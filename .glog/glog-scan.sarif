{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-7e7316d2-9d32-42d9-a76f-b9fbb66300bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `in_out->base_display_config` is larger than `in_out->optimized_display_config`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(in_out->base_display_config) <= sizeof(in_out->optimized_display_config)) {\n    memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: source is larger than destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-48fe3ff9-78c9-4718-b899-66b25826b1df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nmemcpy_s(in_out->optimized_display_cfg, sizeof(struct dml2_display_cfg), in_out->display_config, sizeof(struct dml2_display_cfg));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that all links were checked and are active as of the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b5ba3b0c-1e23-4d89-80ff-aed5f0945e2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(in_out->optimized_display_config) >= sizeof(struct display_configuation_with_meta)) {\n    memcpy(in_out->optimized_display_config,\n        in_out->base_display_config,\n        sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `optimized_display_config` is large enough to hold the data from `base_display_config`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-64da965d-12ce-445d-8993-9b62eb8b50ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vprintf`.\n\nThe `vprintf` function is a variant of `printf` that takes a `va_list` of arguments instead of a variable number of arguments. This function does not check the length of the output against the size of the buffer, which can lead to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\nAvoid using `vprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that include bounds checking, such as `vsnprintf`. Always ensure that your buffers are large enough to hold any data that may be written to them.\n\n## Source Code Fix Recommendation\n\nReplace the use of `vprintf` with `vsnprintf`. Here is an example:\n\n```cpp\n#include <cstdarg>\n#include <cstdio>\n\nvoid safe_printf(const char *format, ...) {\n    va_list args;\n    char buffer[1024];\n\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n\n    printf(\"%s\", buffer);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdarg>`: Provides macros to handle variable arguments.\n- `<cstdio>`: Provides input and output facilities.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a5236791-c130-4f4f-bc03-1b6309dc2791",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(svp_expanded_display_cfg) >= sizeof(struct dml2_display_cfg)) {\n    memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4a443e20-98ff-4267-af1d-cf3afdaf35aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `main` to `phantom` based on the size of `struct dml2_stream_parameters`. If the size of `struct dml2_stream_parameters` is larger than the size of `phantom`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(struct dml2_stream_parameters) <= sizeof(phantom)) {\n    memcpy(phantom, main, sizeof(struct dml2_stream_parameters));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `struct dml2_stream_parameters` is less than or equal to the size of `phantom`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc02232b-69ad-445a-aa7e-680ce26bd6b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&dml->ip_caps, sizeof(struct dml2_ip_capabilities), &in_out->ip_caps, sizeof(struct dml2_ip_capabilities));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a262a299-348f-429b-a198-d6c284505227",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&dml->ip_caps, sizeof(struct dml2_ip_capabilities), &in_out->ip_caps, sizeof(struct dml2_ip_capabilities));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a4284bb7-bacd-4a1c-b3dc-e37e6e2fcf93",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, `memcpy` will overwrite adjacent memory, leading to undefined behavior, crashes, or potential code execution.\n\nIn the provided code snippet, the vulnerability could occur if the size of `dml->soc_bbox` is smaller than the size of `in_out->soc_bb`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to write past it.\n\n## Source Code Fix Recommendation\n\nA potential fix for the provided code snippet could be:\n\n```cpp\nif (sizeof(dml->soc_bbox) >= sizeof(in_out->soc_bb)) {\n    memcpy(&dml->soc_bbox, &in_out->soc_bb, sizeof(struct dml2_soc_bb));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f25d5c77-1f8d-4e01-be1d-baff891c8759",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `optimized_display_config_with_meta` is larger than `base_display_config_with_meta`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(l->base_display_config_with_meta) >= sizeof(l->optimized_display_config_with_meta)) {\n    memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-80061067-e61e-4635-83fc-94d04d19e85c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `main` to `phantom` based on the size of `struct dml2_plane_parameters`. If the size of `struct dml2_plane_parameters` is larger than the size of `phantom`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data being copied before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(phantom) >= sizeof(struct dml2_plane_parameters)) {\n    memcpy(phantom, main, sizeof(struct dml2_plane_parameters));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `phantom` is large enough to hold the data being copied. If it is, we proceed with the `memcpy` function. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-28e7c552-f8b0-458b-ada4-7c6570d72bfa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `optimized_display_config_with_meta` is larger than `base_display_config_with_meta`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(l->base_display_config_with_meta) >= sizeof(l->optimized_display_config_with_meta)) {\n    memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-00a8cc0e-7f88-452e-a456-ac08d7c6e11a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `optimized_display_config_with_meta` is larger than `base_display_config_with_meta`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(l->base_display_config_with_meta) >= sizeof(l->optimized_display_config_with_meta)) {\n    memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e5bacf71-53c5-4a9c-aaa4-d04e6ebc54a3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `optimized_display_config_with_meta` is larger than `base_display_config_with_meta`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(l->base_display_config_with_meta) >= sizeof(l->optimized_display_config_with_meta)) {\n    memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b1ad0b81-b7d6-4164-a530-74f0b5970a1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `optimized_display_config_with_meta` is larger than `base_display_config_with_meta`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(l->base_display_config_with_meta) >= sizeof(l->optimized_display_config_with_meta)) {\n    memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-48535670-639d-4f07-8f4e-b99af6c640e5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(in_out->programming->display_config) >= sizeof(struct dml2_display_cfg)) {\n    memcpy(&in_out->programming->display_config, in_out->display_config, sizeof(struct dml2_display_cfg));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is large enough to hold the data from the source buffer. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included for the code to compile and run properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cb8955af-c525-4d59-8243-3493b5ffbe89",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a potential buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function copies a certain number of bytes from a source memory area to a destination memory area. If the source area is larger than the destination area, this can lead to a buffer overflow, which can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(params->allocations[i].global_mcache_ids_mall_plane1);\nif (size <= sizeof(params->allocations[i].global_mcache_ids_plane1)) {\n    memcpy(params->allocations[i].global_mcache_ids_mall_plane1, params->allocations[i].global_mcache_ids_plane1, size);\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this version of the code, we first calculate the size of the destination buffer and then check if it is less than or equal to the size of the source buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c913294c-388a-44ff-966d-d57460becc82",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer `params->allocations[i].global_mcache_ids_mall_plane0` is assumed to be the same as the size of the source buffer `params->allocations[i].global_mcache_ids_plane0`. This assumption can lead to a buffer overflow if the size of the source buffer is larger than the size of the destination buffer.\n\nA safer approach would be to determine the size of the destination buffer and the source buffer, and then copy the smaller of the two sizes. Here is a possible fix:\n\n```cpp\nsize_t size = sizeof(params->allocations[i].global_mcache_ids_mall_plane0);\nif (size > sizeof(params->allocations[i].global_mcache_ids_plane0)) {\n    size = sizeof(params->allocations[i].global_mcache_ids_plane0);\n}\nmemcpy(params->allocations[i].global_mcache_ids_mall_plane0, params->allocations[i].global_mcache_ids_plane0, size);\n```\n\n## Library Dependencies\n\nThe provided code does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-64828990-6d17-4554-9afb-8e4c14c4be55",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(bool);\nif (size <= sizeof(params->display_config->stage2.per_plane_mcache_support)) {\n    memcpy(params->display_config->stage2.per_plane_mcache_support, l->test_mcache.validate_admissibility_params.per_plane_status, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f52da1fa-a129-4683-a4eb-fc1b88c346de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nstruct display_configuration_with_meta src;\nstruct display_configuration_with_meta dst;\n\n// Ensure dst is large enough to hold src\nif(sizeof(dst) >= sizeof(src)) {\n    memcpy(&dst, &src, sizeof(src));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only dependency required to use it is:\n\n- `#include <cstring>`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a2c1db31-0e5a-43ac-ac9f-d95705827b6a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `display_config` is larger than the size of `out->display_config`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of bytes to be copied. This can prevent buffer overflow attacks by ensuring that no more data is copied than the destination buffer can hold.\n\nHere is how you can modify the provided code snippet to use `strncpy`:\n\n```cpp\nstrncpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c89b05c3-3de0-41f4-981e-251f31f0f8fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `display_config` is larger than the size of `out->display_config`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of bytes to be copied. This can prevent buffer overflow attacks by ensuring that no more data is copied than the destination buffer can hold.\n\nHere is how you can modify the provided code snippet to use `strncpy`:\n\n```cpp\nstrncpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5d58065a-bf1e-4607-8d1c-cf86cba4a171",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `in_out->base_display_config` is larger than `in_out->optimized_display_config`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(in_out->base_display_config) <= sizeof(in_out->optimized_display_config)) {\n    memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: source is larger than destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-930c9b68-303e-4461-a78b-c97cf648370a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `in_out->base_display_config` is larger than `in_out->optimized_display_config`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(in_out->base_display_config) <= sizeof(in_out->optimized_display_config)) {\n    memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error: source is larger than destination\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-96d93bfa-bec6-475e-9b93-c0ae0d1e40bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that the size of `display_config->stage3.stream_svp_meta[stream_index]` is at least as large as `scratch->pmo_dcn4.stream_svp_meta[stream_index]`. If this is not the case, a buffer overflow could occur. To fix this, you could add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(display_config->stage3.stream_svp_meta[stream_index]) >= sizeof(scratch->pmo_dcn4.stream_svp_meta[stream_index])) {\n    memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n        &scratch->pmo_dcn4.stream_svp_meta[stream_index],\n        sizeof(struct dml2_implicit_svp_meta));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-17126a98-da0f-4ee0-9a35-2469f58106b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that `sizeof(struct dml2_fams2_meta)` is the correct size for both source and destination buffers. If this is not the case, you should adjust the size accordingly. If you are unsure about the sizes, consider using a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&display_config->stage3.stream_fams2_meta, sizeof(display_config->stage3.stream_fams2_meta),\n         &scratch->pmo_dcn4.stream_fams2_meta, sizeof(scratch->pmo_dcn4.stream_fams2_meta));\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies other than the standard C++ libraries. However, the structures being used (`dml2_fams2_meta`, `display_config`, `scratch`) are not defined, and may require additional libraries or headers.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-38ad753d-6092-4e10-a931-25c0154e0d57",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that the size of `display_config->stage3.stream_svp_meta[stream_index]` is at least as large as `scratch->pmo_dcn4.stream_svp_meta[stream_index]`. If this is not the case, a buffer overflow could occur. To fix this, you could add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(display_config->stage3.stream_svp_meta[stream_index]) >= sizeof(scratch->pmo_dcn4.stream_svp_meta[stream_index])) {\n    memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n        &scratch->pmo_dcn4.stream_svp_meta[stream_index],\n        sizeof(struct dml2_implicit_svp_meta));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2c3e6fef-2433-4e9d-99fd-f73801718060",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(in_out->optimized_display_config) >= sizeof(struct display_configuation_with_meta)) {\n    memcpy(in_out->optimized_display_config,\n        in_out->base_display_config,\n        sizeof(struct display_configuation_with_meta));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `optimized_display_config` is large enough to hold the data from `base_display_config`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c606048d-af4c-4bab-95d0-10be435c6a6e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `base_strategy` is larger than `variant_strategy`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(base_strategy) <= sizeof(variant_strategy)) {\n    memcpy(&variant_strategy, base_strategy, sizeof(struct dml2_pmo_pstate_strategy));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `base_strategy` is less than or equal to the size of `variant_strategy`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a future date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ffd84251-702a-480e-a654-e72b337e3b43",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nunsigned int size = sizeof(unsigned int);\nif (sizeof(num_streams_per_base_method) >= size) {\n    memcpy(num_streams_per_base_method, num_streams_per_method, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer `num_streams_per_base_method` is large enough to hold the data from `num_streams_per_method`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6c0bd394-0fae-47d3-baa3-bd3c33a50d5f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nmemcpy_s(in_out->optimized_display_cfg, sizeof(struct dml2_display_cfg), in_out->display_config, sizeof(struct dml2_display_cfg));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that all links were checked and are active as of the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ddfecf4a-0b07-4eb2-af86-46672a7511bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `per_stream_pstate_strategy` to `expanded_strategy_list[*num_expanded_strategies]`. If the size of `per_stream_pstate_strategy` is larger than the size of `expanded_strategy_list[*num_expanded_strategies]`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(struct dml2_pmo_pstate_strategy);\nif (*num_expanded_strategies + size <= sizeof(expanded_strategy_list)) {\n    memcpy(&expanded_strategy_list[*num_expanded_strategies], per_stream_pstate_strategy, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied. Then, we check if the destination buffer has enough space to hold the data. If it does, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-68c7f283-0baa-4e83-8de4-72b48187a62c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, it is not clear whether the size of `in_out->programming->plane_programming[plane_index].mcache_allocation` is less than, equal to, or greater than `sizeof(struct dml2_mcache_surface_allocation)`. To fix the potential vulnerability, you should ensure that the destination buffer is large enough to hold the copied data.\n\n```cpp\nif (sizeof(in_out->programming->plane_programming[plane_index].mcache_allocation) >= sizeof(struct dml2_mcache_surface_allocation)) {\n    memcpy(&in_out->programming->plane_programming[plane_index].mcache_allocation,\n           &in_out->display_cfg->stage2.mcache_allocations[plane_index],\n           sizeof(struct dml2_mcache_surface_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to depend on a custom library that defines the `in_out` structure and the `dml2_mcache_surface_allocation` structure. Without more context, it's not possible to list all library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-34538d93-1e01-4792-b18e-aa4ae98d8e6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often leading to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, or `memcpy_s` (in C11) are safer alternatives as they take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative. For example, if you are using C11 or later, you can use `memcpy_s`:\n\n```cpp\nmemcpy_s(&in_out->programming->display_config, sizeof(struct dml2_display_cfg), in_out->display_cfg, sizeof(struct dml2_display_cfg));\n```\n\nIf you are not using C11 or later, you can use a combination of `sizeof` and `min` to ensure that you do not exceed the size of the destination buffer:\n\n```cpp\nsize_t size = min(sizeof(in_out->programming->display_config), sizeof(struct dml2_display_cfg));\nmemcpy(&in_out->programming->display_config, in_out->display_cfg, size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h` for `memcpy`\n- `stdlib.h` for `size_t`\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ee197b29-af0a-4e14-98a1-6d089c23a002",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, it is assumed that the size of `struct dml2_mcache_surface_allocation` is less than or equal to the size of the destination buffer. To ensure this, you can add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(struct dml2_mcache_surface_allocation) <= sizeof(programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation)) {\n    memcpy(&programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation,\n        &programming->plane_programming[main_plane_index].mcache_allocation,\n        sizeof(struct dml2_mcache_surface_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bcd7fd2b-d62b-4d65-a4ff-50cab4197a5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(programming->plane_programming[main_plane_index].phantom_plane.descriptor) >= sizeof(struct dml2_plane_parameters)) {\n    memcpy(&programming->plane_programming[main_plane_index].phantom_plane.descriptor, phantom_plane, sizeof(struct dml2_plane_parameters));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-aa0b1438-f25e-4eab-960a-abb52c708b09",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer and the size of the source buffer are the same, so there is no buffer overflow. However, it is still a good practice to check the size of the buffers before calling `memcpy`. Here is a possible fix:\n\n```cpp\nif (sizeof(programming->plane_programming[plane_index].mcache_allocation) >= sizeof(display_cfg->stage2.mcache_allocations[plane_index])) {\n    memcpy(&programming->plane_programming[plane_index].mcache_allocation,\n        &display_cfg->stage2.mcache_allocations[plane_index],\n        sizeof(struct dml2_mcache_surface_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the following libraries:\n\n- A library that defines the `memcpy` function, such as `<cstring>` or `<string.h>`\n- A library that defines the `dml2_mcache_surface_allocation` struct. This is likely a custom library specific to the application.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-364113a8-6b44-4166-a7b3-5271f2a134e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow or cause denial-of-service conditions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `strncat`, `snprintf`, and `vsnprintf` are safer alternatives as they take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative. For example, you can use `strncpy` as follows:\n\n```cpp\nstrncpy(programming->stream_programming[stream_index].phantom_stream.descriptor, phantom_stream, sizeof(struct dml2_stream_parameters));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` and `strncpy` functions.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that all links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-13ac954b-4518-4f67-854b-57e91db79964",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(programming->display_config) >= sizeof(display_cfg->display_config)) {\n    memcpy(&programming->display_config, &display_cfg->display_config, sizeof(struct dml2_display_cfg));\n} else {\n    // Handle the error case where the destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef8a0037-3608-42a0-979d-c3131901301e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(svp_expanded_display_cfg) >= sizeof(struct dml2_display_cfg)) {\n    memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-511d0da6-de47-499d-a089-0b3f0b9b1513",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `main` to `phantom` based on the size of `struct dml2_plane_parameters`. If the size of `struct dml2_plane_parameters` is larger than the size of `phantom`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data being copied before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(phantom) >= sizeof(struct dml2_plane_parameters)) {\n    memcpy(phantom, main, sizeof(struct dml2_plane_parameters));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `phantom` is large enough to hold the data being copied. If it is, we proceed with the `memcpy` function. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-76883674-5116-4edf-86de-e649de7adb89",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `main` to `phantom` based on the size of `struct dml2_stream_parameters`. If the size of `struct dml2_stream_parameters` is larger than the size of `phantom`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(struct dml2_stream_parameters) <= sizeof(phantom)) {\n    memcpy(phantom, main, sizeof(struct dml2_stream_parameters));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `struct dml2_stream_parameters` is less than or equal to the size of `phantom`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1609de2d-75d0-4e0e-96cb-bfbbfc7b52e5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `core->clean_me_up.mode_lib.soc` is greater than or equal to the size of `in_out->soc_bb`. To fix this vulnerability, you should add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(core->clean_me_up.mode_lib.soc) >= sizeof(struct dml2_soc_bb)) {\n    memcpy(&core->clean_me_up.mode_lib.soc, in_out->soc_bb, sizeof(struct dml2_soc_bb));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code snippet provided does not clearly indicate any specific library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c1664db8-fdf7-41d2-bb54-9680de012bb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(core->clean_me_up.mode_lib.ip_caps) >= sizeof(in_out->ip_caps)) {\n    memcpy(&core->clean_me_up.mode_lib.ip_caps, in_out->ip_caps, sizeof(struct dml2_ip_capabilities));\n} else {\n    // Handle the error condition when the destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly indicate any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3d580193-7236-4ea8-bf7e-f2fd66b3d250",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nWithout the full context of the code, it's hard to provide a specific fix. However, a general fix would be to add a check before the `memcpy` call to ensure the destination buffer is large enough. If the `dml2_core_ip_params` struct is larger than `core->clean_me_up.mode_lib.ip`, you should resize `core->clean_me_up.mode_lib.ip` before the `memcpy` call.\n\n```cpp\nif (sizeof(core->clean_me_up.mode_lib.ip) < sizeof(struct dml2_core_ip_params)) {\n    // Resize core->clean_me_up.mode_lib.ip or handle the error appropriately\n}\nmemcpy(&core->clean_me_up.mode_lib.ip, &core_dcn4_ip_caps_base, sizeof(struct dml2_core_ip_params));\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly show any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` or `<string.h>` header file.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0f7db18d-d81d-406b-974d-91fccc9023a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the destination can hold, preventing buffer overflow.\n\n```cpp\nif (in_out->explicit_ip_bb_size <= sizeof(core->clean_me_up.mode_lib.ip)) {\n    memcpy_s(&core->clean_me_up.mode_lib.ip, sizeof(core->clean_me_up.mode_lib.ip), in_out->explicit_ip_bb, in_out->explicit_ip_bb_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b09e340e-a31c-49f7-ac04-60f954327144",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-33e43961-bff7-4fc8-a42b-f6d2406921cd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3913f997-e720-458d-bbb1-32167ed402b2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(dpcd_data, ext_cap_data, sizeof(dpcd_data))`, if the size of `ext_cap_data` is larger than `dpcd_data`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(dpcd_data);\nif (sizeof(ext_cap_data) <= size) {\n    memcpy(dpcd_data, ext_cap_data, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `ext_cap_data` is less than or equal to the size of `dpcd_data`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c2c80c2d-bc6c-4040-9be2-299f8a6caef8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c45927d2-3bd8-478c-b41d-6c738761fbc8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d4501ee4-221a-4c63-bdca-6ee655b2383f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `clock_limits` to `dcn3_51_soc.clock_limits`. If the size of `clock_limits` is larger than `dcn3_51_soc.clock_limits`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(clock_limits) <= sizeof(dcn3_51_soc.clock_limits)) {\n    memcpy(dcn3_51_soc.clock_limits, clock_limits, sizeof(dcn3_51_soc.clock_limits));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `clock_limits` is less than or equal to the size of `dcn3_51_soc.clock_limits`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c3e26378-de1c-4cf2-85b5-1a808827c74d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions like `strncpy`, `snprintf`, and `memcpy_s` (in C11) are safer alternatives as they take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative. For example, if you are using C11 or later, you can use `memcpy_s`:\n\n```cpp\nmemcpy_s(&pipe->bottom_pipe->stream_res, sizeof(pipe->bottom_pipe->stream_res), &pipe->bottom_pipe->top_pipe->stream_res, sizeof(struct stream_resource));\n```\n\nIf you are not using C11 or later, you can use `strncpy` or `snprintf` instead, but be aware that these functions behave differently and may not be suitable for all situations.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h` for the `memcpy` function\n- `stddef.h` for the `sizeof` operator\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6a8a0599-27e8-4a81-8db9-f6251926690f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7bbff306-59ab-414d-aebb-83de26152ebf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5e298b9d-5e6a-4e3c-ba03-3e50f16029a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior, crashes, data corruption, and even allow execution of arbitrary code.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(&extended_data[offset], reduced_data, reduced_size);\n```\n\nIf `reduced_size` is greater than the size of `extended_data` minus `offset`, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source buffer before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (offset + reduced_size <= sizeof(extended_data)) {\n    memcpy(&extended_data[offset], reduced_data, reduced_size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fixed code, we first check if the destination buffer (`extended_data`) is large enough to hold the data being copied from `reduced_data`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c6976515-d558-4260-8db6-9691ec0a2e16",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `s` is larger than `dcn3_16_soc.clock_limits`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(dcn3_16_soc.clock_limits);\nif (sizeof(s) <= size) {\n    memcpy(dcn3_16_soc.clock_limits, s, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `s` is less than or equal to the size of `dcn3_16_soc.clock_limits`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4fc61bf8-1b73-41b6-9b11-a7722df6283b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `clock_limits` to `dcn3_5_soc.clock_limits`. If the size of `clock_limits` is larger than `dcn3_5_soc.clock_limits`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(clock_limits) <= sizeof(dcn3_5_soc.clock_limits)) {\n    memcpy(dcn3_5_soc.clock_limits, clock_limits, sizeof(dcn3_5_soc.clock_limits));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `clock_limits` is less than or equal to the size of `dcn3_5_soc.clock_limits`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-984b5684-3dd0-44e5-85cf-da1d7972fd64",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the `memcpy` function is copying the contents of `dcn3_16_soc.clock_limits` into `s`. If the size of `s` is smaller than `dcn3_16_soc.clock_limits`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(s) >= sizeof(dcn3_16_soc.clock_limits)) {\n    memcpy(s, dcn3_16_soc.clock_limits, sizeof(dcn3_16_soc.clock_limits));\n} else {\n    // Handle the error condition when s is not large enough\n}\n```\n\nIn this fixed code, we first check if `s` is large enough to hold the data from `dcn3_16_soc.clock_limits`. If it is, we proceed with the `memcpy`. If not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e951bfa5-0533-4dc8-8041-a7aa224f5048",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `s` to `dcn3_1_soc.clock_limits`. If the size of `s` is larger than `dcn3_1_soc.clock_limits`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of characters to be copied. Here's how you can modify the code:\n\n```cpp\nstrncpy(dcn3_1_soc.clock_limits, s, sizeof(dcn3_1_soc.clock_limits));\ndcn3_1_soc.clock_limits[sizeof(dcn3_1_soc.clock_limits) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(dcn3_1_soc.clock_limits) - 1` characters from `s` to `dcn3_1_soc.clock_limits`, and then manually null-terminate the string.\n\n## Library Dependencies\n\nThe `memcpy` and `strncpy` functions are part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4b3cdd5b-04b0-46b8-a22c-965a976db723",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dcn3_1_soc.clock_limits` is larger than the size of `s`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(s) >= sizeof(dcn3_1_soc.clock_limits)) {\n    memcpy(s, dcn3_1_soc.clock_limits, sizeof(dcn3_1_soc.clock_limits));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this code, we first check if the size of `s` is larger or equal to the size of `dcn3_1_soc.clock_limits`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bf6e3c1a-5986-4262-9cdd-0b5a2f9dc0cf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the source (s) is larger than the destination (dcn2_1_soc.clock_limits). This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the source is not larger than the destination. This can be done by checking the size of both before calling `memcpy`. Additionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\nif (sizeof(s) <= sizeof(dcn2_1_soc.clock_limits)) {\n    memcpy(&dcn2_1_soc.clock_limits, s, sizeof(dcn2_1_soc.clock_limits));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f78e8c80-4a0a-41b2-92ca-37f9e9c8ce11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of `dcn2_1_soc.clock_limits` is being used as the size parameter for `memcpy`. If the size of `s` is smaller than `dcn2_1_soc.clock_limits`, this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(s) >= sizeof(dcn2_1_soc.clock_limits)) {\n    memcpy(s, dcn2_1_soc.clock_limits, sizeof(dcn2_1_soc.clock_limits));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `s` is larger or equal to the size of `dcn2_1_soc.clock_limits`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a664f068-893c-46ee-afda-bf2f8acbc25e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `memcpy_s` or `strncpy` which include a length parameter to avoid buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `bb->clock_limits[num_calculated_states]` is greater than or equal to the size of `bb->clock_limits[num_calculated_states - 1]`. To fix this, you should add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(bb->clock_limits[num_calculated_states]) >= sizeof(bb->clock_limits[num_calculated_states - 1])) {\n    memcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies other than the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7d5584a3-85ae-4110-99b0-b9d3a32ecfb3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the vulnerability lies in the `memcpy` function:\n\n```cpp\nmemcpy(qps, table[index].qps, sizeof(qp_set));\n```\n\nThe `memcpy` function is copying the content of `table[index].qps` into `qps` without checking if the size of `table[index].qps` is larger than `qps`. This can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy` which includes the size of the destination as a parameter. Here is how you can modify the code to use `strncpy`:\n\n```cpp\nstrncpy(qps, table[index].qps, sizeof(qp_set));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-41805cb0-0007-42c8-84d0-4795d51c8435",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying 32 bytes of data from `dsc_packed_pps[i * 32]` to `pps_sdp.sb`. If the size of `pps_sdp.sb` is less than 32 bytes, this could result in a buffer overflow, leading to potential code execution, denial of service, or information disclosure vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(pps_sdp.sb) >= 32) {\n    memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7bf7180c-d7fa-473a-bf20-c97b29cfedcd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dcn3_01_soc.clock_limits` is larger than the size of `s`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(s) >= sizeof(dcn3_01_soc.clock_limits)) {\n    memcpy(s, dcn3_01_soc.clock_limits, sizeof(dcn3_01_soc.clock_limits));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-107ebb80-9e1b-42ca-975a-a7f4fd117752",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the source buffer size is larger than the destination buffer size. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the vulnerability arises if the size of the source buffer `s` is larger than the size of the destination buffer `dcn3_01_soc.clock_limits`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the source buffer is not larger than the destination buffer. This can be done by checking the size of the source buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(dcn3_01_soc.clock_limits);\nif (sizeof(s) <= size) {\n    memcpy(dcn3_01_soc.clock_limits, s, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1ed278d9-88f1-49ee-9c78-4d70ade2a3f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dc->dml2_options` is larger than the size of `dml2_opt`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml2_opt) >= sizeof(dc->dml2_options)) {\n    memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e48b3df3-6338-4ef6-ba3a-9d9dc3ec526a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix could be to add a check for the size of the destination buffer before the `memcpy` call:\n\n```cpp\nif (sizeof(phantom_stream->dst) >= sizeof(ref_pipe->stream->dst)) {\n    memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst));\n} else {\n    // Handle the error condition, e.g., by logging an error message or throwing an exception\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-15da87fb-b39d-4922-aeca-329694820029",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, `memcpy` will overwrite adjacent memory, leading to undefined behavior, crashes, or even code execution.\n\nIn the provided code snippet, the vulnerability could occur if the size of `ref_pipe->stream->src` is larger than `phantom_stream->src`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif(sizeof(phantom_stream->src) >= sizeof(ref_pipe->stream->src)) {\n    memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-40bb803a-edbf-4e89-90a5-36e05f898bf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `curr_pipe->plane_state->dcc` is larger than `phantom_plane->dcc`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(curr_pipe->plane_state->dcc) <= sizeof(phantom_plane->dcc)) {\n    memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-061e6eb8-cecb-4a76-9b40-6ab94221b2aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`phantom_stream->timing`) is assumed to be the same as the size of the source buffer (`ref_pipe->stream->timing`). This assumption could lead to buffer overflow if it's not correct.\n\nA safer version of the code would look like this:\n\n```cpp\nif (sizeof(phantom_stream->timing) >= sizeof(ref_pipe->stream->timing)) {\n    memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(ref_pipe->stream->timing));\n} else {\n    // Handle the error condition when the destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-00c513db-3d8e-4ad8-815c-8532ed86a093",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes buffer size checks. For example:\n\n```cpp\nif(sizeof(phantom_plane->tiling_info) >= sizeof(curr_pipe->plane_state->tiling_info)) {\n    memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info, sizeof(phantom_plane->tiling_info));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required for this code to execute.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-41621996-e8bf-4aa3-a1d1-49a9d1fd3b20",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer and the size of the destination buffer are not properly checked. In the provided code snippet, the `memcpy` function is copying the size of `curr_pipe->plane_state->plane_size` into `phantom_plane->plane_size`. If the size of `curr_pipe->plane_state->plane_size` is larger than `phantom_plane->plane_size`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source buffer and the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(phantom_plane->plane_size) >= sizeof(curr_pipe->plane_state->plane_size)) {\n    memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size, sizeof(phantom_plane->plane_size));\n} else {\n    // Handle the error condition when the destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c91e3120-cbe7-4115-ab9e-5835686ab471",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is assumed to be the same as the size of the source buffer. This assumption can lead to buffer overflow if the source buffer is larger than the destination buffer. To fix this, you should check the size of the destination buffer before calling `memcpy`.\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(phantom_plane->dst_rect) >= sizeof(curr_pipe->plane_state->dst_rect)) {\n    memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` header file to use this function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-255b365c-780e-4bc7-9869-d4d28576bc5c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy the content of `curr_pipe->plane_state->clip_rect` to `phantom_plane->clip_rect`. If the size of `curr_pipe->plane_state->clip_rect` is larger than `phantom_plane->clip_rect`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. Alternatively, you can use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which checks the size of the destination buffer:\n\n```cpp\nmemcpy_s(&phantom_plane->clip_rect, sizeof(phantom_plane->clip_rect), &curr_pipe->plane_state->clip_rect, sizeof(curr_pipe->plane_state->clip_rect));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required for the code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef7dfa71-abbf-422c-80f0-ae2dfb251a7c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and unauthorized access to system memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11). These functions prevent buffer overflow by not copying more than the specified size. Additionally, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`:\n\n```cpp\nmemcpy_s(&phantom_plane->src_rect, sizeof(phantom_plane->src_rect), &curr_pipe->plane_state->src_rect, sizeof(curr_pipe->plane_state->src_rect));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for the `memcpy` function\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-25f5bbc5-2ff0-4d53-bb4b-c8d9bf46d3cc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which checks the size of the destination buffer:\n\n```cpp\nmemcpy_s(&phantom_plane->scaling_quality, sizeof(phantom_plane->scaling_quality), &curr_pipe->plane_state->scaling_quality, sizeof(curr_pipe->plane_state->scaling_quality));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7901251d-86b5-4811-a35c-78f4807af050",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dc->dml2_options` is larger than the size of `dml2_opt`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml2_opt) >= sizeof(dc->dml2_options)) {\n    memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-63d35e1f-dd6a-4ef5-bc4f-50cb0880c8d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`phantom_plane->address`) is assumed to be the same as the size of the source buffer (`curr_pipe->plane_state->address`). This assumption could lead to buffer overflow if it's not correct.\n\nA safer version of the code would look like this:\n\n```cpp\nsize_t size = sizeof(phantom_plane->address);\nif (size <= sizeof(curr_pipe->plane_state->address)) {\n    memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, size);\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9f6feec1-6aa1-4848-bc8f-c092395f4be1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dc->dml2_options` is larger than the size of `dml2_opt`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml2_opt) >= sizeof(dc->dml2_options)) {\n    memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0fe05bc1-d69b-4074-8a30-27993d9011d5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(clk_mgr->max_clks_by_state) >= sizeof(dce80_max_clks_by_state)) {\n    memcpy(clk_mgr->max_clks_by_state,\n           dce80_max_clks_by_state,\n           sizeof(dce80_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ed8626fb-7bcb-46c7-af55-19680bd27880",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `dcn10_ip_defaults` to `dc->dcn_ip`. If the size of `dcn10_ip_defaults` is larger than the size of `dc->dcn_ip`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`. If the source data is larger, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dc->dcn_ip) >= sizeof(dcn10_ip_defaults)) {\n    memcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this updated code, we first check if the size of `dc->dcn_ip` is larger or equal to the size of `dcn10_ip_defaults`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8c318c72-a62d-43a7-8637-d30b79c716a3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dcn10_soc_defaults` is larger than the size of `dc->dcn_soc`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dcn10_soc_defaults) <= sizeof(dc->dcn_soc)) {\n    memcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `dcn10_soc_defaults` is less than or equal to the size of `dc->dcn_soc`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a78eccdc-d9d2-481a-be09-dee28edf7650",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that the size of `struct dmub_cmd_fams2_global_config` is less than or equal to the size of the destination buffer. To ensure this, you can add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(struct dmub_cmd_fams2_global_config) <= sizeof(context->bw_ctx.bw.dcn.fams2_global_config)) {\n    memcpy(&context->bw_ctx.bw.dcn.fams2_global_config,\n           &dml_ctx->v21.mode_programming.programming->fams2_global_config,\n           sizeof(struct dmub_cmd_fams2_global_config));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, `memcpy` is part of the C standard library, so it should work in any environment that supports C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-225fcbf5-a40a-43bb-aa11-c828aedf37bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `static_sub_state` is not checked before the `memcpy` function is called. To fix this, you should add a check to ensure that the size of `static_sub_state` is greater than or equal to the size of the source buffer. Here is a possible fix:\n\n```cpp\nif (sizeof(static_sub_state) >= sizeof(dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params)) {\n    memcpy(static_sub_state,\n        &dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params,\n        sizeof(union dmub_cmd_fams2_config));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what libraries it depends on. However, the `memcpy` function is part of the C standard library, so the program would at least need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a future date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2221eb4a-f1ba-45a6-954f-ded00bfd1515",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer `static_base_state` is not checked before the `memcpy` function is called. To fix this, you should add a check to ensure that the size of `static_base_state` is greater than or equal to the size of the source buffer. Here is a possible fix:\n\n```cpp\nif (sizeof(static_base_state) >= sizeof(union dmub_cmd_fams2_config)) {\n    memcpy(static_base_state,\n        &dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_base_params,\n        sizeof(union dmub_cmd_fams2_config));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included at the top of the file.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-918423ee-d08d-4514-9b8b-800ced02d431",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11). Always ensure that the destination buffer is large enough to hold the copied data. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstring>\n\nif (sizeof(main_plane->tiling_info) <= sizeof(phantom_plane->tiling_info)) {\n    memcpy(&phantom_plane->tiling_info, &main_plane->tiling_info, sizeof(phantom_plane->tiling_info));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-673039c1-8cd4-4d93-b9a2-577ab884e312",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer is larger than the destination buffer. In the provided code snippet, if the size of `main_plane->dcc` is larger than `phantom_plane->dcc`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of both buffers before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `memcpy_s`:\n\n```cpp\n#include <string.h> // for memcpy_s\n\n// ...\n\nif(sizeof(main_plane->dcc) <= sizeof(phantom_plane->dcc)) {\n    memcpy_s(&phantom_plane->dcc, sizeof(phantom_plane->dcc), &main_plane->dcc, sizeof(main_plane->dcc));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ff5e1a93-7857-4836-a953-025da56a4b28",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if `main_plane->plane_size` is larger than `phantom_plane->plane_size`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(main_plane->plane_size) <= sizeof(phantom_plane->plane_size)) {\n    memcpy(&phantom_plane->plane_size, &main_plane->plane_size, sizeof(phantom_plane->plane_size));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `main_plane->plane_size` is less than or equal to the size of `phantom_plane->plane_size`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef350aed-3ac2-4d8a-8aa5-d57edd056fcd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is checked before `memcpy` is called. However, it is recommended to add an explicit check to ensure that the size of the source buffer does not exceed the size of the destination buffer.\n\n```cpp\nif (sizeof(main_plane->clip_rect) <= sizeof(phantom_plane->clip_rect)) {\n    memcpy(&phantom_plane->clip_rect, &main_plane->clip_rect, sizeof(phantom_plane->clip_rect));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet to execute properly.\n\n## Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bc86cc48-5a8b-47d1-b909-f75b96448541",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is assumed to be the same as the size of the source buffer. This assumption can lead to buffer overflow if it is not correct. To fix this, you should check the size of the destination buffer before calling `memcpy`.\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(phantom_plane->dst_rect) >= sizeof(main_plane->dst_rect)) {\n    memcpy(&phantom_plane->dst_rect, &main_plane->dst_rect, sizeof(main_plane->dst_rect));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7e52e040-41de-49a6-943a-ce7eef0769de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer is larger than the destination buffer. In the provided code, if the size of `main_plane->src_rect` is larger than `phantom_plane->src_rect`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif(sizeof(main_plane->src_rect) <= sizeof(phantom_plane->src_rect)) {\n    memcpy(&phantom_plane->src_rect, &main_plane->src_rect, sizeof(phantom_plane->src_rect));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `main_plane->src_rect` is less than or equal to the size of `phantom_plane->src_rect`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-02ecf688-6155-4dd7-977b-ac6ee3a1e5f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if the size of `main_plane->scaling_quality` is larger than `phantom_plane->scaling_quality`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. Also, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\n#include <string.h> // for memcpy_s\n\n// ...\n\nif (sizeof(main_plane->scaling_quality) <= sizeof(phantom_plane->scaling_quality)) {\n    memcpy_s(&phantom_plane->scaling_quality, sizeof(phantom_plane->scaling_quality), &main_plane->scaling_quality, sizeof(main_plane->scaling_quality));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-863f5bd6-be56-4ff8-a694-14852b947dce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `main_plane->address` is larger than `phantom_plane->address`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(main_plane->address) <= sizeof(phantom_plane->address)) {\n    memcpy(&phantom_plane->address, &main_plane->address, sizeof(phantom_plane->address));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-58ee6609-8251-4f08-bbcd-795bea496fb0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer and the size of the destination buffer are not properly checked. In the provided code snippet, the `memcpy` function is copying data from `main_stream->dst` to `phantom_stream->dst` without checking if the size of `main_stream->dst` is greater than the size of `phantom_stream->dst`. This can lead to a buffer overflow vulnerability, which can cause the program to crash or, in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source buffer and the size of the destination buffer before calling the `memcpy` function. If the size of the source buffer is greater than the size of the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(main_stream->dst) <= sizeof(phantom_stream->dst)) {\n    memcpy(&phantom_stream->dst, &main_stream->dst, sizeof(phantom_stream->dst));\n} else {\n    // Handle the error condition here\n}\n```\n\nIn this fixed code, we first check if the size of `main_stream->dst` is less than or equal to the size of `phantom_stream->dst`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-72d955f3-b06e-4212-919d-67ca5542d76a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer is larger than the destination buffer. In the provided code snippet, if the size of `main_stream->src` is larger than `phantom_stream->src`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of characters to be copied. Here's how you can modify the code:\n\n```cpp\nstrncpy(&phantom_stream->src, &main_stream->src, sizeof(phantom_stream->src));\nphantom_stream->src[sizeof(phantom_stream->src) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(phantom_stream->src)` characters from `main_stream->src` to `phantom_stream->src`, and then ensure that `phantom_stream->src` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library is required for the `memcpy` and `strncpy` functions.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7cbece57-f8f1-40f8-9f58-302889528cb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The problem arises when the size of the destination buffer is smaller than the source buffer. This can lead to buffer overflow, which is a serious security vulnerability as it can allow an attacker to execute arbitrary code or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the `timing` field in the `phantom_stream` structure is assumed to be the same as the size of the `timing` field in the `main_stream` structure. This assumption may not always hold true, leading to potential buffer overflow. To fix this, you should explicitly check the sizes of the two fields before calling `memcpy`.\n\n```cpp\nif (sizeof(phantom_stream->timing) >= sizeof(main_stream->timing)) {\n    memcpy(&phantom_stream->timing, &main_stream->timing, sizeof(main_stream->timing));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library (`<cstring>` in C++), so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0bb899eb-9253-4072-b150-25be31fea78b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer and the source buffer should be checked before the `memcpy` function is called. Here is a possible fix:\n\n```cpp\nif (sizeof(pipe_ctx->hubp_regs) >= sizeof(struct dml2_dchub_per_pipe_register_set)) {\n    memcpy(&pipe_ctx->hubp_regs, pln_prog->phantom_plane.pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the following libraries:\n\n- A C++ standard library that includes the `memcpy` function.\n- A library or module that defines the `struct dml2_dchub_per_pipe_register_set` type.\n- A library or module that defines the `pipe_ctx` and `pln_prog` objects and their respective types.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9ab63754-4df6-4246-ba01-8112e8601d64",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is used to copy data from `global_sync` to `pipe_ctx->global_sync`. If the size of `global_sync` is larger than the size of `pipe_ctx->global_sync`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be achieved by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` in C++. Additionally, it is also recommended to validate and sanitize all input data to prevent malicious data from being copied into the buffer.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` would be to use `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not copy more data than the buffer can hold, preventing buffer overflow. Here is how you can modify the provided code snippet:\n\n```cpp\nmemcpy_s(&pipe_ctx->global_sync,\n\t\tsizeof(union dml2_global_sync_programming),\n\t\tglobal_sync,\n\t\tsizeof(union dml2_global_sync_programming));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9c7ca281-7aeb-43b1-a2e3-59cfe6cae4cf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(dst_dml2_programming) >= sizeof(struct dml2_display_cfg_programming)) {\n    memcpy(dst_dml2_programming, src_dml_ctx->v21.mode_programming.programming, sizeof(struct dml2_display_cfg_programming));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is large enough to hold the data from the source buffer. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any libraries other than the standard C++ library. However, the structures and variables used in the code (`dst_dml2_programming`, `src_dml_ctx`, `dml2_display_cfg_programming`) are not defined, and may be part of other libraries or custom code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7eea08ec-aafd-4c3e-acf8-86f09d58911a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `pipe_ctx->hubp_regs` is less than, equal to, or greater than the size of `pln_prog->pipe_regs[pipe_reg_index]`. To fix the potential vulnerability, you should ensure that the size of `pipe_ctx->hubp_regs` is at least as large as `sizeof(struct dml2_dchub_per_pipe_register_set)`.\n\n```cpp\n// Ensure that the size of the destination buffer is large enough\nassert(sizeof(pipe_ctx->hubp_regs) >= sizeof(struct dml2_dchub_per_pipe_register_set));\n\n// Then perform the memcpy operation\nmemcpy(&pipe_ctx->hubp_regs, pln_prog->pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set));\n```\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly indicate any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code will need to include the `<cstring>` header file.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b7c97696-7c22-4ced-9b01-2a1346efdbbf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe source code fix would involve checking the size of the destination buffer before the `memcpy` function is called. Here is a possible fix:\n\n```cpp\nsize_t size = sizeof(struct dml2_hubp_pipe_mcache_regs);\nif (size <= sizeof(dc_phantom_pipes[dc_pipe_index]->mcache_regs)) {\n    memcpy(&dc_phantom_pipes[dc_pipe_index]->mcache_regs,\n        l->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_phantom_prog_idx][dc_pipe_index],\n        size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the structures and variables used in the code may be defined in other libraries, which are not specified in the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-46008326-36ba-4345-9c57-65f2808051ad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(dst_dml2_instance) >= sizeof(src_dml_ctx->v21.dml_init.dml2_instance)) {\n    memcpy(dst_dml2_instance, src_dml_ctx->v21.dml_init.dml2_instance, sizeof(struct dml2_instance));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is large enough to hold the data from the source buffer. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1cde1156-e50e-48ad-ad5c-990d5fd7ce24",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `src_dml_ctx` to `dst_dml_ctx` without checking if the size of `src_dml_ctx` is larger than `dst_dml_ctx`. This can lead to a buffer overflow vulnerability, which can be exploited to execute arbitrary code, crash the system, or leak sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. If the source buffer is larger, resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(src_dml_ctx) <= sizeof(dst_dml_ctx)) {\n    memcpy(dst_dml_ctx, src_dml_ctx, sizeof(struct dml2_context));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d10c45d1-c122-4035-b75e-b44738a1b593",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `dc_main_pipes[dc_pipe_index]->mcache_regs` is less than, equal to, or greater than the size of `l->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index]`. If it is less, then a buffer overflow vulnerability exists.\n\nTo fix this, you could add a check before the `memcpy` call to ensure that the destination buffer is large enough:\n\n```cpp\nif (sizeof(dc_main_pipes[dc_pipe_index]->mcache_regs) >= sizeof(l->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index])) {\n    memcpy(&dc_main_pipes[dc_pipe_index]->mcache_regs,\n           l->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index],\n           sizeof(struct dml2_hubp_pipe_mcache_regs));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code snippet provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7c203d95-99a4-44e7-8238-2e724adc9e72",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, it is not clear whether the size of `context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx]` is at least `sizeof(struct dml2_mcache_surface_allocation)`. To fix the potential vulnerability, you should add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx]) >= sizeof(struct dml2_mcache_surface_allocation)) {\n    memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx],\n           &pln_prog->phantom_plane.mcache_allocation,\n           sizeof(struct dml2_mcache_surface_allocation));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to be part of a larger program, and it's not clear from the provided snippet what specific libraries are required. However, the `memcpy` function is part of the standard C library, so at a minimum, the program would need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e16f1ae5-27f1-4a69-87ec-3b28774b3012",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code, a fix could be implemented by adding a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(context->bw_ctx.bw.dcn.arb_regs) >= sizeof(in_ctx->v21.mode_programming.programming->global_regs.arb_regs)) {\n    memcpy(&context->bw_ctx.bw.dcn.arb_regs, &in_ctx->v21.mode_programming.programming->global_regs.arb_regs, sizeof(struct dml2_display_arb_regs));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4c1b1ec3-3c08-4349-bd8d-cec24a628673",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer:\n\n```cpp\nmemcpy_s(wm_regs, sizeof(struct dml2_dchub_watermark_regs),\n         &programming->global_regs.wm_regs[wm_index],\n         sizeof(struct dml2_dchub_watermark_regs));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n- `dml2_dchub_watermark_regs`: This is a custom struct, and its definition should be included in the code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c4fe9058-9829-44e3-9191-0997e7b33c0d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx]` is at least as large as `sizeof(struct dml2_mcache_surface_allocation)`. To fix the potential vulnerability, you should ensure this before the `memcpy` call. If the sizes are not guaranteed to match, consider using a safer function like `memcpy_s`:\n\n```cpp\nif (sizeof(context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx]) >= sizeof(struct dml2_mcache_surface_allocation)) {\n    memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx], &pln_prog->mcache_allocation, sizeof(struct dml2_mcache_surface_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the standard C library, which provides the `memcpy` function. It may also depend on other libraries not visible in the provided snippet, such as libraries defining the `context`, `dml2_mcache_surface_allocation`, and `pln_prog` types.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-313799b2-260f-44b2-bf17-188277feb18e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct dml2_ip_capabilities` is larger than the size of `dml_init->ip_caps`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either increase the size of the buffer or reduce the size of the data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml_init->ip_caps) >= sizeof(struct dml2_ip_capabilities)) {\n    memcpy(&dml_init->ip_caps, ip_caps, sizeof(struct dml2_ip_capabilities));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fix, we first check if the size of `dml_init->ip_caps` is larger or equal to the size of `struct dml2_ip_capabilities`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8e842e29-630c-41c0-874d-38a5e7aedcb1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, or `memcpy_s` (in C11) can be used to prevent buffer overflow. Additionally, always validate the size of the source and destination before copying data.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&dml_init->ip_caps, sizeof(struct dml2_ip_capabilities), &config->external_socbb_ip_params->ip_params, sizeof(struct dml2_ip_capabilities));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` for `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0ef37a4c-49fd-4021-8caa-47adddf753e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `dml_init->soc_bb` is less than, equal to, or greater than the size of `config->external_socbb_ip_params->soc_bb`. To fix the potential vulnerability, you should ensure that the size of `dml_init->soc_bb` is at least as large as `config->external_socbb_ip_params->soc_bb`.\n\n```cpp\nassert(sizeof(dml_init->soc_bb) >= sizeof(config->external_socbb_ip_params->soc_bb));\nmemcpy(&dml_init->soc_bb, &config->external_socbb_ip_params->soc_bb, sizeof(config->external_socbb_ip_params->soc_bb));\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` header file in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5037be97-001d-45af-9134-a22ea1892377",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(dce112_max_clks_by_state);\nif (size <= sizeof(clk_mgr->max_clks_by_state)) {\n    memcpy(clk_mgr->max_clks_by_state, dce112_max_clks_by_state, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the source buffer and then check if the destination buffer is large enough to hold this data. If it is, we proceed with the `memcpy` operation. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-050570f5-77fc-4059-b425-a6fc6d098088",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `qos_params` is larger than the size of `dml_init->soc_bb.qos_parameters`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml_init->soc_bb.qos_parameters) >= sizeof(struct dml2_soc_qos_parameters)) {\n    memcpy(&dml_init->soc_bb.qos_parameters, qos_params, sizeof(struct dml2_soc_qos_parameters));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the destination buffer is large enough to hold the data. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2201bd19-c659-4176-85be-dc5c05ef5c9d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `dml_init->soc_bb` should be checked before calling `memcpy`. If `sizeof(struct dml2_soc_bb)` is larger than the size of `dml_init->soc_bb`, then a buffer overflow could occur. Here is a possible fix:\n\n```cpp\nif (sizeof(dml_init->soc_bb) >= sizeof(struct dml2_soc_bb)) {\n    memcpy(&dml_init->soc_bb, soc_bb, sizeof(struct dml2_soc_bb));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-92607bc0-4eca-4caa-a7f4-bd5d61a567c1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash of the application, or even execution of arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is copying data from `dce110_max_clks_by_state` to `clk_mgr->max_clks_by_state`. If the size of `dce110_max_clks_by_state` is larger than the size of `clk_mgr->max_clks_by_state`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination buffer before copying the data.\n\n```cpp\n#include <algorithm>\n\nstd::copy(std::begin(dce110_max_clks_by_state), std::end(dce110_max_clks_by_state), clk_mgr->max_clks_by_state);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::copy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d9fe3837-e1aa-432d-bf22-4f56af969e90",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `clk_mgr->max_clks_by_state` should be checked before calling `memcpy`. If `sizeof(dce120_max_clks_by_state)` is greater than the size of `clk_mgr->max_clks_by_state`, then `memcpy` should not be called.\n\n```cpp\nif(sizeof(clk_mgr->max_clks_by_state) >= sizeof(dce120_max_clks_by_state)) {\n    memcpy(clk_mgr->max_clks_by_state,\n        dce120_max_clks_by_state,\n        sizeof(dce120_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-376d03fa-a03a-4994-b4c0-91f51921f20a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct dc_clocks` is larger than the size of `new_clocks`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(new_clocks) >= sizeof(struct dc_clocks)) {\n    memcpy(&new_clocks, &clk_mgr_base->clks, sizeof(struct dc_clocks));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b2d175f7-e497-43aa-9cd8-4b08ef751687",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `clk_mgr->max_clks_by_state` should be checked before the `memcpy` function is called. If `sizeof(dce60_max_clks_by_state)` is greater than the size of `clk_mgr->max_clks_by_state`, then the `memcpy` function should not be called to prevent buffer overflow.\n\n```cpp\nif (sizeof(clk_mgr->max_clks_by_state) >= sizeof(dce60_max_clks_by_state)) {\n    memcpy(clk_mgr->max_clks_by_state,\n           dce60_max_clks_by_state,\n           sizeof(dce60_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fd3a3adf-b416-455f-9417-4bbce538fea5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the source buffer is larger than the destination buffer. In the provided code snippet, if `mcif_params->luma_pitch * dest_height` is larger than the size of `dest_luma_buffer`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source buffer is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = mcif_params->luma_pitch * dest_height;\nif (copy_size <= sizeof(dest_luma_buffer)) {\n    memcpy(dest_luma_buffer, luma_buffer, copy_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-68e09390-6bd6-4f91-885a-fa1e2228f380",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is less than the size of the source buffer, it can lead to a buffer overflow. This can overwrite adjacent memory, leading to unpredictable program behavior, crashes, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `chroma_buffer` to `dest_chroma_buffer`. The size of the data to be copied is calculated as `mcif_params->chroma_pitch * dest_height / 2`. If the size of `dest_chroma_buffer` is less than this value, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = mcif_params->chroma_pitch * dest_height / 2;\nif (sizeof(dest_chroma_buffer) >= copy_size) {\n    memcpy(dest_chroma_buffer, chroma_buffer, copy_size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied and store it in `copy_size`. We then check if the size of `dest_chroma_buffer` is greater than or equal to `copy_size`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-19471ac0-e6f0-4eb6-93c5-2ac99bf3e9a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code should be fixed to ensure that the size of the destination buffer is not less than the size of the source buffer. Here is a possible fix:\n\n```cpp\nsize_t size = sizeof(scl_data->dscl_prog_data.isharp_delta);\nif (size <= sizeof(dpp->scl_data.dscl_prog_data.isharp_delta)) {\n    memcpy(dpp->scl_data.dscl_prog_data.isharp_delta, scl_data->dscl_prog_data.isharp_delta, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-992e36ac-24c9-4c76-9ffb-4910048ed830",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying 32 bytes of data from `dsc_packed_pps[i * 32]` to `pps_sdp.sb`. If the size of `pps_sdp.sb` is less than 32 bytes, this could result in a buffer overflow, leading to potential code execution, denial of service, or information disclosure vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(pps_sdp.sb) >= 32) {\n    memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9b43e332-74e8-42a9-a33d-d92407309948",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. In the provided code, the `memcpy` function is copying `dsc_packed_pps` into `pps_sdp.sb[0]`. If `dsc_packed_pps` is larger than `pps_sdp.sb[0]`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. If the source is larger than the destination, you should not proceed with the copy.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(dsc_packed_pps) <= sizeof(pps_sdp.sb)) {\n    memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `dsc_packed_pps` is less than or equal to the size of `pps_sdp.sb`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe provided code requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-95560c8d-9c2d-414a-a741-ade4581ad936",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that `pipe_ctx->plane_state->visual_confirm_color` and `pipe_ctx->visual_confirm_color` are of type `struct tg_color`. If this is the case, the `sizeof(struct tg_color)` should be safe. However, it is always a good practice to add checks. Here is a safer version of the code:\n\n```cpp\nif (sizeof(pipe_ctx->plane_state->visual_confirm_color) >= sizeof(struct tg_color)) {\n    memcpy(&pipe_ctx->plane_state->visual_confirm_color, &(pipe_ctx->visual_confirm_color), sizeof(struct tg_color));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code should work as long as the C Standard Library is available. However, without the full context of the code, it's hard to say if there are other library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2c7b2b6f-28a0-4d0d-b343-7750e15d82fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-07f20a86-bbd8-4d93-b4e1-3fa939540dc7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the size of `struct v11_compute_mqd` from `m` to `mqd_dst`. If the size of `struct v11_compute_mqd` is larger than the size of `mqd_dst`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow attacks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(m) <= sizeof(mqd_dst)) {\n    memcpy(mqd_dst, m, sizeof(struct v11_compute_mqd));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `m` is less than or equal to the size of `mqd_dst`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you will need to include the `cstring` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4feac01f-7985-45ad-80c1-45a647937975",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter. This parameter is used to specify the maximum number of characters to be copied from the source string, which prevents buffer overflow by ensuring that the destination buffer is not overrun.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with a safer alternative such as `strncpy` or `memcpy`. Here is how you can do it:\n\n```cpp\nstrncpy(amd_mem_client.version, AMD_PEER_BRIDGE_DRIVER_VERSION, sizeof(amd_mem_client.version) - 1);\namd_mem_client.version[sizeof(amd_mem_client.version) - 1] = '\\0';\n```\n\nor\n\n```cpp\nmemcpy(amd_mem_client.version, AMD_PEER_BRIDGE_DRIVER_VERSION, sizeof(amd_mem_client.version) - 1);\namd_mem_client.version[sizeof(amd_mem_client.version) - 1] = '\\0';\n```\n\nBoth of these alternatives ensure that the destination buffer is not overrun by limiting the number of characters copied from the source string.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strcpy`, `strncpy`, and `memcpy` functions.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-cfe88839-c099-4c68-b1d4-87f87a2eaa51",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\" and it is a common security issue in C++ programming. In the provided code snippet, the `strcpy` function is used to copy the `AMD_PEER_BRIDGE_DRIVER_NAME` string into the `amd_mem_client.name` buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter. This parameter is used to specify the maximum number of characters to be copied from the source string, preventing buffer overflow.\n\nIn C++, the `strncpy` function can be used as a safer alternative to `strcpy`. However, it's important to note that `strncpy` does not null-terminate the destination string if the source string is longer than the specified length. Therefore, it's necessary to manually add a null character at the end of the destination string.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstrncpy(amd_mem_client.name, AMD_PEER_BRIDGE_DRIVER_NAME, sizeof(amd_mem_client.name) - 1);\namd_mem_client.name[sizeof(amd_mem_client.name) - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the provided links are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-038f5d79-5bb9-4f1b-b5fc-c738150479fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is determined by `sizeof(user_spm_data)`, which may be larger than the size of `user_spm_data`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(*user_spm_ptr) <= sizeof(user_spm_data)) {\n    memcpy(&user_spm_data, user_spm_ptr, sizeof(*user_spm_ptr));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of the data pointed to by `user_spm_ptr` is less than or equal to the size of `user_spm_data`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4cfdb243-82d5-4407-b0f0-8a220c334b68",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied exceeds the size of the destination buffer. In the provided code snippet, `memcpy(ring_start, ring_end, overflow_size)`, if `overflow_size` is greater than the size of `ring_start`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nsize_t ring_start_size = sizeof(ring_start) / sizeof(ring_start[0]);\n\nif (overflow_size <= ring_start_size) {\n    memcpy(ring_start, ring_end, overflow_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first calculate the size of `ring_start` and then check if `overflow_size` is less than or equal to `ring_start_size` before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-37faa9f4-fe88-416c-966b-c9c871a044bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct kfd_hsa_memory_exception_data` is larger than the size of `ev_priv->memory_exception_data`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(ev->memory_exception_data) <= sizeof(ev_priv->memory_exception_data)) {\n    memcpy(&ev_priv->memory_exception_data,\n           &ev->memory_exception_data,\n           sizeof(struct kfd_hsa_memory_exception_data));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef78a5fe-aac1-40fb-87b9-d9c4c35f0671",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct kfd_hsa_hw_exception_data` is larger than the size of `ev_priv->hw_exception_data`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle the error appropriately, such as by truncating the data or allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(ev_priv->hw_exception_data) >= sizeof(struct kfd_hsa_hw_exception_data)) {\n    memcpy(&ev_priv->hw_exception_data,\n           &ev->hw_exception_data,\n           sizeof(struct kfd_hsa_hw_exception_data));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-56505e62-08d6-4410-86a3-9eeb349db2c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash the program, or in worst cases, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `ev_priv->hw_exception_data` to `ev->hw_exception_data`. If the size of `ev_priv->hw_exception_data` is larger than `ev->hw_exception_data`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before the `memcpy` operation. \n\nAdditionally, consider using safer functions that include the size of the destination buffer as a parameter, such as `strncpy` or `memcpy_s`, to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&ev->hw_exception_data, sizeof(struct kfd_hsa_hw_exception_data), &ev_priv->hw_exception_data, sizeof(struct kfd_hsa_hw_exception_data));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b99f50bb-eb37-41d7-aecd-c0ad1ab3d653",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to write beyond it.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\nerrno_t err = memcpy_s(&ev->memory_exception_data, sizeof(struct kfd_hsa_memory_exception_data), &ev_priv->memory_exception_data, sizeof(struct kfd_hsa_memory_exception_data));\nif (err)\n{\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-95e36b6a-98ed-4784-b05c-58a67d341a53",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `dev->kfd->cwsr_isa` to `qpd->cwsr_kaddr`. If `dev->kfd->cwsr_isa_size` is larger than the size of `qpd->cwsr_kaddr`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif (sizeof(qpd->cwsr_kaddr) >= dev->kfd->cwsr_isa_size) {\n    memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9a8724c5-8ab9-4841-a713-e508ec42e2c8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `dev->kfd->cwsr_isa` to `qpd->cwsr_kaddr`. If `dev->kfd->cwsr_isa_size` is larger than the size of `qpd->cwsr_kaddr`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif (sizeof(qpd->cwsr_kaddr) >= dev->kfd->cwsr_isa_size) {\n    memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ec787e47-8b0c-4c8e-914b-7ec6db2cfd4e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability could occur if the size of `properties` is larger than the size of `tmp_q->properties`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(*properties) <= sizeof(tmp_q->properties)) {\n    memcpy(&tmp_q->properties, properties, sizeof(*properties));\n} else {\n    // Handle error: data is too large for the buffer\n}\n```\n\nIn this fix, we first check if the size of `properties` is less than or equal to the size of `tmp_q->properties`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f1b03318-f78c-482b-a905-31feb2b54ea2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `iolink1` to `props` without checking if the size of `iolink1` is larger than the size of `props`. This can lead to a buffer overflow, which can cause the program to crash or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the source and destination before calling `memcpy`. If the size of the source is larger than the destination, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(iolink1) <= sizeof(props)) {\n    memcpy(props, iolink1, sizeof(struct kfd_iolink_properties));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `iolink1` is less than or equal to the size of `props`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7faad49b-b2a5-4aed-9040-bfa2b6d3de51",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy(props2, props, sizeof(struct kfd_iolink_properties))`, if the size of `props2` is less than `sizeof(struct kfd_iolink_properties)`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `memmove`, which also copies data from one memory location to another, but it checks for buffer overflow and handles overlapping of source and destination memory blocks. However, it is still necessary to ensure that the destination buffer is large enough.\n\nHere is a fixed version of the code:\n\n```cpp\nif(sizeof(props2) >= sizeof(struct kfd_iolink_properties)) {\n    memmove(props2, props, sizeof(struct kfd_iolink_properties));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code requires the `cstring` library.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a963e442-f1de-47b2-9c2a-617ee7090f37",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(crat_table->signature) >= CRAT_SIGNATURE) {\n    memcpy(&crat_table->signature, CRAT_SIGNATURE, sizeof(crat_table->signature));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `crat_table->signature` is greater than or equal to `CRAT_SIGNATURE`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d8d33233-1199-4c05-995b-68b854facbd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\n#include <string.h> // for memcpy_s\n\n// Ensure gpu_link is not larger than props\nif (sizeof(struct kfd_iolink_properties) >= sizeof(gpu_link)) {\n    memcpy_s(props, sizeof(struct kfd_iolink_properties), gpu_link, sizeof(gpu_link));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<string.h>`: This library is required for the `memcpy_s` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b7668c83-c424-447c-8293-a995c52e6797",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy the string \"UNAVAIL\" into `crat_table->oem_table_id`. If the size of `crat_table->oem_table_id` is less than the size of the string \"UNAVAIL\", it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before using the `memcpy` function. Alternatively, you can use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `strncpy` function:\n\n```cpp\nstrncpy(crat_table->oem_table_id, \"UNAVAIL\", CRAT_OEMTABLEID_LENGTH);\ncrat_table->oem_table_id[CRAT_OEMTABLEID_LENGTH - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for `memcpy` or `strncpy` function\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7a42344f-6488-4929-8e52-07850af257a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy the string \"INV\" into `crat_table->oem_id`. If the size of `crat_table->oem_id` is less than `CRAT_OEMID_LENGTH`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nIn addition, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `strncpy`:\n\n```cpp\nstrncpy(crat_table->oem_id, \"INV\", CRAT_OEMID_LENGTH);\ncrat_table->oem_id[CRAT_OEMID_LENGTH - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-473b47a8-5569-4b50-961b-7d10b03b28b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to arbitrary code execution or denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `acpi_table->oem_id` to `crat_table->oem_id` with a length of `CRAT_OEMID_LENGTH`. If `CRAT_OEMID_LENGTH` is larger than the size of `crat_table->oem_id`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which takes the size of the destination buffer as an argument and ensures that no more than this size is written to the destination.\n\nHere is how you can modify the provided code snippet to use `strncpy`:\n\n```cpp\nstrncpy(crat_table->oem_id, acpi_table->oem_id, min(sizeof(crat_table->oem_id), CRAT_OEMID_LENGTH));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7baf6913-965c-4a13-98dd-37266c2c7be0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `strncpy` function:\n\n```cpp\nstrncpy(crat_table->oem_table_id, acpi_table->oem_table_id, min(sizeof(crat_table->oem_table_id), CRAT_OEMTABLEID_LENGTH));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for `memcpy` or `strncpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fe3d0295-e588-447f-9401-32c15b6a0d2a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(crat_table->signature) >= CRAT_SIGNATURE) {\n    memcpy(&crat_table->signature, CRAT_SIGNATURE, sizeof(crat_table->signature));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `crat_table->signature` is greater than or equal to `CRAT_SIGNATURE`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-61aefc79-5e72-4828-bd8d-6ce645fa0bb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Always ensure that the destination buffer is large enough to hold the data being copied. \n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `strncpy` or `memcpy_s` and ensure the destination buffer is large enough. Here is an example of how to use `strncpy`:\n\n```cpp\nstrncpy(top_dev->oem_table_id, crat_table->oem_table_id, min(sizeof(top_dev->oem_table_id), CRAT_OEMTABLEID_LENGTH));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f58082a3-5c3e-4f3c-b543-a6ce6e18ff70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `crat_table->oem_id` to `top_dev->oem_id`. If `CRAT_OEMID_LENGTH` is larger than the size of `top_dev->oem_id`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of characters to be copied. Here's how you can modify the code to use `strncpy`:\n\n```cpp\nstrncpy(top_dev->oem_id, crat_table->oem_id, min(sizeof(top_dev->oem_id), CRAT_OEMID_LENGTH));\n```\n\nThis code will copy at most `min(sizeof(top_dev->oem_id), CRAT_OEMID_LENGTH)` characters, preventing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\nFor `strncpy` and `sizeof`, you also need to include the `cstring` and `cstdlib` headers respectively:\n\n```cpp\n#include <cstring>\n#include <cstdlib>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cffd3aca-2a9a-40e8-ba18-127897cced2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\nAdditionally, it is a good practice to initialize buffers to a known state and to zero out the buffer after use. This can help prevent information leakage if the buffer is read after the data has been copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, you can use the `memcpy_s` function, which is available in C11:\n\n```cpp\nif (CRAT_SIBLINGMAP_SIZE <= sizeof(props->sibling_map)) {\n    memcpy_s(props->sibling_map, sizeof(props->sibling_map), cache->sibling_map, CRAT_SIBLINGMAP_SIZE);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9c92b6d3-4777-4094-ba49-7229ff6b1d06",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `kgd_mem->ipc_obj->share_handle` is larger than `bo_priv->ipc_share_handle`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(kgd_mem->ipc_obj->share_handle);\nif (size <= sizeof(bo_priv->ipc_share_handle)) {\n    memcpy(bo_priv->ipc_share_handle, kgd_mem->ipc_obj->share_handle, size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included at the top of your source file:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a8e0c8ec-f73f-4099-9088-46078d05b06c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vsnprintf`.\n\nThe `vsnprintf` function is a variant of `sprintf` that takes a maximum size parameter to prevent buffer overflows. However, it can still lead to vulnerabilities if not used correctly. For example, if the size argument is not correctly calculated, it can lead to buffer overflows. Also, like `sprintf`, `vsnprintf` can lead to format string vulnerabilities if the format string is not controlled or if user input is directly used as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `vsnprintf` and other similar functions if possible. Instead, use safer alternatives that are less prone to misuse, such as `snprintf`. Always control the format string and never use user input as the format string. Also, always correctly calculate the size argument to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `vsnprintf` with `snprintf` and ensure the size argument is correctly calculated. For example, if you have the following code:\n\n```cpp\nchar buffer[1024];\nvsnprintf(buffer, sizeof(buffer), format, args);\n```\n\nYou can replace it with:\n\n```cpp\nchar buffer[1024];\nsnprintf(buffer, sizeof(buffer), \"%s\", format);\n```\n\n## Library Dependencies\n\nThe `vsnprintf` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4f855db4-3e7d-4e34-a5eb-c23758f7cf85",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e796f59d-6f24-46c9-85a6-b6beb1685165",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the destination can hold, preventing buffer overflow.\n\n```cpp\n// Assuming mqd_dst is a pointer to struct v9_sdma_mqd\n// and m is a pointer to the source data\nsize_t size = sizeof(struct v9_sdma_mqd);\nif (mqd_dst && m && size <= sizeof(mqd_dst)) {\n    memcpy_s(mqd_dst, size, m, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` and `memcpy_s` functions are part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3dc6389c-82f7-4efe-9445-2d2c2501aa52",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(ctl_stack, ctl_stack_src, ctl_stack_size)\n```\n\nIf `ctl_stack_size` is larger than the size of `ctl_stack`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(ctl_stack) >= ctl_stack_size) {\n    memcpy(ctl_stack, ctl_stack_src, ctl_stack_size);\n} else {\n    // Handle error condition, e.g., by aborting the program or by allocating a larger buffer for ctl_stack\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-587b115f-1da9-4bc7-8605-8bbba918876b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6bac01ef-9156-4967-9564-66480ade6e9e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), whenever possible.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes a buffer size check. For example, you can use the `memcpy_s` function, which is available in C11:\n\n```cpp\nif(m->cp_hqd_cntl_stack_size <= sizeof(ctl_stack_dst)) {\n    memcpy_s(ctl_stack_dst, sizeof(ctl_stack_dst), ctl_stack, m->cp_hqd_cntl_stack_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed for this code to execute.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cd6ede36-f91c-40f9-81a3-b98024e187d9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `struct v9_mqd` is larger than the size of `mqd_dst`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by dynamically allocating memory for the destination buffer based on the size of the source data. Additionally, consider using safer alternatives to `memcpy` such as `memcpy_s` or `strncpy` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n// Assuming mqd_dst is a pointer to a struct v9_mqd\nstruct v9_mqd* mqd_dst = (struct v9_mqd*) malloc(sizeof(struct v9_mqd));\nif (mqd_dst == NULL) {\n    // Handle error\n}\nmemcpy(mqd_dst, m, sizeof(struct v9_mqd));\n```\n\nIn this fix, we dynamically allocate memory for `mqd_dst` based on the size of `struct v9_mqd` to ensure that it is large enough to hold the data being copied.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n- `stdlib.h`: This library is required for the `malloc` function.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e2f506e1-a5ee-42cc-b3e7-896d67cb4fa1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-924efad7-5bca-4545-b9b0-dd0837fca7d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer is larger than the destination buffer. In the provided code snippet, the `memcpy` function is copying the contents of `m` into `mqd_dst` without checking if `mqd_dst` has enough space to hold the contents of `m`. This can lead to a buffer overflow vulnerability if `m` is larger than `mqd_dst`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the contents of the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, you should either resize it or limit the amount of data copied to prevent a buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_dst) >= sizeof(struct cik_sdma_rlc_registers)) {\n    memcpy(mqd_dst, m, sizeof(struct cik_sdma_rlc_registers));\n} else {\n    // Handle error: mqd_dst is not large enough\n}\n```\n\nIn this fixed code, we first check if `mqd_dst` is large enough to hold the contents of `m`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-555dad8b-a4bf-45c4-a386-7b8109e94152",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dc92e64e-0ec2-4cd1-9aa0-4e5b9194f3e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nThis vulnerability is often referred to as a buffer overflow vulnerability. In the provided code snippet, the vulnerability exists if the size of `struct cik_mqd` is larger than the size of the buffer pointed to by `mqd_dst`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow. For example, the `strncpy` function in C++ includes a parameter for the maximum number of characters to be copied. If this limit is exceeded, `strncpy` will not copy any additional characters, preventing a buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `strncpy`. Here is an example of how you can do this:\n\n```cpp\nstrncpy(mqd_dst, m, sizeof(struct cik_mqd));\n```\n\nPlease note that `strncpy` does not null-terminate the destination string if the source string is longer than the specified length. You may need to manually add a null terminator if this is a requirement for your program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you will need to include the `cstring` header file in your program:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a9c313f1-3077-43fe-a4fa-635a85a28886",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `query_attr_size` is larger than the size of `svm_priv->attrs`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (query_attr_size <= sizeof(svm_priv->attrs)) {\n    memcpy(&svm_priv->attrs, query_attr, query_attr_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `query_attr_size` is less than or equal to the size of `svm_priv->attrs` before calling `memcpy`. If `query_attr_size` is larger, we handle the error appropriately instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-70a9f340-b904-41df-a3c1-b5660799280e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nmemcpy_s(set_attr, sizeof(set_attr), criu_svm_md->data.attrs, num_attrs * sizeof(struct kfd_ioctl_svm_attribute));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n- `kfd_ioctl_svm_attribute`: This is a custom structure and its definition should be included in the code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dba6477d-1c3d-40d0-ae2f-2e42bcf2c49d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to vulnerabilities if not used properly. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or can be exploited to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Also, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t num_elements, size_t size) {\n    if (dst_size < num_elements * size) {\n        // Handle the error, e.g., by throwing an exception or returning an error code\n    } else {\n        memcpy(dst, src, num_elements * size);\n    }\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4c997064-c791-4669-9832-622c39037c81",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(ipc_handle) >= sizeof(ipc_obj->share_handle)) {\n    memcpy(ipc_handle, ipc_obj->share_handle, sizeof(ipc_obj->share_handle));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-60568e52-3d4b-40c7-882d-166544446796",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. In the provided code snippet, the vulnerability arises if the size of `restore_handle` is larger than `obj->share_handle`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to determine the size of `restore_handle` and `obj->share_handle` and use the smaller size in the `memcpy` function. Here is an example:\n\n```cpp\nsize_t size = sizeof(obj->share_handle) < sizeof(restore_handle) ? sizeof(obj->share_handle) : sizeof(restore_handle);\nmemcpy(obj->share_handle, restore_handle, size);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-444f2c03-98d5-499e-bd4b-a58b7adc66db",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are considered unsafe or deprecated, are used in the code. These functions can lead to security issues such as buffer overflows, memory corruption, and undefined behavior. The `bsearch` function is one such function that can be problematic if not used carefully, as it involves direct memory manipulation and requires precise handling of pointers and data types.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using C++ standard library functions and algorithms that provide safer and more robust implementations.\n2. **Input Validation**: Ensure that all inputs are validated before being processed by the function.\n3. **Bounds Checking**: Implement bounds checking to prevent buffer overflows.\n4. **Code Review**: Regularly review code to identify and replace unsafe functions with safer alternatives.\n\n### Source Code Fix Recommendation\n\nInstead of using `bsearch`, consider using C++ standard library algorithms such as `std::binary_search` or `std::lower_bound` which are type-safe and provide better error handling.\n\n#### Example Code Fix\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n    int key = 3;\n\n    // Use std::binary_search for safer searching\n    if (std::binary_search(data.begin(), data.end(), key)) {\n        std::cout << \"Element found.\" << std::endl;\n    } else {\n        std::cout << \"Element not found.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard C++ library headers are required:\n\n- `<algorithm>`: Provides the `std::binary_search` function.\n- `<iostream>`: Used for input and output operations.\n- `<vector>`: Provides the `std::vector` container.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-717b33fc-09d1-4cfe-8ff3-96ea9fbbb166",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a336970d-2003-4709-85be-b05a91f81c8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the destination can hold, preventing buffer overflow.\n\n```cpp\n// Assuming mqd_dst is a pointer to struct v10_sdma_mqd\n// and m is a pointer to the source data\nsize_t size = sizeof(struct v10_sdma_mqd);\nif (mqd_dst && m && size <= sizeof(mqd_dst)) {\n    memcpy_s(mqd_dst, size, m, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` and `memcpy_s` functions are part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef07b3bc-9b53-485e-b3e3-22dc403f6714",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes size checks. For example:\n\n```cpp\n#include <string.h> // for strncpy\n#include <stdlib.h> // for malloc\n\nstruct v10_compute_mqd *mqd_dst = (struct v10_compute_mqd *)malloc(sizeof(struct v10_compute_mqd));\nif (mqd_dst != NULL) {\n    strncpy((char *)mqd_dst, (char *)m, sizeof(struct v10_compute_mqd));\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>`: This library is required for the `strncpy` function.\n- `<stdlib.h>`: This library is required for the `malloc` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-aeade182-e086-441b-85ab-217ecf8899b2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1f2bc7c3-59bd-4f9b-a439-5aabac259d12",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t size = dev->kfd->device_info.ih_ring_entry_size;\nif (size <= sizeof(patched_ihre)) {\n    memcpy(patched_ihre, ih_ring_entry, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3162d135-c134-40ec-959d-032d417c5b1e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-93766537-c90a-426f-9c93-e398d744762a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4a12a293-09fa-45a5-ba0a-0a28b9346101",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\".\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions prevent buffer overflow by not copying more characters than the destination buffer can hold.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"xgmi_wafl\", sizeof(ras->ras_block.ras_comm.name) - 1);\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` is used instead of `strcpy`. The third argument to `strncpy` is the size of the destination buffer minus one (to leave space for the null terminator). The next line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `strncpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-63c91ec6-ced4-471c-9de3-fa6f98b3af47",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-518f943d-39b5-41e7-8ee6-cfa2f3b8daa1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d24b3727-5db4-4d3e-8ea7-5940e0e1fd9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2059893d-7bec-4f76-b19f-f78c940b0cd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd))`, the vulnerability can occur if the size of `mqd_dst` is less than `sizeof(struct vi_sdma_mqd)`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `memmove`, which also copies data from a source to a destination, but it checks for overlapping memory areas. However, it does not solve the problem of buffer overflow. To prevent buffer overflow, you can use `strncpy` or `snprintf` which take the size of the destination buffer as an argument and ensure not to write beyond it.\n\n```cpp\nif(sizeof(mqd_dst) >= sizeof(struct vi_sdma_mqd)) {\n    memcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so it does not require any additional libraries to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d569a517-7603-4272-b521-c0a171146fd4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(m, mqd_src, sizeof(*m))`, if the size of `mqd_src` is larger than the size of `m`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before performing the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(mqd_src) <= sizeof(*m)) {\n    memcpy(m, mqd_src, sizeof(*m));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `mqd_src` is less than or equal to the size of `m`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be available at a later date. Always refer to the latest resources from OWASP and CWE for up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2ec3c8d7-1ea3-4fc5-986b-1f10de99d4f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (sizeof(mqd_dst) >= sizeof(struct vi_mqd)) {\n    memcpy(mqd_dst, m, sizeof(struct vi_mqd));\n} else {\n    // Handle the error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5d92a5de-ea1a-4461-b493-39163284e50b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```cpp\nmemcpy(buf_cpy, buf, count);\n```\n\nWith:\n\n```cpp\nif (count <= sizeof(buf_cpy)) {\n    memcpy(buf_cpy, buf, count);\n} else {\n    // Handle error\n}\n```\n\nOr use a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(buf_cpy, sizeof(buf_cpy), buf, count);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-707b5e0f-25b8-4d6e-b9de-da0d95684918",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nvoid vulnerable_function(char *param) {\n    size_t length = strlen(param);\n    // ...\n}\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nvoid safer_function(char *param, size_t max_length) {\n    size_t length = strnlen(param, max_length);\n    // ...\n}\n```\n\nIn the safer version, `strnlen()` will not read past `max_length` characters, preventing potential buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a7c07600-542f-4c6c-aa2b-5e7bf53eca8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nstrlen(sub_str);\n```\n\nUse:\n\n```c++\nstrnlen(sub_str, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `sub_str`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-9aeb62b6-7257-4160-b113-0f1a55f59121",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability in the given code:\n\n```cpp\nif (size <= sizeof(buf)) {\n    memcpy(buf, gpu_metrics, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data is less than or equal to the size of the destination buffer. If it is, we proceed with the copy operation. Otherwise, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `<cstring>` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5f88ae71-bb14-44ee-8291-422af3e18908",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to a buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues, such as arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source buffer and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (sizeof(tmp_buf) >= count) {\n    memcpy(tmp_buf, buf, count);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `tmp_buf` is greater than or equal to `count`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-222c0993-ff2f-42b9-be70-abda9d12c255",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `count-i` is larger than the size of `buf_cpy`, it can lead to a buffer overflow, which can cause a program crash or potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t buf_cpy_size = sizeof(buf_cpy);\nif (count - i <= buf_cpy_size) {\n    memcpy(buf_cpy, buf, count - i);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first get the size of `buf_cpy` using `sizeof`. Then, we check if `count - i` is less than or equal to `buf_cpy_size` before calling `memcpy`. If `count - i` is larger than `buf_cpy_size`, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-608e1af4-364f-455a-bb08-a106f66f2b70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nstrlen(sub_str);\n```\n\nUse:\n\n```c++\nstrnlen(sub_str, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `sub_str`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b632a3aa-507b-42bb-89cb-71bd56f2ea54",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nstrlen(sub_str);\n```\n\nUse:\n\n```c++\nstrnlen(sub_str, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `sub_str`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-17122d14-321b-451e-8a03-3f7882c08ca7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `bytes` is larger than the size of `buf_cpy`, it can lead to a buffer overflow, potentially allowing an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nsize_t buf_cpy_size = sizeof(buf_cpy);\nif (bytes <= buf_cpy_size) {\n    memcpy(buf_cpy, buf, bytes);\n} else {\n    // Handle error: buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a0bb27bc-5889-42d3-afd9-02ac41884518",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nstrlen(sub_str);\n```\n\nUse:\n\n```c++\nstrnlen(sub_str, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `sub_str`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a645787b-2435-475a-b37f-22f5d352b7b5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```cpp\nmemcpy(buf_cpy, buf, count);\n```\n\nWith:\n\n```cpp\nif (count <= sizeof(buf_cpy)) {\n    memcpy(buf_cpy, buf, count);\n} else {\n    // Handle error\n}\n```\n\nOr use a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(buf_cpy, sizeof(buf_cpy), buf, count);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-063f1d24-9b26-4807-99f4-7e22c989b80b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes a buffer size check. For example:\n\n```cpp\n#include <cstring> // for memcpy\n#include <algorithm> // for min\n\n// ...\n\nsize_t buf_size = sizeof(buf);\nsize_t table_size = sizeof(table);\nsize_t copy_size = std::min(buf_size, table_size);\n\nmemcpy(buf, table, copy_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This header file contains definitions for functions to manipulate C strings and arrays.\n- `<algorithm>`: This header file contains definitions for a collection of function objects, which includes `std::min`.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-68f729bd-c963-413b-bbf0-d2c9fa458515",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(buf)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the null-terminating character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar buf[100];\n// ... populate buf ...\nsize_t len = strlen(buf);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar buf[100];\n// ... populate buf ...\nsize_t max_len = sizeof(buf);\nsize_t len = strnlen(buf, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b0d696ca-836b-4501-ab8d-cae30debcba3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"perf_determinism\")`, there is no direct vulnerability as the string is a string literal which is automatically null-terminated by the compiler. However, if the string was user input or came from an untrusted source, it could potentially not be null-terminated and lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. If the string comes from an untrusted source, consider using safer alternatives such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is necessary as the string is a string literal and automatically null-terminated. However, if the string was not a literal, a fix might look like this:\n\n```cpp\nchar str[] = \"perf_determinism\";\nsize_t len = strnlen(str, sizeof(str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed to use it.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-57808391-a2e9-4c5f-bcf7-d9f7e9140fb1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential code execution.\n\nIn the provided code snippet, `strlen(\"profile_peak\")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was user input or read from an untrusted source, it could potentially be a source of vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated. Avoid using `strlen` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, there is no direct fix needed as the string is a constant and properly null-terminated. However, if the string was user input or read from an untrusted source, you could use `strnlen` as follows:\n\n```cpp\n#include <string.h>\n\nsize_t len = strnlen(user_input, MAX_LENGTH);\n```\n\nIn this example, `MAX_LENGTH` should be the maximum expected length of the string. This will prevent `strnlen` from reading beyond the intended memory if the string is not properly null-terminated.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-7f831fe6-7ded-44ce-a916-438d5363e8a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution.\n\nIn the provided code snippet, `strlen(\"profile_min_mclk\")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was replaced with a variable that may not be null-terminated, a vulnerability could occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated. Avoid using `strlen` with strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen` which takes a maximum length parameter to prevent reading beyond the end of the string.\n\n## Source Code Fix Recommendation\n\nIf the string was a variable, the code could be fixed as follows:\n\n```cpp\nconst char* str = \"profile_min_mclk\";\nsize_t len = strnlen(str, MAX_LENGTH);\n```\n\nIn this code, `MAX_LENGTH` should be the maximum expected length of the string. This prevents `strnlen` from reading beyond the end of the string.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library (`<cstring>` in C++), so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-ee9dcd36-a564-4eb0-b73a-fa9308a65918",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"profile_min_sclk\")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was user input or came from an untrusted source, it could potentially be a source of vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. Avoid using `strlen` on strings from untrusted sources. If you must use `strlen` on such strings, ensure that they are properly sanitized and null-terminated.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, there is no direct vulnerability. However, if the string was user input or came from an untrusted source, it could be sanitized and null-terminated as follows:\n\n```cpp\nchar user_input[256];\n// Get user input...\nuser_input[sizeof(user_input) - 1] = '\\0';\nsize_t length = strlen(user_input);\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-bed47c6e-d737-48a7-aedf-1ffd1ac528a0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\nIn the provided code snippet, `strlen(\"profile_standard\")`, there is no direct vulnerability as the string is a string literal which is automatically null-terminated by the compiler. However, if the string was user input or came from an untrusted source, it could potentially not be null-terminated and lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. If the string comes from an untrusted source, consider using safer alternatives such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is necessary as the string is a string literal and automatically null-terminated. However, if the string was not a string literal, you could use `strnlen` as follows:\n\n```cpp\n#include <string.h>\n\nconst char* str = /* string from untrusted source */;\nsize_t max_length = /* maximum expected length of str */;\nsize_t length = strnlen(str, max_length);\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-f4050e39-7669-4355-910f-2679d3ec90e2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential code execution.\n\nIn the provided code snippet, `strlen(\"profile_exit\")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was replaced with a variable that may not be null-terminated, a vulnerability could occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen` which takes a maximum length parameter to prevent reading beyond the end of a buffer.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is needed as the string is a constant and properly null-terminated. However, if the string was replaced with a variable, use `strnlen` instead of `strlen`.\n\n```cpp\nchar* str = /* some string */;\nsize_t len = strnlen(str, MAX_LEN);\n```\n\nReplace `MAX_LEN` with the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-e4e399d7-1ba5-47ad-b536-02b4e935b1a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source size is larger than the destination size. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)\n```\n\nThe `memcpy` function is copying `psp->sos.size_bytes` from the memory location `psp->sos.start_addr` to `psp->fw_pri_buf`. If `psp->sos.size_bytes` is larger than the size of `psp->fw_pri_buf`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the destination size before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(psp->sos.start_addr, psp->sos.start_addr + psp->sos.size_bytes, psp->fw_pri_buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4a4369c1-bdff-4aa6-931d-915a93a38122",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`, the `memcpy` function is copying `bin_desc->size_bytes` bytes from the memory location pointed to by `bin_desc->start_addr` to the memory location pointed to by `psp->fw_pri_buf`. If `bin_desc->size_bytes` is greater than the size of `psp->fw_pri_buf`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the data before the `memcpy` function is called.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (bin_desc->size_bytes <= sizeof(psp->fw_pri_buf)) {\n    memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes);\n} else {\n    // Handle the error condition, e.g., by logging an error message and exiting the function\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4506267d-cae4-4b85-b010-777c22aeb46f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&ucode_len, ptr, 4)`, the function is copying 4 bytes of data from the location pointed to by `ptr` to the location of `ucode_len`. If `ucode_len` is not large enough to hold 4 bytes of data, a buffer overflow can occur, potentially leading to arbitrary code execution, data corruption, and other security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` in C++. Additionally, you should always validate and sanitize input data to prevent buffer overflow attacks.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` would be to use `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This can help prevent buffer overflow attacks by ensuring that no more data is copied than the destination buffer can hold. Here's how you could modify the provided code snippet to use `memcpy_s` instead:\n\n```cpp\nsize_t ucode_len_size = sizeof(ucode_len);\nmemcpy_s(&ucode_len, ucode_len_size, ptr, 4);\n```\n\nIn this code, `ucode_len_size` is the size of the destination buffer. `memcpy_s` will not copy more data than this size, preventing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` and `memcpy_s` functions are part of the C Standard Library, so you'll need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eec6c410-de01-4986-9173-826bd64212ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. In the provided code snippet, `memcpy(&adev->uvd.keyselect, ptr, 4)`, the function is copying 4 bytes of data from the location pointed to by `ptr` to `adev->uvd.keyselect`. If the size of `adev->uvd.keyselect` is less than 4 bytes, it can lead to a buffer overflow condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(adev->uvd.keyselect) >= 4) {\n    memcpy(&adev->uvd.keyselect, ptr, 4);\n} else {\n    // Handle error condition\n}\n```\n\nIn this fixed code, we first check if the size of `adev->uvd.keyselect` is at least 4 bytes. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8b8ba2b3-d2e9-4a5d-a885-28718a56d5f1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3d5e06a9-a442-4f25-99e3-3741b6ac2f03",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the destination buffer is smaller than the source buffer. In the provided code snippet, if `obj->buffer.length` is greater than the size of `bios+offset`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <cstring> // for memcpy\n#include <algorithm> // for min\n\n// ...\n\nsize_t bios_size = sizeof(bios) - offset;\nsize_t copy_size = std::min(bios_size, obj->buffer.length);\n\nmemcpy(bios+offset, obj->buffer.pointer, copy_size);\n```\n\nIn this fix, we first calculate the size of the destination buffer (`bios_size`). Then we determine the minimum of `bios_size` and `obj->buffer.length` to ensure we do not copy more data than the destination buffer can hold.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fd1cdb61-dd6e-42ae-9fdf-71f6bb545dc3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(AMD_VBIOS_SIGNATURE)` is a potential vulnerability if `AMD_VBIOS_SIGNATURE` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings passed to `strlen()` are null-terminated. This can be done by initializing strings with a null character at the end or by manually adding a null character at the end of the string before passing it to `strlen()`.\n\n## Source Code Fix Recommendation\n\nIf `AMD_VBIOS_SIGNATURE` is a character array, ensure it is null-terminated:\n\n```cpp\nchar AMD_VBIOS_SIGNATURE[] = \"Signature\\0\";\nsize_t length = strlen(AMD_VBIOS_SIGNATURE);\n```\n\nIf `AMD_VBIOS_SIGNATURE` is a pointer to a character string, ensure the string it points to is null-terminated:\n\n```cpp\nchar* AMD_VBIOS_SIGNATURE = new char[10];\nstrcpy(AMD_VBIOS_SIGNATURE, \"Signature\");\nAMD_VBIOS_SIGNATURE[9] = '\\0';\nsize_t length = strlen(AMD_VBIOS_SIGNATURE);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so the code requires the `<cstring>` (or `<string.h>` in C) library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-50047a21-9159-4d64-97e7-ad1df1b98702",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source size is larger than the destination size. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)\n```\n\nThe `memcpy` function is copying `psp->sos.size_bytes` from the memory location `psp->sos.start_addr` to `psp->fw_pri_buf`. If `psp->sos.size_bytes` is larger than the size of `psp->fw_pri_buf`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the destination size before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(psp->sos.start_addr, psp->sos.start_addr + psp->sos.size_bytes, psp->fw_pri_buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9291667a-6079-41ef-beff-c0ffcb219ea4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`, the `memcpy` function is copying `bin_desc->size_bytes` bytes from the memory location pointed to by `bin_desc->start_addr` to the memory location pointed to by `psp->fw_pri_buf`. If `bin_desc->size_bytes` is greater than the size of `psp->fw_pri_buf`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the data before the `memcpy` function is called.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (bin_desc->size_bytes <= sizeof(psp->fw_pri_buf)) {\n    memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes);\n} else {\n    // Handle the error condition, e.g., by logging an error message and exiting the function\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3c7109f2-f6fa-4188-90b7-891a87a75f97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9ed45fc1-aa79-42ec-a5f5-b23a97508fad",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-18d2fd25-066d-4c5e-94f3-b82b42538547",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-224c0eee-6f75-4f29-a28c-6f84e942b6be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the contents of `end` into `init_table`. If the size of `end` is larger than `init_table`, it can lead to a buffer overflow, which can cause the program to crash or lead to execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstruct mmsch_v1_0_cmd_end end;\nvoid *init_table = malloc(sizeof(struct mmsch_v1_0_cmd_end));\nif (init_table != NULL) {\n    memcpy(init_table, &end, sizeof(struct mmsch_v1_0_cmd_end));\n} else {\n    // Handle malloc failure\n}\n```\n\nIn this fix, we first allocate memory for `init_table` using `malloc`, ensuring it is large enough to hold the data from `end`. We then check if `malloc` was successful before proceeding with the `memcpy` operation.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `#include <stdlib.h>` for `malloc`\n- `#include <string.h>` for `memcpy`\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d44feef2-1caa-42fd-9c2a-68b99edf91a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-836a33c2-8da7-4acc-8c0f-363e4b2e2baf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5078ec85-3552-4875-86dd-b803a0aeb0ed",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. In the provided code snippet, the `memcpy` function is copying the contents of `info` into `bank_error->info`. If the size of `info` is larger than `bank_error->info`, it can lead to buffer overflow, which is a serious security vulnerability that can lead to arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(bank_error->info) >= sizeof(*info)) {\n    memcpy(&bank_error->info, info, sizeof(*info));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `bank_error->info` is larger or equal to the size of `info`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d0bcb039-3d94-483e-8592-a9458cb0c240",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `strncpy` or `memcpy_s`. Here is an example of how to do it with `memcpy_s`:\n\n```cpp\nif (sizeof(node->bank) >= sizeof(*bank)) {\n    memcpy_s(&node->bank, sizeof(node->bank), bank, sizeof(*bank));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ab481ce3-eb1d-4af2-b4e5-87caa861a371",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fd6fd510-4300-44c5-9ddb-b3ac519a0b53",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"vcn\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"vcn\" (including the null terminator), this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"vcn\", sizeof(ras->ras_block.ras_comm.name));\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-b4a2bdda-b50b-4f67-9415-1ea4699dd0de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d29c86b0-2c42-4c16-939b-e1cdb9fef98c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, and `memcpy_s` (in C11) are safer alternatives as they take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative. For example, you can use the `memcpy_s` function which is available in C11:\n\n```cpp\nmemcpy_s(&amdgpu_crtc->native_mode, sizeof(struct drm_display_mode), &amdgpu_encoder->native_mode, sizeof(struct drm_display_mode));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h` for the `memcpy` function\n- `drm/drmP.h` for the `struct drm_display_mode` type\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9995ea7e-685f-44d0-9b2f-c464b6305049",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example, you can use the `memcpy_s` function, which is a safer version of `memcpy`:\n\n```cpp\nif (size <= sizeof(table_loc)) {\n    memcpy_s((void *)table_loc, sizeof(table_loc), &header, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-872287d3-28f1-4c99-ad50-073d8b299d48",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1c721a3a-58c9-48a5-be98-add7172406bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fbbd5d40-f8e3-442c-9160-facf4174c7f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example, you can use the `memcpy_s` function, which is a safer version of `memcpy`:\n\n```cpp\nif (size <= sizeof(table_loc)) {\n    memcpy_s((void *)table_loc, sizeof(table_loc), &header, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7e1ade39-04d4-483d-99b5-716ed4c43830",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fdf90da2-a432-4ba6-8017-3fc7a7025a69",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t copy_size = ring->buf_mask + 1 - offset;\nif (copy_size <= sizeof(ring->ring[offset])) {\n    memcpy((void *)&ring->ring[offset], de_payload_cpu_addr, copy_size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fix, we first calculate the size of the data to be copied and then check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-73762bbe-1095-433f-b0cc-a0a0cfbe50c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the source buffer, it can lead to a buffer overflow. This can overwrite adjacent memory, leading to unpredictable program behavior, crashes, incorrect results, or a security vulnerability.\n\nIn the provided code, the `memcpy` function is used without checking if the destination buffer (`ring->ring[0]`) is large enough to hold the data being copied from the source buffer (`de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2)`). This can potentially lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t dest_size = sizeof(ring->ring);\nsize_t src_size = payload_size;\n\nif (src_size <= dest_size) {\n    memcpy((void *)&ring->ring[0],\n           de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n           payload_size);\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe provided code requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b0027fa5-2d47-4f49-9bb5-55aeeec8d83b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (payload_size <= sizeof(ring->ring[offset])) {\n    memcpy((void *)&ring->ring[offset], de_payload_cpu_addr, payload_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the payload is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fbb0a9fd-b99f-4d9d-a763-3c0eae011801",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is not checked before calling `memcpy`. This can be fixed by adding a check before the `memcpy` call:\n\n```cpp\nsize_t dest_size = sizeof(ring->ring);\nsize_t src_size = ((ring->buf_mask + 1 - offset) << 2);\n\nif (src_size <= dest_size) {\n    memcpy((void *)&ring->ring[0],\n           ce_payload_cpu_addr + src_size,\n           payload_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3f990649-73d2-41c5-8adb-6ffd0ed84d4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability:\n\n```cpp\nsize_t copy_size = ring->buf_mask + 1 - offset;\nif (copy_size <= sizeof(ring->ring[offset])) {\n    memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, copy_size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fix, we first calculate the size of the data to be copied and then check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-db70cfb4-a342-4fd9-b895-78bd2595182b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (payload_size <= sizeof(ring->ring[offset])) {\n    memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, payload_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`payload_size`) is less than or equal to the size of the destination buffer (`sizeof(ring->ring[offset])`). If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3eb3ab21-3b69-4127-bc2e-7d85e63ab3ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination buffer as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `mqd` is not checked before the `memcpy` function is called. To fix this, you could add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(mqd) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` header file.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-425824bc-fed6-4055-b12b-692d3c06c023",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `mqd` to `adev->gfx.mec.mqd_backup[mqd_idx]`. If the size of `mqd` is larger than the size of `adev->gfx.mec.mqd_backup[mqd_idx]`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(adev->gfx.mec.mqd_backup[mqd_idx]) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is larger than or equal to the size of the source data. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` library would need to be included for this function to work.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-af4e3255-21af-4579-91ef-faa1190d7391",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `adev->gfx.kiq[0].mqd_backup` to `mqd`. If the size of `adev->gfx.kiq[0].mqd_backup` is larger than `mqd`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` and add a check to ensure the destination buffer is large enough:\n\n```cpp\nif(sizeof(mqd) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy_s(mqd, sizeof(mqd), adev->gfx.kiq[0].mqd_backup, sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cstddef>`: This library provides the `sizeof` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2ff34503-55c3-40f8-b51e-d730b9b7f848",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct v9_mqd_allocation` is larger than the size of `adev->gfx.kiq[0].mqd_backup`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(adev->gfx.kiq[0].mqd_backup) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is larger than or equal to the size of the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C standard library, so the code would need to include `<cstring>` or `<string.h>` to use this function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cf0e6f5c-2195-4fa8-9325-ac2b1c0a2bef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dea744cd-1fe7-445b-83f8-4908ccf8b934",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e6f87b02-08e1-4092-906a-1f78084d18aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3d0a0b9b-9e5b-46ba-afd8-070bced93911",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-682dc8b4-f559-4ff6-8e74-16f500620300",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (fw_size <= sizeof(fw)) {\n    memcpy(fw, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(fw)`). If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5ecf6ac2-0c98-4f81-985d-d6ce1fa75a9b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nIn the provided code snippet, `strcpy(ras->ras_block.ras_comm.name, \"hdp\")`, the `strcpy` function is used to copy the string \"hdp\" into the `name` field of the `ras_comm` structure within the `ras_block` structure of the `ras` object. If the `name` field is not large enough to hold the string \"hdp\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the array bounds of the destination buffer. In C++, this can be achieved using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function as follows:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"hdp\", sizeof(ras->ras_block.ras_comm.name) - 1);\n```\n\nThis will copy at most `sizeof(ras->ras_block.ras_comm.name) - 1` characters from the string \"hdp\" to the `name` field, preventing a buffer overflow. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe `strcpy` and `strncpy` functions are part of the C standard library, so the following include directive is required:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-c7129204-ae26-4fc7-be14-e161d6ca39cc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to serious vulnerabilities if not used properly. The most common vulnerability associated with `memcpy` is buffer overflow. This happens when the size of the data being copied exceeds the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior, including memory corruption, crashes, and other security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Also, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix the vulnerability in the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void *dst, size_t dst_size, const void *src, size_t num_bytes) {\n    if (dst_size < num_bytes) {\n        // Handle the error, e.g. by throwing an exception or returning an error code\n        throw std::length_error(\"Destination buffer is too small\");\n    }\n    memcpy(dst, src, num_bytes);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-783634d8-6593-41e6-b7d7-e46d417d6b27",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(dst, dst_tmp, num_bytes)`, if `num_bytes` is larger than the size of `dst`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(dst) >= num_bytes) {\n    memcpy(dst, dst_tmp, num_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `dst` is larger or equal to `num_bytes`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-786: Access of Memory Location Before Start of Buffer](https://cwe.mitre.org/data/definitions/786.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8a862abe-de31-430a-af7d-5238b6613532",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash of the application, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (align_num_bytes <= sizeof(src_tmp)) {\n    memcpy(src_tmp, src, align_num_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data being copied (`align_num_bytes`) is less than or equal to the size of the destination buffer (`sizeof(src_tmp)`). If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a48f9404-c21a-4165-9a51-1fb81d1d0bf4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is greater than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet `memcpy(dst, dst_tmp, align_num_bytes)`, the vulnerability arises if `align_num_bytes` is greater than the size of `dst`. This would result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t dst_size = sizeof(dst);\nif (align_num_bytes <= dst_size) {\n    memcpy(dst, dst_tmp, align_num_bytes);\n} else {\n    // Handle error: source data is too large for destination buffer\n}\n```\n\nIn this fix, we first get the size of the destination buffer `dst`. Then we check if `align_num_bytes` is less than or equal to `dst_size` before performing the `memcpy` operation. If `align_num_bytes` is greater than `dst_size`, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow Attacks](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cca39259-af22-4a46-beda-0e640712105e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-06f6a495-37d1-4929-b157-b975af5dc305",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`num_bytes`) is larger than the size of the destination buffer (`src_tmp`). This can lead to unexpected behavior, including program crashes, data corruption, and execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is larger than the size of the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (sizeof(src_tmp) >= num_bytes) {\n    memcpy(src_tmp, src, num_bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer (`src_tmp`) is larger than or equal to the size of the data being copied (`num_bytes`). If it is, we proceed with the copy operation. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you will need to include the `<cstring>` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e874fd20-6b97-4cf5-849c-b81874c78247",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-48121354-a10f-48f7-8642-0b52c5dac1d6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9de5f3c0-66bd-4f3c-bcc9-5cefec3dbf44",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3db66a30-b005-49d8-8df9-49d0947de208",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `adev->gfx.mec.mqd_backup[mqd_idx]` is at least `sizeof(struct vi_mqd_allocation)`. To fix the potential vulnerability, you should add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(adev->gfx.mec.mqd_backup[mqd_idx]) >= sizeof(struct vi_mqd_allocation)) {\n    memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct vi_mqd_allocation));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, `memcpy` is part of the C standard library, so the code will at least need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-07db58f0-ec4c-4a6d-8714-809e6e6a4779",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination buffer as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `mqd` should be checked before calling `memcpy`. If the size of `mqd` is less than `sizeof(struct vi_mqd_allocation)`, then `memcpy` should not be called. Here is a possible fix:\n\n```cpp\nif (sizeof(mqd) >= sizeof(struct vi_mqd_allocation)) {\n    memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct vi_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the following libraries:\n\n- `string.h` for the `memcpy` function\n- Any libraries that define the `vi_mqd_allocation` struct and the `adev` object\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ac5463ff-be7c-4398-8423-e7705c323398",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nmemcpy_s(adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation), mqd, sizeof(struct vi_mqd_allocation));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9c722134-26d0-4d64-afa6-20174a76d480",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `mqd` should be checked before calling `memcpy`. If the size of `mqd` is less than the size of `adev->gfx.kiq[0].mqd_backup`, then the `memcpy` call should be avoided.\n\n```cpp\nif (sizeof(mqd) >= sizeof(struct vi_mqd_allocation)) {\n    memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-28bbafce-9303-450e-9e05-55732de53a5b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fa692c6f-7969-415c-958f-771601b2ccfc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5d8be667-abbb-4eb6-a113-63e6f001be3c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9e5a7b11-604b-4b61-a1e6-0aa10b3b454e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f1b4273c-a196-4d1e-9cb2-0177664dabf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-422fe5fb-3f68-450b-86fd-2edf0597d5c9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6b76f485-cdfb-4d87-8d4d-cc9529b44bf9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7adbf04b-27f3-4219-bfa1-e3d42d9b0146",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d717199a-eaa1-4357-bd7a-8e217b4220a6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nIn the provided code snippet, `strcpy(ras->ras_block.ras_comm.name, \"gfx\")`, the string \"gfx\" is being copied into `ras->ras_block.ras_comm.name` without checking if the destination buffer can hold the source string. If the destination buffer is smaller than the source string, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the array bounds of the destination buffer. Functions like `strncpy`, `strlcpy`, or `memcpy` can be used instead of `strcpy`. These functions take an additional parameter that specifies the maximum number of characters to be copied from the source string, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"gfx\", sizeof(ras->ras_block.ras_comm.name) - 1);\n```\n\nThis will copy at most `sizeof(ras->ras_block.ras_comm.name) - 1` characters from the source string to the destination buffer, ensuring that the destination buffer is not overflowed.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-763fc843-2145-4740-b51d-62950f9def96",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b8128699-e937-4695-ad31-6ecf2d19bc5c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is determined by the `le32_to_cpu(header->jt_size)` function. If this function returns a value larger than the size of `dst_addr`, a buffer overflow will occur.\n\nBuffer overflow vulnerabilities can lead to a variety of security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in bounds checking.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nsize_t size = le32_to_cpu(header->jt_size);\nif (size <= sizeof(dst_addr)) {\n    memcpy(dst_addr, src_addr, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied. Then, we check if this size is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<string.h>` for the `memcpy` function.\n- `<linux/byteorder/little_endian.h>` for the `le32_to_cpu` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-86852f20-67f8-449c-8f70-f116c5cb02d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vsnprintf`.\n\nThe `vsnprintf` function is a variant of `sprintf` that takes a maximum size parameter to prevent buffer overflows. However, it can still lead to vulnerabilities if not used correctly. For example, if the size argument is not correctly calculated, it can lead to buffer overflows. Also, like `sprintf`, `vsnprintf` can lead to format string vulnerabilities if the format string is not controlled or if user input is directly used as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `vsnprintf` and other similar functions if possible. Instead, use safer alternatives that are less prone to misuse, such as `snprintf`. Always control the format string and never use user input as the format string. Also, always correctly calculate the size argument to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `vsnprintf` with `snprintf` and ensure the size argument is correctly calculated. For example, if you have the following code:\n\n```cpp\nchar buffer[1024];\nvsnprintf(buffer, sizeof(buffer), format, args);\n```\n\nYou can replace it with:\n\n```cpp\nchar buffer[1024];\nsnprintf(buffer, sizeof(buffer), \"%s\", format);\n```\n\n## Library Dependencies\n\nThe `vsnprintf` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b8f2285a-6879-4151-955f-296f0a53459b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(ucode->kaddr, ucode_addr, ucode->ucode_size)\n```\n\nThe `memcpy` function is copying `ucode->ucode_size` bytes from the memory location pointed to by `ucode_addr` to the memory location pointed to by `ucode->kaddr`. If `ucode->ucode_size` is larger than the size of the memory allocated for `ucode->kaddr`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the source data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif (sizeof(ucode->kaddr) >= ucode->ucode_size) {\n    memcpy(ucode->kaddr, ucode_addr, ucode->ucode_size);\n} else {\n    // Handle the error condition, e.g., by logging an error message and exiting the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3404cc1b-aa22-4815-a1de-aca7770940ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(ATOM_ROM_MAGIC)` is potentially vulnerable if `ATOM_ROM_MAGIC` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings passed to `strlen()` are null-terminated. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before passing it to `strlen()`.\n\n## Source Code Fix Recommendation\n\nIf `ATOM_ROM_MAGIC` is a string literal, it is automatically null-terminated and there is no vulnerability. If it is a character array or a pointer to a character, ensure it is null-terminated before passing it to `strlen()`.\n\n```cpp\nchar ATOM_ROM_MAGIC[] = \"your_string_here\";\nATOM_ROM_MAGIC[sizeof(ATOM_ROM_MAGIC) - 1] = '\\0';\nstrlen(ATOM_ROM_MAGIC);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so the code requires the `<cstring>` or `<string.h>` header file.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2b29ed70-6743-4cfe-bd86-c9ace78beb41",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(ATOM_ATI_MAGIC)`, the vulnerability arises if `ATOM_ATI_MAGIC` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum length of the string to be considered.\n\n## Source Code Fix Recommendation\n\nAssuming `ATOM_ATI_MAGIC` is a char array, you can ensure it is null-terminated by initializing it like this:\n\n```cpp\nchar ATOM_ATI_MAGIC[] = \"your_string_here\";\n```\n\nOr, if the string is dynamically allocated, ensure a null character is added at the end:\n\n```cpp\nchar* ATOM_ATI_MAGIC = new char[length + 1];\nstrcpy(ATOM_ATI_MAGIC, \"your_string_here\");\nATOM_ATI_MAGIC[length] = '\\0';\n```\n\nIf you want to use `strnlen()`, you can do it like this:\n\n```cpp\nsize_t length = strnlen(ATOM_ATI_MAGIC, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum length you expect the string to be.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so you need to include `cstring` or `string.h`:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-0c4d446c-c9df-4314-bcd7-0e33d38cba5d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. In the provided code snippet, `memcpy(ctx->name, na, 7)`, the function is copying 7 bytes from the source `na` to the destination `ctx->name`. If `ctx->name` is not large enough to hold 7 bytes, this can result in a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11 or later).\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `strncpy`:\n\n```cpp\nstrncpy(ctx->name, na, sizeof(ctx->name) - 1);\nctx->name[sizeof(ctx->name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4e0ccfbd-6e1f-47cc-ba2a-6727dc155281",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the data being copied is larger than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. \n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (name_size <= sizeof(ctx->name)) {\n    memcpy(ctx->name, c_ptr, name_size);\n} else {\n    // Handle error: name_size is too large for ctx->name\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-58b30df9-a5fe-42fc-b751-3ce959155bb1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(ctx->vbios_ver_str, vbios_ver, STRLEN_NORMAL)`, the `memcpy` function is copying `STRLEN_NORMAL` bytes from `vbios_ver` to `ctx->vbios_ver_str`. If `STRLEN_NORMAL` is larger than the size of `ctx->vbios_ver_str`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of characters to be copied. Here's how you can modify the code:\n\n```cpp\nstrncpy(ctx->vbios_ver_str, vbios_ver, min(STRLEN_NORMAL, sizeof(ctx->vbios_ver_str)));\n```\n\nThis code will only copy the smaller of `STRLEN_NORMAL` and `sizeof(ctx->vbios_ver_str)` characters, preventing a buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f42f2942-9d28-4455-a6ba-6f0e377d81cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-087f2e25-0069-40a5-9d65-fc000b0962ee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the contents of `end` into `init_table`. If the size of `end` is larger than `init_table`, it can lead to a buffer overflow, which can cause the program to crash or lead to execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstruct mmsch_v1_0_cmd_end end;\nvoid *init_table = malloc(sizeof(struct mmsch_v1_0_cmd_end));\nif (init_table != NULL) {\n    memcpy(init_table, &end, sizeof(struct mmsch_v1_0_cmd_end));\n} else {\n    // Handle malloc failure\n}\n```\n\nIn this fix, we first allocate memory for `init_table` using `malloc`, ensuring it is large enough to hold the data from `end`. We then check if `malloc` was successful before proceeding with the `memcpy` operation.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `#include <stdlib.h>` for `malloc`\n- `#include <string.h>` for `memcpy`\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2925dcd0-5bc6-4f13-898d-943de951331f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e2e69746-1ad0-486d-b8b0-0da186b2144e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ca1e4fa3-4458-493e-b4eb-2f4d3d57437e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/vega20_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/vega20_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/vega20_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` copies at most `sizeof(fw_name) - 1` characters from the source string to the destination buffer, and then manually null-terminates the string.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-3365a650-ff97-4124-b29e-618189400dd7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/vega10_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/vega10_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/vega10_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate the string to ensure it is properly formed.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-58de5929-4339-48ce-a48a-8aa1fd7475bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/vega12_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/vega12_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/vega12_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library to execute properly:\n\n- `cstring` or `string.h` for the `strcpy` function\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-2f4743b1-3374-440f-abf9-752e6eecda05",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include array bounds checking, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require the size of the destination buffer as an argument, which can prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nchar fw_name[30];\nstrncpy(fw_name, \"amdgpu/vega10_acg_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the C++ Standard Library (`<cstring>`).\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-1b950c9f-2f9b-43ac-8c68-99924c4e435d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/vegam_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/vegam_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/vegam_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-f89ce54f-2ac6-467a-a498-d9f5444a774c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/polaris12_smc.bin\")`, the string \"amdgpu/polaris12_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold this string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris12_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(fw_name) - 1` is the maximum number of characters that will be copied from the source string. The `- 1` is to leave space for the null terminator. The next line explicitly adds the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-0dcd3876-bd3d-456f-9bb5-2bd1f901acd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\")`, the string \"amdgpu/polaris12_k_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris12_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for the `strcpy` function\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-ed0ccfc2-223b-4501-9954-672a983a674a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/polaris10_smc_sk.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold this string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-3c9e1524-7c9b-4814-a9ea-23d93cb9521b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/polaris10_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/polaris10_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris10_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` copies at most `sizeof(fw_name) - 1` characters from the source string to the `fw_name` buffer. The `- 1` ensures there is space for the null terminator. The next line explicitly sets the last character of `fw_name` to the null terminator, ensuring the string is properly terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` and `strncpy` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-97596c10-e2c5-406b-bdf3-1790eef8fb6c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nchar fw_name[30];\nstrncpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nIn this code, `strncpy` copies at most `sizeof(fw_name)` characters. If the source string is longer than this, it will be truncated. The last line ensures that the string is null-terminated, which `strncpy` does not do if the source string is longer than the specified size.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-c500f806-b733-4cd4-bed2-6a77e03b7dd5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nchar fw_name[30];\nstrncpy(fw_name, \"amdgpu/polaris10_k_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nIn this code, `strncpy` copies at most `sizeof(fw_name)` characters. If the source string is longer, it will be truncated. The last line ensures that the string is null-terminated, which `strncpy` does not do if the source string is longer than the specified size.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-ae38a248-72e5-476c-9f78-8a46a2e9d247",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nchar fw_name[30];\nstrncpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nIn this example, `strncpy` will copy at most `sizeof(fw_name)` characters from the source string to `fw_name`. If the source string is longer than this, only the first `sizeof(fw_name)` characters will be copied. The last line ensures that the string is null-terminated, which `strncpy` does not do if the source string is longer than the specified size.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-35f0559b-2140-496e-a33d-215532dd4fb2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/polaris11_smc.bin\")`, the string \"amdgpu/polaris11_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris11_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-f120b317-2634-4123-b8ce-ce6015b70b15",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including denial of service, code execution, and privilege escalation. Therefore, the use of `strcpy` is generally discouraged in secure programming.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that include buffer size as a parameter. This ensures that the function does not write past the end of the buffer.\n\nIn C++, the `strncpy` function can be used as a safer alternative to `strcpy`. It takes an additional parameter that specifies the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar fw_name[30];\nstrncpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null-termination\n```\n\nIn this code, `strncpy` is used instead of `strcpy`, and the size of `fw_name` is passed as the third argument to `strncpy`. This ensures that `strncpy` does not write past the end of `fw_name`. The last line ensures that `fw_name` is null-terminated, as `strncpy` does not null-terminate the destination string if the source string is longer than the specified length.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strncpy` function.\n\n## References\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-08a5f3e8-dc11-48a6-8491-7ce71c5a3167",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus reducing the risk of buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstruct mmsch_v1_0_cmd_direct_polling init_table;\nif (sizeof(init_table) >= sizeof(direct_poll)) {\n    memcpy((void *)&init_table, direct_poll, sizeof(direct_poll));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `init_table` is greater than or equal to the size of `direct_poll`. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c6efd82c-9f5f-441e-8403-0642265f09c5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstruct mmsch_v1_0_cmd_direct_read_modify_write init_table;\nstruct mmsch_v1_0_cmd_direct_read_modify_write direct_rd_mod_wt;\n\n// Ensure that the size of the destination buffer is not less than the size of the source buffer\nif(sizeof(init_table) >= sizeof(direct_rd_mod_wt)) {\n    memcpy((void *)&init_table, &direct_rd_mod_wt, sizeof(struct mmsch_v1_0_cmd_direct_read_modify_write));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0ccb5ab6-df9e-446a-bd79-91e61794095a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause memory corruption, leading to unpredictable program behavior, crashes, or even code execution. This is known as the \"Detected Use of Prohibited C Function (strcpy)\" vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter. This allows the function to know the size of the destination buffer and prevent buffer overflow. Functions like `strncpy`, `strlcpy` or `memcpy` can be used instead. However, these functions have their own issues and should be used carefully.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with a safer function like `strncpy`. Here is how you can do it:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/polaris11_k_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-465fd00c-0a45-4182-8fe5-20b852740543",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```cpp\nstruct mmsch_v1_0_cmd_direct_write *init_table = new mmsch_v1_0_cmd_direct_write;\nif (sizeof(*init_table) >= sizeof(struct mmsch_v1_0_cmd_direct_write)) {\n    memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v1_0_cmd_direct_write));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer (`init_table`) is large enough to hold the data from the source buffer (`direct_wt`). If it is, we proceed with the `memcpy`. If it isn't, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef6c24b1-5511-4d1d-a03a-55bae1c1dd5a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/fiji_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/fiji_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/fiji_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this fix, `strncpy` is used instead of `strcpy`. The `sizeof(fw_name) - 1` argument ensures that no more characters than the size of the `fw_name` buffer are copied, and the `fw_name[sizeof(fw_name) - 1] = '\\0'` line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-3072ac3e-bec4-4557-8b52-655ec22e8aae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/tonga_smc.bin\")`, the string \"amdgpu/tonga_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere's how you can fix the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/tonga_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(fw_name) - 1` ensures that the last character in the buffer is reserved for the null terminator, ensuring that `fw_name` is a valid string.\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so no additional libraries are needed for the original code. The `strncpy` function is also part of the C standard library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-a0b002a1-b951-49f4-ac3a-2b7acb44d268",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/tonga_k_smc.bin\")`, the string \"amdgpu/tonga_k_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy` or `strlcpy`. These functions take an additional parameter that specifies the maximum number of characters to be copied from the source string, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/tonga_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(fw_name) - 1` ensures that at most `sizeof(fw_name) - 1` characters are copied from the source string, leaving space for the null terminator. The second line explicitly adds the null terminator, as `strncpy` does not add it if the source string is longer than the specified length.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-473fe51b-52e7-40f9-b109-32436929cb25",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\nIn the provided code snippet:\n\n```cpp\nstrcpy(fw_name, \"amdgpu/topaz_smc.bin\");\n```\n\nThe `strcpy` function is used to copy the string \"amdgpu/topaz_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere's how you could fix the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/topaz_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate the string to ensure it's a valid C string.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-89f19891-d895-468a-90c7-edc6f75a4456",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\nIn the provided code snippet:\n\n```cpp\nstrcpy(fw_name, \"amdgpu/topaz_k_smc.bin\");\n```\n\n`strcpy` is used to copy the string \"amdgpu/topaz_k_smc.bin\" into the `fw_name` buffer. If `fw_name` is not large enough to hold this string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere's how you could fix the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/topaz_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate the string to ensure it's a valid C-string.\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so the code will require the `<cstring>` header in C++.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-0f8b2956-2f2f-4fed-acd7-f8bfe001d0b0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow. This can cause a program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\".\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that check the array bounds. In C++, this can be achieved by using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` function as shown below:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/hawaii_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name` and then manually null-terminate the string.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-204ce43c-9920-4dcb-9f0a-12e8851ba5df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\")`, the `strcpy` function is used to copy the string \"amdgpu/hawaii_k_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/hawaii_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` copies at most `sizeof(fw_name) - 1` characters from the source string to the destination buffer, and then explicitly null-terminates the destination string. This ensures that no buffer overflow occurs and that the destination string is always null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-130370c8-e443-4fd4-a529-21318686929c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/bonaire_smc.bin\")`, the string \"amdgpu/bonaire_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/bonaire_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to the `fw_name` buffer, and then manually null-terminate the string.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-c323d978-d6a9-4dfe-8272-9475466a68a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\")`, the string \"amdgpu/bonaire_k_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"amdgpu/bonaire_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-c12f0e58-65e2-44cd-b1ca-277ac1154057",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/hainan_smc.bin\")`, the string \"radeon/hainan_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/hainan_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nIn this code, `sizeof(fw_name) - 1` ensures that no more characters than the buffer can hold are copied, and the last line ensures that the string is null-terminated.\n\n## Library Dependencies\n\nThe `strcpy` and `strncpy` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-5eeadfb7-5630-4110-a497-c1812dc81d58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/banks_k_2_smc.bin\")`, the string \"radeon/banks_k_2_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/banks_k_2_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate `fw_name`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstring` (for `strcpy` and `strncpy`)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-4c066ede-e507-4dbb-a343-092c144c571a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\nIn the provided code snippet:\n\n```cpp\nstrcpy(fw_name, \"radeon/hainan_k_smc.bin\");\n```\n\n`strcpy` is used to copy the string \"radeon/hainan_k_smc.bin\" into the `fw_name` buffer. If `fw_name` is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that include a length parameter. This allows the function to ensure that it does not write past the end of the buffer.\n\nIn C++, the `strncpy` function can be used as a safer alternative to `strcpy`. It takes a length parameter, which should be set to the size of the destination buffer. This will prevent the function from writing past the end of the buffer.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/hainan_k_smc.bin\", sizeof(fw_name));\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code snippet requires the `<cstring>` library, which provides the `strcpy` and `strncpy` functions.\n\n## References\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-6757afbb-9cb7-494b-bf9c-d7993016c401",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/oland_smc.bin\")`, the `strcpy` function is used to copy the string \"radeon/oland_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow can occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. These include `strncpy`, `strlcpy`, or `memcpy`. However, these functions can also lead to other issues if not used correctly, such as not null-terminating the destination string or truncating the source string.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function and ensure the destination string is null-terminated:\n\n```cpp\nstrncpy(fw_name, \"radeon/oland_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-f1af32e2-57f6-477a-9b44-46d9db3a1475",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\nIn the provided code snippet:\n\n```cpp\nstrcpy(fw_name, \"radeon/oland_k_smc.bin\");\n```\n\nThe `strcpy` function is used to copy the string \"radeon/oland_k_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/oland_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate the string to ensure it is a valid C-string.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-02486987-af18-4b92-8ab1-f3ca82168f0d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/verde_smc.bin\")`, the `strcpy` function is used to copy the string \"radeon/verde_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/verde_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to the `fw_name` buffer, and then manually null-terminate the string.\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so the code does not require any additional library dependencies to execute.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-728c4d5c-4281-4f82-8eda-0c81d83bf972",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/verde_k_smc.bin\")`, the string \"radeon/verde_k_smc.bin\" is copied into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/verde_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-20c37a8d-f2fd-4f33-9ae8-d26ae38a0dd6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\nIn the provided code snippet:\n\n```cpp\nstrcpy(fw_name, \"radeon/pitcairn_smc.bin\");\n```\n\nThe `strcpy` function is used to copy the string \"radeon/pitcairn_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere's how you could fix the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/pitcairn_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\nThis code will copy at most `sizeof(fw_name) - 1` characters from the source string to `fw_name`, and then manually null-terminate the string.\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so the code requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-04bf104c-4941-41e1-9beb-c92229100648",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/pitcairn_k_smc.bin\")`, the `strcpy` function is used to copy the string \"radeon/pitcairn_k_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/pitcairn_k_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `strcpy` and `strncpy`)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-60337f90-1d5d-4223-aa1c-471ef6f84e71",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(fw_name, \"radeon/tahiti_smc.bin\")`, the `strcpy` function is used to copy the string \"radeon/tahiti_smc.bin\" into the `fw_name` buffer. If the `fw_name` buffer is not large enough to hold the string, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions require you to specify the maximum number of characters to copy, preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(fw_name, \"radeon/tahiti_smc.bin\", sizeof(fw_name) - 1);\nfw_name[sizeof(fw_name) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe `strcpy` function is part of the C standard library, so the code requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-4450752f-0d16-45ab-a88b-758a2362679c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the `init_table` should be checked before the `memcpy` function is called. If `init_table` is not large enough to hold the data from `direct_poll`, the function should not be called.\n\n```cpp\nif (sizeof(init_table) >= sizeof(struct mmsch_v2_0_cmd_direct_polling)) {\n    memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v2_0_cmd_direct_polling));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-effb0ee1-8cc2-4cf8-894b-bc8f3c7835bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstruct mmsch_v2_0_cmd_direct_read_modify_write init_table;\n// Ensure direct_rd_mod_wt is initialized and its size is less than or equal to sizeof(init_table)\nif (sizeof(direct_rd_mod_wt) <= sizeof(init_table)) {\n    memcpy((void *)&init_table, direct_rd_mod_wt, sizeof(direct_rd_mod_wt));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5b0968e6-cb60-4f1c-99bd-18d073528ea4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstruct mmsch_v2_0_cmd_direct_write init_table;\nif (sizeof(init_table) >= sizeof(direct_wt)) {\n    memcpy((void *)&init_table, direct_wt, sizeof(direct_wt));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `init_table` is greater than or equal to the size of `direct_wt` before calling `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-36b6488d-cb6c-4abf-b797-e9c4c8ae1f9a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2c6c3079-c068-4098-b45c-7a8c0a62da9b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-eb610f0c-7d24-4b0c-b377-c65f394a302a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-eefdd8ed-df93-4d60-a315-df2f1530cf2b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a68b8334-5d64-45cc-b75d-5a32fccede59",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-31125893-4d9a-42b6-a431-3c7c8f94f302",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"mmhub\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"mmhub\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` as follows:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"mmhub\", sizeof(ras->ras_block.ras_comm.name));\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(ras->ras_block.ras_comm.name)` characters from \"mmhub\" to `ras->ras_block.ras_comm.name`. The second line ensures that the string is null-terminated, which is not guaranteed by `strncpy` if the source string is larger than the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-14a0d650-898d-4d2a-bd3e-a6e58aa1475d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7e8bc716-c4a1-4eba-b7ee-bb3f997da60b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len)\n```\n\nThe `memcpy` function is copying `shared_buf_len` bytes from the buffer `shared_buf` to `mem_context->shared_buf`. If `shared_buf_len` is larger than the size of `mem_context->shared_buf`, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which works with C++ containers and checks the boundaries:\n\n```cpp\n#include <algorithm>\n\nstd::copy(shared_buf, shared_buf + shared_buf_len, mem_context->shared_buf);\n```\n\nIf you still need to use `memcpy`, ensure to check the size of the destination buffer:\n\n```cpp\nif (sizeof(mem_context->shared_buf) >= shared_buf_len) {\n    memcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7423480b-c442-4ebb-b628-eea71df66dfe",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the vulnerability can occur if the `count` is greater than the size of the destination buffer (`adev->psp.vbflash_tmp_buf + pos`).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `memcpy_s` or `strncpy` which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t buffer_size = sizeof(adev->psp.vbflash_tmp_buf) - pos;\nif (buffer_size >= count) {\n    memcpy(adev->psp.vbflash_tmp_buf + pos, buffer, count);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b0757132-2d91-4790-92dd-3dbdb0e2e5c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior, including memory corruption, crashes, and security vulnerabilities.\n\nIn the provided code snippet, `memcpy(psp->fw_pri_buf, start_addr, bin_size)`, if `bin_size` is larger than the size of `psp->fw_pri_buf`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (bin_size <= sizeof(psp->fw_pri_buf)) {\n    memcpy(psp->fw_pri_buf, start_addr, bin_size);\n} else {\n    // Handle the error condition, e.g., by logging an error message and exiting the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so the code snippet does not require any additional library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b93d33b8-f789-4329-8eb2-660702649f25",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of `ras_cmd->ras_out_message.address` is being copied into `out` without checking if `out` has enough space to hold the data. This can lead to a buffer overflow vulnerability, which can cause the program to crash or, in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is larger than the size of the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(ras_cmd->ras_out_message.address);\nif (size <= sizeof(out)) {\n    memcpy(out, &ras_cmd->ras_out_message.address, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fixed code, we first calculate the size of the data being copied and then check if the destination buffer is large enough to hold the data. If it is, we proceed with the copy operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ced79a97-d1d4-4b58-98eb-93919dd5a5d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow or cause denial-of-service conditions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which includes an additional parameter for the size of the destination. The fixed code would look like this:\n\n```cpp\nmemcpy_s(out, sizeof(out), &ras_cmd->ras_status, sizeof(ras_cmd->ras_status));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1e16c1f6-b0a6-4ab1-ba64-3f8584c621df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the destination buffer before calling `memcpy`. If the size of the data is greater than the size of the buffer, then the data should be truncated or the buffer should be resized appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t in_size = sizeof(in);\nsize_t buffer_size = sizeof(ras_cmd->ras_in_message.address);\n\nif (in_size <= buffer_size) {\n    memcpy(&ras_cmd->ras_in_message.address, in, in_size);\n} else {\n    // Handle error condition, e.g., by truncating data or resizing buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1948115f-5c80-43af-877e-e54e6614cae7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(ras_cmd->ras_in_message.trigger_error);\nif (size <= sizeof(in)) {\n    memcpy(&ras_cmd->ras_in_message.trigger_error, in, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is less than or equal to the size of the source. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-213a1151-94fa-4ded-88b5-6f68102fcd31",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `in` to `ras_cmd->ras_in_message`. If the size of `in` is larger than `ras_cmd->ras_in_message`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of bytes to be copied. Here's how you can modify the code to use `strncpy`:\n\n```cpp\nstrncpy(ras_cmd->ras_in_message, in, sizeof(ras_cmd->ras_in_message));\nras_cmd->ras_in_message[sizeof(ras_cmd->ras_in_message) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(ras_cmd->ras_in_message) - 1` bytes from `in` to `ras_cmd->ras_in_message`, and then null-terminate the destination string to prevent buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-49b70841-6240-4eb6-b25e-a08022c5bad8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to data corruption, crashes, and potentially code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `link_extend_info_output->nodes[i].port_num` to `topology->nodes[i].port_num`. If the size of the data in `link_extend_info_output->nodes[i].port_num` is larger than the size of `topology->nodes[i].port_num`, a buffer overflow can occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of characters to be copied. Here's how you could use it in this context:\n\n```cpp\nstrncpy(topology->nodes[i].port_num, link_extend_info_output->nodes[i].port_num, sizeof(struct xgmi_connected_port_num));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5390f014-b224-4031-909b-fadc79913e7b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nif (sizeof(psp->fw_pri_buf) >= psp->rl.size_bytes) {\n    memcpy(psp->fw_pri_buf, psp->rl.start_addr, psp->rl.size_bytes);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e82714a1-6ca7-4897-aba2-58c50e8ce632",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function:\n\n```cpp\nmemcpy_s(&cmd->resp, sizeof(cmd->resp), &psp->cmd_buf_mem->resp, sizeof(struct psp_gfx_resp));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `#include <string.h>`\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-829bc40c-0085-4a53-a3b7-711d0404f692",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy the `cmd` into `psp->cmd_buf_mem`. If the size of `cmd` is larger than `psp->cmd_buf_mem`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of bytes to be copied. Here's how you can modify the code:\n\n```cpp\nstrncpy(psp->cmd_buf_mem, cmd, sizeof(psp->cmd_buf_mem));\npsp->cmd_buf_mem[sizeof(psp->cmd_buf_mem) - 1] = '\\0';\n```\n\nIn this code, `strncpy` will copy at most `sizeof(psp->cmd_buf_mem)` bytes from `cmd` to `psp->cmd_buf_mem`. The next line ensures that `psp->cmd_buf_mem` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` and `strncpy` functions.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c37078a1-8a7d-4b15-b3a6-2d62e22cb86c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&tmp, buf + i,  6)`, if the size of `tmp` is less than 6 bytes, it can lead to a buffer overflow vulnerability.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crash, or even code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which include the size of the destination as a parameter, reducing the risk of buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `strncpy`:\n\n```cpp\nchar tmp[6];\nstrncpy(tmp, buf + i, sizeof(tmp));\ntmp[sizeof(tmp) - 1] = '\\0'; // Ensure null-termination\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-563df92f-83d3-49ff-92ff-b272911cf5f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&tmp, buf + i, 6)`, if the size of `tmp` is less than 6 bytes, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Also, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `memcpy_s`:\n\n```cpp\n#include <string.h>\n\n// Ensure tmp is at least 6 bytes\nchar tmp[6];\nmemcpy_s(&tmp, sizeof(tmp), buf + i, 6);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-63595e11-74a7-436e-ba13-23f621e524ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(&tmp, buf + i, 8)`, there is a potential risk if the size of `tmp` is less than 8 bytes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\nif(sizeof(tmp) >= 8) {\n    memcpy(&tmp, buf + i, 8);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only dependency required to use it is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dd60732a-60b8-4045-9115-2443e2862663",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(buf + i, &tmp, 6)`, there is a potential risk if the size of `buf` is less than `i + 6`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the buffer and the data before calling `memcpy`. Also, consider using safer functions like `strncpy` or `memcpy_s` (in C11) which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\n#include <cstring> // for memcpy\n#include <cassert> // for assert\n\n// ...\n\nchar buf[10];\nchar tmp[6];\nsize_t i = 0;\n\nassert(i + sizeof(tmp) <= sizeof(buf)); // Ensure buffer is large enough\nmemcpy(buf + i, &tmp, sizeof(tmp)); // Copy memory\n```\n\nIn this version, we use `assert` to ensure that the buffer is large enough before calling `memcpy`. If the buffer is not large enough, the program will terminate with an error message.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cassert>`: This library provides the `assert` function.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5090027a-7ed2-451c-a1f1-31c7c3bb76f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(buf + i, &tmp, 6)`, there is a potential risk if the size of `buf` is less than `i + 6`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the buffer and the data before calling `memcpy`. Also, consider using safer functions like `strncpy` or `memcpy_s` (in C11) which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\n#include <cstring> // for memcpy\n#include <cassert> // for assert\n\n// ...\n\nchar buf[10];\nchar tmp[6];\nsize_t i = 0;\n\nassert(i + sizeof(tmp) <= sizeof(buf)); // Ensure buffer is large enough\nmemcpy(buf + i, &tmp, sizeof(tmp)); // Copy memory\n```\n\nIn this version, we use `assert` to ensure that the buffer is large enough before calling `memcpy`. If the buffer is not large enough, the program will terminate with an error message.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cassert>`: This library provides the `assert` function.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6df26699-5076-4ee7-9b79-73753d07d949",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(buf + i, &tmp, 8)`, there is a potential risk if the size of `buf` is less than `i + 8`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the buffer and the data before calling `memcpy`. Also, consider using safer functions like `strncpy` or `memcpy_s` (in C11) which take the size of the destination buffer as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <cstring>\n\n// Ensure buf is at least 8 bytes larger than i\nif (sizeof(buf) - i >= 8) {\n    memcpy(buf + i, &tmp, 8);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `<cstring>` header file in your code.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-029b22c4-f8fd-45a7-8c54-5caf533746ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-72719730-0920-48d4-802a-7be604f28442",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source size is larger than the destination size. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)\n```\n\nThe `memcpy` function is copying `psp->sos.size_bytes` from the memory location `psp->sos.start_addr` to `psp->fw_pri_buf`. If `psp->sos.size_bytes` is larger than the size of `psp->fw_pri_buf`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the destination size before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(psp->sos.start_addr, psp->sos.start_addr + psp->sos.size_bytes, psp->fw_pri_buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-875b4996-3815-4a85-b0fe-ec9b3f6f5329",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e10fc871-7fbc-4342-b322-9d489e30f0db",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`, the `memcpy` function is copying `bin_desc->size_bytes` bytes from the memory location pointed to by `bin_desc->start_addr` to the memory location pointed to by `psp->fw_pri_buf`. If `bin_desc->size_bytes` is greater than the size of `psp->fw_pri_buf`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the data before the `memcpy` function is called.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (bin_desc->size_bytes <= sizeof(psp->fw_pri_buf)) {\n    memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes);\n} else {\n    // Handle the error condition, e.g., by logging an error message and exiting the function\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9bc9f46f-b2de-4f7d-b107-f9f9069d4461",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3bf991d6-d09b-48d8-a329-198bcdd0b516",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `ib->length_dw * 4` is larger than the size of `ib->ptr`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the destination buffer and the size of the source data before performing the `memcpy()` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = ib->length_dw * 4;\nif (size <= sizeof(ib->ptr)) {\n    memcpy(ib->ptr, kptr, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied and then check if it is less than or equal to the size of the destination buffer before performing the `memcpy()` operation.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-185c4343-c38c-401c-8f1b-056d7f77f781",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-99251425-41ea-453c-b935-e659bf7d00b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as data corruption, system crash, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy `fw_data` into `adev->gfx.me.me_fw_ptr`. If `fw_size` is larger than the size of `adev->gfx.me.me_fw_ptr`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(adev->gfx.me.me_fw_ptr)) {\n    memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if `fw_size` is less than or equal to the size of `adev->gfx.me.me_fw_ptr`. If it is, we proceed with the `memcpy` function. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f92dc23b-2ba2-4fef-a68c-686bb4c6e3be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f5622a56-a945-4fb2-9b08-4d286a02a4fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `fw_size` is larger than the size of `adev->gfx.ce.ce_fw_ptr`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(adev->gfx.ce.ce_fw_ptr)) {\n    memcpy(adev->gfx.ce.ce_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `fw_size` is less than or equal to the size of `adev->gfx.ce.ce_fw_ptr` before calling `memcpy`. If `fw_size` is larger, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ada9ee17-9b22-4d91-a07c-21ac0fdf3d71",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy `fw_data` into `adev->gfx.pfp.pfp_fw_ptr`. If `fw_size` is larger than the size of `adev->gfx.pfp.pfp_fw_ptr`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(adev->gfx.pfp.pfp_fw_ptr)) {\n    memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error: source data is too large\n}\n```\n\nIn this fix, we check if `fw_size` is less than or equal to the size of `adev->gfx.pfp.pfp_fw_ptr` before calling `memcpy`. If `fw_size` is larger, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3cef900e-8be9-4bd1-860a-5f8e91766aac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. In the provided code snippet, if `fw_size` is larger than the size of the buffer at `ptr + toc_offset`, it can lead to a buffer overflow, potentially allowing an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(ptr) - toc_offset) {\n    memcpy(ptr + toc_offset, fw_data, fw_size);\n} else {\n    // Handle error condition, such as resizing the buffer or truncating the data\n}\n```\n\nIn this code, we first check if `fw_size` is less than or equal to the size of the buffer at `ptr + toc_offset`. If it is, we proceed with the `memcpy`. If not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bcfb4e2e-5d49-479e-a3a6-27bcd1172aab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(adev->gfx.rlc.rlc_toc_buf, adev->psp.toc.start_addr, adev->psp.toc.size_bytes)\n```\n\nThe `memcpy` function is copying `adev->psp.toc.size_bytes` bytes from the memory location `adev->psp.toc.start_addr` to `adev->gfx.rlc.rlc_toc_buf`. If `adev->psp.toc.size_bytes` is larger than the size of `adev->gfx.rlc.rlc_toc_buf`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination buffer before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(adev->psp.toc.start_addr, adev->psp.toc.start_addr + adev->psp.toc.size_bytes, adev->gfx.rlc.rlc_toc_buf);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for `memcpy` and `<algorithm>` library for `std::copy`.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ef681a41-1464-4848-9839-06585418c0ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a1dcea17-bdbb-4b79-9708-782dc437048f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-43257c6d-15d7-4b19-a9f9-d89e19a47f67",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (fw_size <= sizeof(fw)) {\n    memcpy(fw, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(fw)`). If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e96cc762-a889-4fd5-bec0-c29d27cc61d9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a74a78be-260a-42c9-a6cb-f028a89a47ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5c793427-a323-4bda-99d4-07ffea0a72ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (fw_size <= sizeof(adev->mes.data_fw_ptr[pipe])) {\n    memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(adev->mes.data_fw_ptr[pipe])`). If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-10aa70b4-dd47-4d0b-825b-0728f64f97ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy` is used to copy `fw_size` bytes from `fw_data` to `adev->mes.ucode_fw_ptr[pipe]`. If `fw_size` is larger than the size of `adev->mes.ucode_fw_ptr[pipe]`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. In C++, this can be achieved by using the `std::copy` function from the `<algorithm>` library, which checks the size of the destination before copying the data.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `std::copy`:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw_data, fw_data + fw_size, adev->mes.ucode_fw_ptr[pipe]);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<algorithm>` for `std::copy`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4f546a1e-ead2-449a-af92-d062e35b46dc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `xcc_info->numa_info` is larger than `numa_info`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy`. If the source data is larger than the destination buffer, you should either increase the size of the destination buffer or reduce the size of the source data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(*xcc_info->numa_info) <= sizeof(*numa_info)) {\n    memcpy(numa_info, xcc_info->numa_info, sizeof(*numa_info));\n} else {\n    // Handle error: source data is too large\n}\n```\n\nIn this fix, we first check if the size of `xcc_info->numa_info` is less than or equal to the size of `numa_info`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7704cbd4-f2ee-45ad-91ce-e735f736961d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c6e6ec25-6381-4a46-8a7a-6130f37bf140",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function:\n\n```cpp\nmemcpy_s(misc_pkt.set_shader_debugger.tcp_watch_cntl, sizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl),\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-501bc48e-a44d-4036-b80b-4359368b8629",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (size <= sizeof(atcs_output)) {\n    memcpy(&atcs_output, info->buffer.pointer, size);\n} else {\n    // Handle error: source size is greater than destination size\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dc2fd8b1-13a1-4680-ae9c-90325fbc1078",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `output`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle the error in a way that is appropriate for your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(output)) {\n    memcpy(&output, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `size` is less than or equal to the size of `output` before calling `memcpy`. If `size` is larger, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b1bd846a-6586-499a-b739-e92b8fcbb0c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to a buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues, such as arbitrary code execution or denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source buffer and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (size <= sizeof(characteristics)) {\n    memcpy(&characteristics, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing, but they may change or become inactive over time."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e2b9a2a8-3ff3-4f81-a61b-a2873806dbc1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `params`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to serious security issues, including arbitrary code execution, data corruption, and application crashes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(params)) {\n    memcpy(&params, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `size` is less than or equal to the size of `params` before calling `memcpy`. If `size` is larger, we handle the error appropriately instead of allowing a buffer overflow to occur.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-54301c73-3608-400b-b3a4-ee929e5a9361",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `output`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle the error in a way that is appropriate for your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(output)) {\n    memcpy(&output, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `size` is less than or equal to the size of `output` before calling `memcpy`. If `size` is larger, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9867ad33-a098-45ac-9eb8-fe039db3bd8e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, data corruption, and application crashes.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((u8 *)binary, (u8 *)fw->data, fw->size)\n```\n\nThe `memcpy` function is copying `fw->size` bytes from the memory location pointed to by `fw->data` to the memory location pointed to by `binary`. If `fw->size` is larger than the size of the memory allocated for `binary`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination buffer before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw->data, fw->data + fw->size, binary);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memcpy`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6c44b8d2-1bc5-463d-a9f5-ba7c6b7a6bb1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nsize_t size = adev->mman.discovery_tmr_size;\nif (size <= sizeof(binary)) {\n    memcpy_s(binary, size, discv_regn, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2983018a-74c6-4fb6-9145-3e7625aa4e58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger than the destination buffer, the program should handle this situation gracefully, for example by truncating the source data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (fw_data_size <= sizeof(fw_data_ptr)) {\n    memcpy(fw_data_ptr, fw_data, fw_data_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_data_size`) is less than or equal to the size of the destination buffer (`sizeof(fw_data_ptr)`). If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a042dace-9012-40ad-b594-58afb4d9a347",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues, such as code execution, data corruption, and application crashes.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)\n```\n\nThe `memcpy` function is copying `fw_ucode_size` bytes from the memory area pointed to by `fw_ucode` to the memory area pointed to by `fw_ucode_ptr`. If `fw_ucode_size` is larger than the size of the memory area that `fw_ucode_ptr` points to, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw_ucode, fw_ucode + fw_ucode_size, fw_ucode_ptr);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file to use it. If you choose to use `std::copy` instead, you need to include the `<algorithm>` header file.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2fa771de-6a9c-4312-b040-ea1672dd5164",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (fw_size <= sizeof(fw)) {\n    memcpy(fw, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(fw)`). If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6ad3a502-463f-4dc1-815d-9d86d31f8bdf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the destination buffer before using `memcpy`. If the size of the source data is larger than the destination buffer, you should not proceed with the copy operation. Instead, you should handle the error in a way that does not compromise the security of your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (fw_data_size <= sizeof(adev->gfx.me.me_fw_data_ptr)) {\n    memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_data_size`) is less than or equal to the size of the destination buffer (`sizeof(adev->gfx.me.me_fw_data_ptr)`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bf15c576-8d0e-4e8e-9af6-0a3f7dafe355",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nif (fw_ucode_size <= sizeof(adev->gfx.me.me_fw_ptr)) {\n    memcpy_s(adev->gfx.me.me_fw_ptr, sizeof(adev->gfx.me.me_fw_ptr), fw_ucode, fw_ucode_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2a017be9-8b4f-4f3b-bc03-ed3785adc6d8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as data corruption, system crash, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy `fw_data` into `adev->gfx.me.me_fw_ptr`. If `fw_size` is larger than the size of `adev->gfx.me.me_fw_ptr`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(adev->gfx.me.me_fw_ptr)) {\n    memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if `fw_size` is less than or equal to the size of `adev->gfx.me.me_fw_ptr`. If it is, we proceed with the `memcpy` function. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-36a961fa-1738-449a-a74f-d028b83c1e9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the source data before copying.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function as shown below:\n\n```cpp\nif(fw_data_size <= sizeof(adev->gfx.pfp.pfp_fw_data_ptr)) {\n    memcpy_s(adev->gfx.pfp.pfp_fw_data_ptr, sizeof(adev->gfx.pfp.pfp_fw_data_ptr), fw_data, fw_data_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5944590c-0ca4-44c8-82b9-db12d4e3fcfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow, or cause a program crash (Denial of Service).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. Here is an example using `memcpy_s`:\n\n```cpp\nif (fw_ucode_size <= sizeof(adev->gfx.pfp.pfp_fw_ptr)) {\n    memcpy_s(adev->gfx.pfp.pfp_fw_ptr, sizeof(adev->gfx.pfp.pfp_fw_ptr), fw_ucode, fw_ucode_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b9044152-d482-4be0-be3c-d32b8f6b3d70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy `fw_data` into `adev->gfx.pfp.pfp_fw_ptr`. If `fw_size` is larger than the size of `adev->gfx.pfp.pfp_fw_ptr`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(adev->gfx.pfp.pfp_fw_ptr)) {\n    memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error: source data is too large\n}\n```\n\nIn this fix, we check if `fw_size` is less than or equal to the size of `adev->gfx.pfp.pfp_fw_ptr` before calling `memcpy`. If `fw_size` is larger, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fb7fae65-2999-456a-b37d-49d9a923db4b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. In the provided code snippet, if `fw_size` is larger than the size of the buffer at `ptr + toc_offset`, it can lead to a buffer overflow, potentially allowing an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(ptr) - toc_offset) {\n    memcpy(ptr + toc_offset, fw_data, fw_size);\n} else {\n    // Handle error condition, such as resizing the buffer or truncating the data\n}\n```\n\nIn this code, we first check if `fw_size` is less than or equal to the size of the buffer at `ptr + toc_offset`. If it is, we proceed with the `memcpy`. If not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-defa3ab9-00be-43c9-80ef-df3ef0b4fe86",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a6fb9117-ba8e-4218-a7f5-ce22540b917d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter. This parameter is used to specify the maximum number of characters to be copied from the source string, which prevents buffer overflow by ensuring that the destination buffer is not overrun.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with a safer alternative such as `strncpy` or `memcpy`. Here is how you can do it:\n\n```cpp\nstrncpy(adev->umc.ras->ras_block.ras_comm.name, \"umc\", sizeof(adev->umc.ras->ras_block.ras_comm.name) - 1);\n```\n\nor\n\n```cpp\nmemcpy(adev->umc.ras->ras_block.ras_comm.name, \"umc\", min(sizeof(adev->umc.ras->ras_block.ras_comm.name) - 1, strlen(\"umc\")));\n```\n\nIn both cases, the `sizeof(adev->umc.ras->ras_block.ras_comm.name) - 1` ensures that the destination buffer has enough space for the source string and the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `strcpy`, `strncpy`, and `memcpy` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-34d83736-aec5-444b-b897-4ab25de1ca79",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-bf051419-2b51-450d-943d-f28ffd701dc1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-245cfa61-184a-4084-a229-aab87bbef158",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-617bbde3-2fb6-47eb-b1c3-c73d37eb4f80",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`prev_dpcd_caps`) and the source buffer (`link->dpcd_caps`) is assumed to be the same. To fix this vulnerability, you should ensure that the size of `prev_dpcd_caps` is at least as large as `link->dpcd_caps`. If the sizes are not the same, you should resize `prev_dpcd_caps` before calling `memcpy`.\n\n```cpp\nif (sizeof(prev_dpcd_caps) < sizeof(link->dpcd_caps)) {\n    // Resize prev_dpcd_caps or handle the error\n} else {\n    memcpy(&prev_dpcd_caps, &link->dpcd_caps, sizeof(struct dpcd_caps));\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-030b21bc-a94b-4e8a-80b2-5f8ac3ea9bde",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the source buffer, it can lead to a buffer overflow. This can overwrite adjacent memory and lead to unexpected behavior, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the vulnerability arises if the size of `dsc_packed_pps` is greater than the size of `stream->dsc_packed_pps`. This would cause `memcpy` to write beyond the end of `stream->dsc_packed_pps`, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(stream->dsc_packed_pps);\nif (size > sizeof(dsc_packed_pps)) {\n    size = sizeof(dsc_packed_pps);\n}\nmemcpy(&stream->dsc_packed_pps[0], &dsc_packed_pps[0], size);\n```\n\nIn this fixed code, we first determine the size of the destination buffer. If it is larger than the size of the source buffer, we adjust it to be the size of the source buffer. This ensures that we never write beyond the end of the destination buffer.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f00f4408-27f2-428c-a9f7-af6653df16dc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-511410e2-e86e-4e5f-9f97-39cf1ab74d07",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a1135ff2-5054-4849-abd9-a0c10873bc42",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fa0e20c4-b308-4c17-b767-2343f6db1142",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-972f37fc-9a0f-42be-855d-c2d6fdc8d1a1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76dcdbe9-fb90-4371-97fb-72e01b23fb75",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-8af8ea0d-0be1-421a-9dcb-2ef284ede52a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6badea16-5405-4705-890f-df86f7660ae7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-724e2353-5ab4-4d2c-883a-af15b35c98bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, and `memcpy_s` (in C11) are safer alternatives. Always ensure that the destination buffer is large enough to hold the copied data, including the null terminator for strings.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by checking the size of `mode_lib->vba.cache_pipes` before copying data from `pipes`. Here is a possible fix:\n\n```cpp\nsize_t size = sizeof(*pipes);\nif (size <= sizeof(mode_lib->vba.cache_pipes)) {\n    memcpy(mode_lib->vba.cache_pipes, pipes, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h` (for `memcpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7aa135cb-1f3e-405f-b4a7-f2127a0f26c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, and `memcpy_s` (in C11) are safer alternatives. Always ensure that the destination buffer is large enough to hold the copied data, including the null terminator for strings.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the vulnerability can be fixed by checking the size of `mode_lib->vba.cache_pipes` before copying data from `pipes`. Here is a possible fix:\n\n```cpp\nsize_t size = sizeof(*pipes);\nif (size <= sizeof(mode_lib->vba.cache_pipes)) {\n    memcpy(mode_lib->vba.cache_pipes, pipes, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h` (for `memcpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8ebb2ea5-61e8-46ff-8af5-5da686a185f6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6b917c6f-c695-4243-a03f-110d74b5b9bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination buffer as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `mqd` is not checked before the `memcpy` function is called. To fix this, you could add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(mqd) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` header file.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7403d501-6cfc-4ca8-9609-29677e578d0d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `mqd` to `adev->gfx.mec.mqd_backup[mqd_idx]`. If the size of `mqd` is larger than the size of `adev->gfx.mec.mqd_backup[mqd_idx]`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(adev->gfx.mec.mqd_backup[mqd_idx]) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is larger than or equal to the size of the source data. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` library would need to be included for this function to work.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b121db9c-f00f-4316-bbbf-f4cec09d0b80",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `adev->gfx.kiq[xcc_id].mqd_backup` should be checked before calling `memcpy`. If the size of `mqd` is greater than the size of `adev->gfx.kiq[xcc_id].mqd_backup`, then `memcpy` should not be called.\n\n```cpp\nif(sizeof(adev->gfx.kiq[xcc_id].mqd_backup) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(adev->gfx.kiq[xcc_id].mqd_backup, mqd, sizeof(struct v9_mqd_allocation));\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, `memcpy` is part of the C standard library, so the program would at least need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cf8292db-1e6b-46b9-a96f-f259a4ade8e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `mqd` is not checked before calling `memcpy`. To fix this, you should ensure that the size of `mqd` is at least as large as `sizeof(struct v9_mqd_allocation)`.\n\n```cpp\nif (sizeof(mqd) >= sizeof(struct v9_mqd_allocation)) {\n    memcpy(mqd, adev->gfx.kiq[xcc_id].mqd_backup, sizeof(struct v9_mqd_allocation));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library dependencies:\n\n- `<string.h>`: This library is required for the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d8f87483-837e-4ae7-b509-ba8d14b2cd7a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1ba5b819-fce1-4887-8b26-ba53edfe23f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (fw_size <= sizeof(fw)) {\n    memcpy(fw, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(fw)`). If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-21c3c2b4-8d05-46dc-9dd0-2cba088d6993",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is not checked before calling `memcpy`. To fix this, you could add a check before the `memcpy` call:\n\n```cpp\nif (sizeof(stream->writeback_info[j]) >= sizeof(struct dc_writeback_info)) {\n    memcpy(&stream->writeback_info[j], &stream->writeback_info[i], sizeof(struct dc_writeback_info));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d90496d2-549a-4186-8ac3-07996a439bda",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-0e4fa5b1-ac06-44fb-b38a-4abaa04d6e89",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `dc->dml2_options` is larger than the size of `dml2_opt`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dml2_opt) >= sizeof(dc->dml2_options)) {\n    memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1a78f64f-87cd-4d10-a9d9-a2c09790257f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that `state->bw_ctx.dml` and `dc->dml` are of type `struct display_mode_lib`. To fix the vulnerability, you should ensure that the size of `state->bw_ctx.dml` is at least as large as `dc->dml`. If this is not the case, you should resize `state->bw_ctx.dml` before calling `memcpy`.\n\n```cpp\nif (sizeof(state->bw_ctx.dml) < sizeof(dc->dml)) {\n    // Resize state->bw_ctx.dml or handle error\n} else {\n    memcpy(&state->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any libraries. However, the `memcpy` function is part of the C Standard Library, so this library is required. Additionally, the `struct display_mode_lib` type is not defined in the code snippet, so the library or header file where this type is defined is also required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ac110e6e-1885-4505-9342-97e110329e76",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nstruct dc_state src_state;\nstruct dc_state dst_state;\n\n// Ensure that the destination buffer is large enough\nif (sizeof(dst_state) >= sizeof(src_state)) {\n    memcpy(&dst_state, &src_state, sizeof(src_state));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0fe23aa0-2379-4547-b43f-15a35bf82d32",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example, you can use the `memcpy_s` function, which is a safer version of `memcpy`:\n\n```cpp\nif (size <= sizeof(table_loc)) {\n    memcpy_s((void *)table_loc, sizeof(table_loc), &header, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-df2dc6be-0ad9-4e08-a92b-e0c43578c69c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example, you can use the `memcpy_s` function, which is available in C11:\n\n```cpp\nmemcpy_s(&header, sizeof(header), (void *)table_loc, size);\n```\n\nThis function will only copy data if the destination buffer is large enough to hold the source data. If the destination buffer is not large enough, the function will fail and no data will be copied.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed to use this function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that all links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-81020b3f-d143-45ba-b219-a61932392f40",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-173f9aaa-001b-4868-9d6d-992e883f31fa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer is assumed to be the same as the size of the source buffer. This assumption can lead to buffer overflow if the size of the source buffer is larger than the size of the destination buffer. To fix this, you should check the size of the destination buffer before calling `memcpy`. Here is a fixed version of the code:\n\n```cpp\nif (sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx) >= sizeof(src_ctx->res_ctx.link_enc_cfg_ctx)) {\n    memcpy(&dst_ctx->res_ctx.link_enc_cfg_ctx,\n           &src_ctx->res_ctx.link_enc_cfg_ctx,\n           sizeof(src_ctx->res_ctx.link_enc_cfg_ctx));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe provided code does not explicitly require any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code will need to include the `<cstring>` header file.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cb967155-6d69-407d-9dac-acf00a0138ab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `payload->data` to `cmd.dp_aux_access.aux_control.dpaux.data`, with the size of the data to be copied specified by `payload->length`. If `payload->length` is larger than the size of `cmd.dp_aux_access.aux_control.dpaux.data`, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to add a check for the size of the destination buffer before calling `memcpy`. Here is an example:\n\n```cpp\nsize_t dest_size = sizeof(cmd.dp_aux_access.aux_control.dpaux.data);\nif (payload->length <= dest_size) {\n    memcpy(cmd.dp_aux_access.aux_control.dpaux.data,\n           payload->data,\n           payload->length\n          );\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-836421b9-b271-48b5-b4c1-eb25f246dcbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, `memcpy` will overwrite adjacent memory, leading to undefined behavior, crashes, or even code execution.\n\nIn the provided code snippet, the size of the source buffer (`flip_addr->dirty_rects`) is used as the third argument to `memcpy`. If the size of the destination buffer (`update_dirty_rect->src_dirty_rects`) is smaller than the source buffer, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities when using `memcpy`, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nIn addition, consider using safer alternatives to `memcpy` such as `memcpy_s` or `strncpy` which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to determine the size of the destination buffer and use it as the third argument to `memcpy`:\n\n```cpp\nsize_t size = sizeof(update_dirty_rect->src_dirty_rects);\nif (size > sizeof(flip_addr->dirty_rects)) {\n    size = sizeof(flip_addr->dirty_rects);\n}\nmemcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects, size);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library (`<cstring>` in C++).\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3485779e-9f02-408a-8dcb-02c4893d6cfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, `memcpy` will overwrite adjacent memory, leading to undefined behavior, crashes, or even code execution.\n\nIn the provided code snippet, the size of the source buffer (`flip_addr->dirty_rects`) is used as the third argument to `memcpy`. If the size of the destination buffer (`update_dirty_rect->src_dirty_rects`) is smaller than the source buffer, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities when using `memcpy`, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nIn addition, consider using safer alternatives to `memcpy` such as `memcpy_s` or `strncpy` which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to determine the size of the destination buffer and use it as the third argument to `memcpy`:\n\n```cpp\nsize_t size = sizeof(update_dirty_rect->src_dirty_rects);\nif (size > sizeof(flip_addr->dirty_rects)) {\n    size = sizeof(flip_addr->dirty_rects);\n}\nmemcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects, size);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library (`<cstring>` in C++).\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d88b4d82-f33a-4f56-bf91-d0682a46576d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is greater than the size of the destination buffer. In the provided code snippet, `memcpy(&out, &buf[1], num)`, if `num` is greater than the size of `out`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(out) >= num) {\n    memcpy(&out, &buf[1], num);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fixed code, `memcpy` is only called if `out` is large enough to hold `num` bytes of data. If `out` is not large enough, an error is handled appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc4fcb5c-2ec7-4df5-965f-b472f67bc39c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which include a length parameter to avoid buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(stream->out_transfer_func.tf_pts) >= sizeof(update->out_transfer_func->tf_pts)) {\n    memcpy(&stream->out_transfer_func.tf_pts,\n           &update->out_transfer_func->tf_pts,\n           sizeof(struct dc_transfer_func_distributed_points));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to be part of a larger program, and it's not clear from the snippet alone what specific libraries it depends on. However, `memcpy` is part of the standard C library (`<cstring>` in C++, `<string.h>` in C), and `struct dc_transfer_func_distributed_points` seems to be a custom data structure, likely defined elsewhere in the program.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f255c833-1f58-4696-9367-668ada4ac2aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(surface->blend_tf) >= sizeof(srf_update->blend_tf)) {\n    memcpy(&surface->blend_tf, srf_update->blend_tf, sizeof(surface->blend_tf));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source buffer. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4a1ee427-c01f-4fe9-8826-ba92bc32e3cf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nif (sizeof(surface->lut3d_func) >= sizeof(srf_update->lut3d_func)) {\n    memcpy(&surface->lut3d_func, srf_update->lut3d_func, sizeof(surface->lut3d_func));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-522ceb79-4f58-4048-9b90-19ef34a9b651",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(surface->in_shaper_func) >= sizeof(srf_update->func_shaper)) {\n    memcpy(&surface->in_shaper_func, srf_update->func_shaper, sizeof(surface->in_shaper_func));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source data. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies other than the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `surface` and `srf_update`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b351dcca-4d66-4f56-bb49-699dba73d7a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `struct dc_transfer_func_distributed_points` is larger than the size of `surface->in_transfer_func.tf_pts`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (sizeof(surface->in_transfer_func.tf_pts) >= sizeof(struct dc_transfer_func_distributed_points)) {\n    memcpy(&surface->in_transfer_func.tf_pts,\n        &srf_update->in_transfer_func->tf_pts,\n        sizeof(struct dc_transfer_func_distributed_points));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included at the top of the file.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8a65d1e6-87e8-4a1b-a9b0-e8934b77dad3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), whenever possible.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(surface->gamma_correction.entries) >= sizeof(srf_update->gamma->entries)) {\n    memcpy(&surface->gamma_correction.entries,\n           &srf_update->gamma->entries,\n           sizeof(struct dc_gamma_entries));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0d0b2a79-c35e-4ac8-8c5a-cf8dfbea93f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the destination buffer. In the provided code snippet, if the size of `init_params->bb_overrides` is larger than `dc->bb_overrides`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(init_params->bb_overrides) <= sizeof(dc->bb_overrides)) {\n    memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));\n} else {\n    // Handle error: source data is too large for destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-032543c3-c2d1-4eaf-b146-86a63c9219db",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the source buffer size is larger than the destination buffer size. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nThis vulnerability is often exploited by attackers to execute arbitrary code or to perform a Denial of Service (DoS) attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `memcpy_s` or `strncpy`, which include built-in checks for buffer overflow conditions.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should add a check to ensure that the size of `dc->vm_pa_config` is at least as large as `sizeof(struct dc_phy_addr_space_config)` before calling `memcpy`.\n\n```cpp\nif (sizeof(dc->vm_pa_config) >= sizeof(struct dc_phy_addr_space_config)) {\n    memcpy(&dc->vm_pa_config, pa_config, sizeof(struct dc_phy_addr_space_config));\n} else {\n    // Handle error condition\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-be0348a3-e705-419f-8dc9-8e5e1028bd14",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-de4c179e-f9b1-45da-9308-9da2ba0d649e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a601f296-a112-49aa-9ee7-565d0ff59e41",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9336f0dd-5a18-473b-b4d2-b876aca3bebb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `strncpy` or `memcpy_s`:\n\n```cpp\nstrncpy(op_input.set_shader_debugger.tcp_watch_cntl, tcp_watch_cntl, sizeof(op_input.set_shader_debugger.tcp_watch_cntl));\n```\n\nor\n\n```cpp\nmemcpy_s(op_input.set_shader_debugger.tcp_watch_cntl, sizeof(op_input.set_shader_debugger.tcp_watch_cntl), tcp_watch_cntl, sizeof(op_input.set_shader_debugger.tcp_watch_cntl));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-47e08e95-552f-4d14-bbe6-4b0dcf34dab3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1c4d88bc-ce49-46fb-bb51-40b8e7c80964",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f1ca06a3-5a58-48a2-90e4-8ad4b5fca30a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-22ddcd32-7618-49d5-90be-855c24f694a6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-8ee321fb-a7a2-44bf-a715-5f6bfb62ffb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crashing of the program, or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `snprintf`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the data being copied is not checked against the size of the destination buffer. This can be fixed by adding a size check before the `memcpy` call:\n\n```cpp\nsize_t size = sizeof(uint32_t);\nif (size <= sizeof(dscl_prog_data->isharp_delta)) {\n    memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup), size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not indicate any specific library dependencies. However, the `memcpy` function is part of the C standard library, so the code will need to include `<cstring>` or `<string.h>`.\n\n## OWASP Resources\n\n- [Buffer Overflow Attacks](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-44cdbb9d-20fc-45e0-b960-83495c726de5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4d2c8ada-143e-49d9-8e70-8fc8cfc92647",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(filter_isharp_1D_lut_pregen[setup].value) >= size_1dlut) {\n    memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the destination buffer is greater than or equal to the size of the source buffer. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-639aa043-a934-49f0-bf0c-b69dd4065034",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(vf2pf_info->driver_version, \"N/A\")`, the `strcpy` function is used to copy the string \"N/A\" into the `driver_version` field of the `vf2pf_info` object. If the `driver_version` buffer is not large enough to hold the string \"N/A\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be achieved using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function as follows:\n\n```cpp\nstrncpy(vf2pf_info->driver_version, \"N/A\", sizeof(vf2pf_info->driver_version) - 1);\nvf2pf_info->driver_version[sizeof(vf2pf_info->driver_version) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(vf2pf_info->driver_version) - 1` characters from the source string to the destination buffer, and then manually null-terminate the destination string to ensure it is a valid string.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-59840ede-8fda-4837-a07e-c40da5c3657e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter. This parameter is used to specify the maximum number of characters to be copied from the source string, which prevents buffer overflow by ensuring that the destination buffer is not overrun.\n\nIn C++, these safer functions include `strncpy`, `strncat`, `snprintf`, and `vsnprintf`. However, these functions can also lead to other issues if not used correctly, such as null-termination issues or integer overflow vulnerabilities.\n\nTherefore, the best mitigation advice is to use even safer functions provided by some libraries, such as `strlcpy` and `strlcat` from the BSD library, or to use higher-level string handling facilities provided by the C++ Standard Library, such as the `std::string` class.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function and add a null character at the end to ensure the string is properly terminated:\n\n```cpp\nstrncpy(vf2pf_info->driver_version, THIS_MODULE->version, sizeof(vf2pf_info->driver_version) - 1);\nvf2pf_info->driver_version[sizeof(vf2pf_info->driver_version) - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for the `strcpy` function\n- `linux/module.h` for the `THIS_MODULE` macro\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-833901a1-6b8c-42b4-b7f2-ae64e4d9603a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability:\n\n```cpp\nif (pages * sizeof(*data->bps) <= sizeof(data->bps[data->count])) {\n    memcpy(&data->bps[data->count], bps, pages * sizeof(*data->bps));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d034f7cf-6bf3-4819-9d94-542b9bf59a14",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-154cad66-1da9-4237-9e75-4079895c05a7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ccb7ec41-edac-472f-a9c2-459fa3ad18a9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-bb535177-5164-436b-9901-982af091452b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a72b78dc-6253-45f3-9715-2ffdd7677dde",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7355e322-d821-4ca7-a6b3-655a7e1dd549",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e09d917a-4dbf-4862-bb4d-470d106cf82b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and code execution.\n\nIn the provided code snippet, the vulnerability arises if `ubo->metadata_size` is larger than the size of `buffer`. This would result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11 or later), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t buffer_size = sizeof(buffer);\nif (ubo->metadata_size <= buffer_size) {\n    memcpy(buffer, ubo->metadata, ubo->metadata_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6797f33b-5216-47ad-a27e-d323a7ad6659",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1b559644-8ba7-4b2d-8ae3-673aeaa5abdf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3b801bda-6ba7-4652-abdd-432199cc0ec6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `curr_pipe->plane_state->dcc` is larger than `phantom_plane->dcc`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(curr_pipe->plane_state->dcc) <= sizeof(phantom_plane->dcc)) {\n    memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-be73946f-0744-4506-aff9-9226355c40e7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes buffer size checks. For example:\n\n```cpp\nif(sizeof(phantom_plane->tiling_info) >= sizeof(curr_pipe->plane_state->tiling_info)) {\n    memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info, sizeof(phantom_plane->tiling_info));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required for this code to execute.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e75bdfbf-6fe4-4d19-9bb4-7b067717e8ea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer and the size of the destination buffer are not properly checked. In the provided code snippet, the `memcpy` function is copying the size of `curr_pipe->plane_state->plane_size` into `phantom_plane->plane_size`. If the size of `curr_pipe->plane_state->plane_size` is larger than `phantom_plane->plane_size`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source buffer and the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(phantom_plane->plane_size) >= sizeof(curr_pipe->plane_state->plane_size)) {\n    memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size, sizeof(phantom_plane->plane_size));\n} else {\n    // Handle the error condition when the destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ad281364-7b39-4216-997b-f1f4db8946b2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy the content of `curr_pipe->plane_state->clip_rect` to `phantom_plane->clip_rect`. If the size of `curr_pipe->plane_state->clip_rect` is larger than `phantom_plane->clip_rect`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling the `memcpy` function. Alternatively, you can use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which checks the size of the destination buffer:\n\n```cpp\nmemcpy_s(&phantom_plane->clip_rect, sizeof(phantom_plane->clip_rect), &curr_pipe->plane_state->clip_rect, sizeof(curr_pipe->plane_state->clip_rect));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required for the code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1e3ebc96-3cf3-4295-b67a-45243bbe31de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is assumed to be the same as the size of the source buffer. This assumption can lead to buffer overflow if the source buffer is larger than the destination buffer. To fix this, you should check the size of the destination buffer before calling `memcpy`.\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(phantom_plane->dst_rect) >= sizeof(curr_pipe->plane_state->dst_rect)) {\n    memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would need to include the `<cstring>` header file to use this function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d4557646-04af-423c-8f5d-f8fdd41cafea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and unauthorized access to system memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11). These functions prevent buffer overflow by not copying more than the specified size. Additionally, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`:\n\n```cpp\nmemcpy_s(&phantom_plane->src_rect, sizeof(phantom_plane->src_rect), &curr_pipe->plane_state->src_rect, sizeof(curr_pipe->plane_state->src_rect));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for the `memcpy` function\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6079680f-2d80-43b7-ab02-615f54929e81",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which checks the size of the destination buffer:\n\n```cpp\nmemcpy_s(&phantom_plane->scaling_quality, sizeof(phantom_plane->scaling_quality), &curr_pipe->plane_state->scaling_quality, sizeof(curr_pipe->plane_state->scaling_quality));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e7b3fc83-0ea3-4de7-8533-70a50e8bbced",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`phantom_plane->address`) is assumed to be the same as the size of the source buffer (`curr_pipe->plane_state->address`). This assumption could lead to buffer overflow if it's not correct.\n\nA safer version of the code would look like this:\n\n```cpp\nsize_t size = sizeof(phantom_plane->address);\nif (size <= sizeof(curr_pipe->plane_state->address)) {\n    memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, size);\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e5dd5d89-8e44-4a5c-b5d4-74aec8f9443f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix could be to add a check for the size of the destination buffer before the `memcpy` call:\n\n```cpp\nif (sizeof(phantom_stream->dst) >= sizeof(ref_pipe->stream->dst)) {\n    memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst));\n} else {\n    // Handle the error condition, e.g., by logging an error message or throwing an exception\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d712dc4f-009b-4e31-8c5e-225819fcce44",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, `memcpy` will overwrite adjacent memory, leading to undefined behavior, crashes, or even code execution.\n\nIn the provided code snippet, the vulnerability could occur if the size of `ref_pipe->stream->src` is larger than `phantom_stream->src`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif(sizeof(phantom_stream->src) >= sizeof(ref_pipe->stream->src)) {\n    memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-403b595c-4927-46b7-a39d-e8220b92bdee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer (`phantom_stream->timing`) is assumed to be the same as the size of the source buffer (`ref_pipe->stream->timing`). This assumption could lead to buffer overflow if it's not correct.\n\nA safer version of the code would look like this:\n\n```cpp\nif (sizeof(phantom_stream->timing) >= sizeof(ref_pipe->stream->timing)) {\n    memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(ref_pipe->stream->timing));\n} else {\n    // Handle the error condition when the destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-05fa0b17-87a5-4adb-bf13-b3f647c96c16",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example, you can use the `memcpy_s` function, which is a safer version of `memcpy`:\n\n```cpp\nif (size <= sizeof(table_loc)) {\n    memcpy_s((void *)table_loc, sizeof(table_loc), &header, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7047ec48-034f-43ec-a7ea-0884bc0ce854",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6cf0c493-776f-481a-9f5f-7ddb91f93a1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```cpp\nif (sizeof(dst_dml2) >= sizeof(struct dml2_context)) {\n    memcpy(dst_dml2, src_dml2, sizeof(struct dml2_context));\n} else {\n    // Handle the error condition\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data from the source buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5f66d5d3-4b24-4b38-8f05-b254e83f72f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer and the source buffer is checked using `sizeof`. However, it is not clear whether the size of the destination buffer is indeed large enough. A safer version of the code could look like this:\n\n```cpp\nif (sizeof(context->bw_ctx.bw.dcn.watermarks.c) >= sizeof(dml2->v20.g6_temp_read_watermark_set)) {\n    memcpy(&context->bw_ctx.bw.dcn.watermarks.c, &dml2->v20.g6_temp_read_watermark_set, sizeof(context->bw_ctx.bw.dcn.watermarks.c));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet seems to be part of a larger code base and it's not clear what specific libraries it depends on. However, `memcpy` is part of the C standard library, so at least this library is required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-53972ee3-47a8-423c-a5f6-b7aa38a09284",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that checks the size of the destination buffer. For example:\n\n```cpp\n#include <cstring>\n\n// Ensure init_table is large enough to hold the data being copied\nif (sizeof(init_table) >= tmp) {\n    memcpy((void *)init_table, &end, tmp);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the `<cstring>` library in C++. Therefore, the `<cstring>` library needs to be included for the code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e3e11a87-b2cf-4d95-8867-31ffab890f0a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2e1c541d-d3ec-4e31-b8d3-499b5190bc9b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6fb0609c-f36d-45c6-bde7-b2c662120d85",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-42c3d0cb-4b9d-40c8-a233-37ce129a4671",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `adev->gart.ptr` to `adev->reset_magic`. If the size of `adev->gart.ptr` is larger than `adev->reset_magic`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. Here is an example using `memcpy_s`:\n\n```cpp\nif(adev->reset_magic && adev->gart.ptr) {\n    memcpy_s(adev->reset_magic, sizeof(adev->reset_magic), adev->gart.ptr, AMDGPU_RESET_MAGIC_NUM);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++), so no additional libraries are needed for this code to execute.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-02ca371c-f8ad-48fa-a3e2-180b49de83b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1f12fb34-8b91-443f-a19c-5b24b79e2b62",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2e1c5701-d41c-4aa2-b9a5-4343a0ac2545",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(vbios_info.date) >= sizeof(atom_context->date)) {\n    memcpy(vbios_info.date, atom_context->date, sizeof(atom_context->date));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source data. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2cdfe85e-0dca-493d-a3dd-c1f09f34bd85",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the misuse of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used properly, it can lead to various security issues such as buffer overflow, which can allow an attacker to execute arbitrary code or cause a denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy the content of `atom_context->vbios_ver_str` into `vbios_info.vbios_ver_str`. The size of the copied data is determined by `sizeof(atom_context->vbios_ver_str)`. If the size of `atom_context->vbios_ver_str` is larger than `vbios_info.vbios_ver_str`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of characters to be copied. Here's how you can modify the code:\n\n```cpp\nstrncpy(vbios_info.vbios_ver_str, atom_context->vbios_ver_str, sizeof(vbios_info.vbios_ver_str) - 1);\nvbios_info.vbios_ver_str[sizeof(vbios_info.vbios_ver_str) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(vbios_info.vbios_ver_str) - 1` characters from `atom_context->vbios_ver_str` to `vbios_info.vbios_ver_str`, and then ensure that `vbios_info.vbios_ver_str` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` or `strncpy` function)\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c8685526-ca83-4596-ba43-4f3e62dd4e12",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(vbios_info.vbios_pn) >= sizeof(atom_context->vbios_pn)) {\n    memcpy(vbios_info.vbios_pn, atom_context->vbios_pn, sizeof(atom_context->vbios_pn));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-714936ed-8d84-4691-83ae-b66a842597ef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `atom_context->name` is being used as the size parameter for `memcpy`. This could potentially lead to a buffer overflow if the size of `vbios_info.name` is smaller than `atom_context->name`. To fix this, the size parameter should be the smaller of the sizes of `vbios_info.name` and `atom_context->name`.\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(vbios_info.name) < sizeof(atom_context->name) ? sizeof(vbios_info.name) : sizeof(atom_context->name);\nmemcpy(vbios_info.name, atom_context->name, size);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c73edcd0-c4ba-42c8-a8d9-44143eb7ed05",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(dev_info->cu_bitmap);\nif (size <= sizeof(adev->gfx.cu_info.bitmap)) {\n    memcpy(&dev_info->cu_bitmap[0], &adev->gfx.cu_info.bitmap[0], size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is less than or equal to the size of the source buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a future date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3ebcfcb7-afb4-46b1-8d25-0019822dca61",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing built-in protection against buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `dev_info->cu_ao_bitmap[0]` should be checked before the `memcpy` function is called. If the size of the source buffer `adev->gfx.cu_info.ao_cu_bitmap[0]` is greater than the size of the destination buffer, then the `memcpy` function should not be called.\n\n```cpp\nsize_t dest_size = sizeof(dev_info->cu_ao_bitmap);\nsize_t src_size = sizeof(adev->gfx.cu_info.ao_cu_bitmap);\n\nif (src_size <= dest_size) {\n    memcpy(&dev_info->cu_ao_bitmap[0], &adev->gfx.cu_info.ao_cu_bitmap[0], src_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-76ad1381-b713-4cc2-890a-386efa434ced",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e9808c36-7f51-406c-bfc9-80800c20ceda",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can cause memory corruption, leading to unpredictable program behavior, crashes, or even code execution.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\".\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that check the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. These functions prevent buffer overflow by not copying more characters than the destination buffer can hold.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` function:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"sdma\", sizeof(ras->ras_block.ras_comm.name) - 1);\n```\n\nThis will copy the string \"sdma\" to `ras->ras_block.ras_comm.name`, but not more than `sizeof(ras->ras_block.ras_comm.name) - 1` characters. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-b999938b-d2ec-43d4-b802-2364b2ff6345",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that all instances of `amdgpu_sdma_instance` are of the same size. If this is not the case, it could lead to a buffer overflow. To fix this, you should ensure that the size of the destination buffer is checked before calling `memcpy`. Here is a possible fix:\n\n```cpp\nif (sizeof(adev->sdma.instance[i]) >= sizeof(struct amdgpu_sdma_instance)) {\n    memcpy((void *)&adev->sdma.instance[i],\n           (void *)&adev->sdma.instance[0],\n           sizeof(struct amdgpu_sdma_instance));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what other libraries it might depend on. However, the `memcpy` function is part of the standard C library, so no additional libraries are needed for this function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e12378c9-9678-4086-9c7b-c3a5dd729eb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the vulnerability arises if the size of `from->rc_range_params` is larger than `to->rc_range_params`. This can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\nif(sizeof(to->rc_range_params) >= sizeof(from->rc_range_params)) {\n    memcpy_s(&to->rc_range_params, sizeof(to->rc_range_params), &from->rc_range_params, sizeof(from->rc_range_params));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-da4798e6-d270-4427-a700-12643e0424c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which checks the size of the destination buffer:\n\n```cpp\nmemcpy_s(&to->rc_buf_thresh, sizeof(to->rc_buf_thresh), &from->rc_buf_thresh, sizeof(from->rc_buf_thresh));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f9d3c824-d3d1-4efb-b647-5d4e6f72127c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-681a3ae0-e845-47bc-9863-02fca9f3845b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a common source of security vulnerabilities. It copies a string from one location to another, but it does not check the size of the destination buffer, which can lead to buffer overflow if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace `strcpy` with a function that checks the size of the destination buffer, such as `strncpy`, `strlcpy`, or `memcpy`. You should also ensure that the destination buffer is large enough to hold the source string and the null terminator.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"pcie_bif\", sizeof(ras->ras_block.ras_comm.name) - 1);\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nThis code uses `strncpy` to copy the string and ensures that the destination buffer is not overflowed. It also manually adds the null terminator, because `strncpy` does not add it if the source string is too large.\n\n## Library Dependencies\n\nThis code requires the `cstring` library, which provides the `strncpy` function.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-51904c4e-5c4b-4c29-9275-3adce86af26b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example, you can use the `memcpy_s` function, which is a safer version of `memcpy`:\n\n```cpp\nif (size <= sizeof(table_loc)) {\n    memcpy_s((void *)table_loc, sizeof(table_loc), &header, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d4d9920e-00ea-43fd-8fbf-b23ded197779",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-580247c9-079b-4a88-9f28-81759fc42300",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the `size` is larger than the size of `table_loc`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to serious security issues, including arbitrary code execution, data corruption, and application crashes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &end, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-21e86ada-f43e-4a47-8161-3e3795815b37",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes size checks. Here is an example of how to do this:\n\n```cpp\n#include <cstring> // for memcpy\n#include <algorithm> // for min\n\nsize_t size_to_copy = std::min(sizeof(table_loc), sizeof(direct_poll));\nmemcpy((void *)table_loc, &direct_poll, size_to_copy);\n```\n\nIn this example, the `std::min` function is used to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-11498ba1-7090-4e86-9add-d929e07dcad2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include size checks.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &direct_wt, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `table_loc` is greater than or equal to `size`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4f728d60-853c-440e-9eb3-64475964a35b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` function is called. If the source data is larger than the destination buffer, then the `memcpy` function should not be called.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &direct_rd_mod_wt, size);\n} else {\n    // Handle error condition\n}\n```\n\nIn this code, the `sizeof` function is used to get the size of the destination buffer. If the size of the destination buffer is greater than or equal to the size of the source data, then the `memcpy` function is called. Otherwise, an error condition is handled.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6bf708dd-9837-4d2d-8e99-2c98b5f80bd6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(buf, adev->mman.sdma_access_ptr, len)`, if `len` is greater than the size of `buf`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the buffer and the size of the data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `strncpy` or `memcpy_s` (if available), which includes the size of the destination buffer as a parameter. This ensures that the function does not write past the end of the buffer.\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t buf_size = sizeof(buf);\nif (len <= buf_size) {\n    memcpy(buf, adev->mman.sdma_access_ptr, len);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code requires the `<cstring>` header file.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-728e0c58-0a60-4505-8e3e-60416f3a8ba8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, then the data should not be copied and an error should be returned.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (len <= sizeof(adev->mman.sdma_access_ptr)) {\n    memcpy(adev->mman.sdma_access_ptr, buf, len);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the data being copied (`len`) is less than or equal to the size of the destination buffer (`sizeof(adev->mman.sdma_access_ptr)`). If it is, then we proceed with the `memcpy`. If it is not, then we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4bf07ba3-949c-4d0a-86c5-b202f7b28086",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is greater than the size of the destination buffer. In the provided code snippet, `memcpy(buf, &value, bytes)`, if the `bytes` is larger than the size of `buf`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(buf) >= bytes) {\n    memcpy(buf, &value, bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `buf` is greater than or equal to `bytes` before calling `memcpy`. If `buf` is not large enough, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1c9725b9-04b6-4196-8aa2-c775182d807e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the contents of `end` into `init_table`. If the size of `end` is larger than `init_table`, it can lead to a buffer overflow, which can cause the program to crash or lead to execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstruct mmsch_v1_0_cmd_end end;\nvoid *init_table = malloc(sizeof(struct mmsch_v1_0_cmd_end));\nif (init_table != NULL) {\n    memcpy(init_table, &end, sizeof(struct mmsch_v1_0_cmd_end));\n} else {\n    // Handle malloc failure\n}\n```\n\nIn this fix, we first allocate memory for `init_table` using `malloc`, ensuring it is large enough to hold the data from `end`. We then check if `malloc` was successful before proceeding with the `memcpy` operation.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `#include <stdlib.h>` for `malloc`\n- `#include <string.h>` for `memcpy`\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-184166a3-c8c1-40af-a838-a6b6f2c1609f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-bfc577d9-3fd6-4983-8ec2-ca639efa7073",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7ca8ea8c-bc57-4023-ba6c-61b77cb8ad6e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `clk_mgr_dce->max_clks_by_state` is not checked before calling `memcpy`. This can be fixed by adding a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(clk_mgr_dce->max_clks_by_state) >= sizeof(dce120_max_clks_by_state)) {\n    memcpy(clk_mgr_dce->max_clks_by_state, dce120_max_clks_by_state, sizeof(dce120_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-528d1f36-59e0-4d91-88f8-eec70d6fc0ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination buffer as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(clk_mgr_dce->max_clks_by_state) >= sizeof(dce120_max_clks_by_state)) {\n    memcpy(clk_mgr_dce->max_clks_by_state,\n           dce120_max_clks_by_state,\n           sizeof(dce120_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is large enough to hold the data from the source buffer. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a25d6cd2-2e82-44b7-9bdb-9874b9395781",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `clk_mgr_dce->max_clks_by_state` is not checked before calling `memcpy`. To fix this, you should add a check to ensure that the size of `clk_mgr_dce->max_clks_by_state` is at least as large as `dce112_max_clks_by_state`. Here is an example of how you might do this:\n\n```cpp\nif (sizeof(clk_mgr_dce->max_clks_by_state) >= sizeof(dce112_max_clks_by_state)) {\n    memcpy(clk_mgr_dce->max_clks_by_state,\n           dce112_max_clks_by_state,\n           sizeof(dce112_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so the code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cdf7577b-9cbb-41fd-a1c6-2e3227f1d2de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to determine the size of `clk_mgr_dce->max_clks_by_state` and ensure it is not less than the size of `dce110_max_clks_by_state` before calling `memcpy`.\n\n```cpp\nsize_t size = sizeof(dce110_max_clks_by_state);\nif (sizeof(clk_mgr_dce->max_clks_by_state) >= size) {\n    memcpy(clk_mgr_dce->max_clks_by_state, dce110_max_clks_by_state, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the `<cstring>` library for the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-773c4a33-0cec-4826-946b-705e26e8cfaf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `clk_mgr_dce->max_clks_by_state` is not checked before calling `memcpy`. This can be fixed by adding a size check before the `memcpy` call. Here is a possible fix:\n\n```cpp\nif (sizeof(clk_mgr_dce->max_clks_by_state) >= sizeof(dce80_max_clks_by_state)) {\n    memcpy(clk_mgr_dce->max_clks_by_state,\n           dce80_max_clks_by_state,\n           sizeof(dce80_max_clks_by_state));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` library to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-87f58cac-88ca-4d11-ad34-fb57b0c9c149",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c1706b15-749b-4e0c-8648-055c19908b75",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-95be4721-895f-408f-a981-fb35cd8dff30",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1b24a09d-277e-4963-b059-7d85af1bd4ef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a8fa36b3-4275-46e4-a1b1-2d9541091a1c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the destination buffer before using `memcpy`. If the size of the source data is larger than the destination buffer, the program should handle this situation appropriately, for example by truncating the source data or by allocating a larger buffer for the destination.\n\n## Source Code Fix Recommendation\n\nIn the given code example, the size of the destination buffer `adev->sdma.instance[i].sdma_fw_ptr` is not checked before `memcpy` is called. A possible fix could be to add a size check before the `memcpy` call:\n\n```cpp\nif (fw_size <= sizeof(adev->sdma.instance[i].sdma_fw_ptr)) {\n    memcpy(adev->sdma.instance[i].sdma_fw_ptr, fw_data, fw_size);\n} else {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the given code example.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0ee75d47-27c5-4c75-a2fe-153c3a8c556d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c6a2662b-76bf-463d-b8e4-32a6f0a9b69b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy `fw_data` into `adev->umsch_mm.data_fw_ptr`. If `fw_size` is larger than the size of `adev->umsch_mm.data_fw_ptr`, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination buffer before copying the data. Here is how you can modify the code to use `std::copy`:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw_data, fw_data + fw_size, adev->umsch_mm.data_fw_ptr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::copy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3820f492-8ec6-4b6a-b902-2712eb86dc87",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (fw_size <= sizeof(adev->umsch_mm.ucode_fw_ptr)) {\n    memcpy(adev->umsch_mm.ucode_fw_ptr, fw_data, fw_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(adev->umsch_mm.ucode_fw_ptr)`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-65943be0-6170-485e-8416-082c23c6d4ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\n// Assuming out is a pointer to a buffer of size out_size\nmemcpy_s(out, out_size, &temp_pipe->plane_res.scl_data, sizeof(*out));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f6378597-ee13-4759-a45f-f28ef99cb52f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the buffers before copying data. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` and add a size check:\n\n```cpp\nsize_t size = sizeof(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr);\nif (bytes <= size) {\n    memcpy_s(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, size, (void *)pData, bytes);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a56cc820-a935-4b26-9610-25c3863c0a62",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crashes, and code execution vulnerabilities.\n\nIn the provided code snippet, the `memcpy` function is copying data from the `src` pointer to the `dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr` pointer. If the `bytes` value is larger than the size of the destination buffer, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t dest_size = sizeof(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr);\nif (bytes <= dest_size) {\n    memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)src, bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first get the size of the destination buffer using the `sizeof` function. We then check if the `bytes` value is less than or equal to the size of the destination buffer before calling the `memcpy` function.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2e6d0909-8191-473d-82ff-7fe5bc0523ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that perform bounds checking, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which includes an additional parameter for the size of the destination. Here is how you can modify the code:\n\n```cpp\n#include <string.h> // for memcpy_s\n\n// ...\n\nstruct dmub_hw_lock_inst_flags cmd;\nsize_t dest_size = sizeof(cmd.lock_hw.lock_hw_data.inst_flags);\nsize_t src_size = sizeof(struct dmub_hw_lock_inst_flags);\n\nif (dest_size >= src_size) {\n    memcpy_s(&cmd.lock_hw.lock_hw_data.inst_flags, dest_size, inst_flags, src_size);\n} else {\n    // Handle error: destination not large enough\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<string.h>`: This library is required for the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cab24018-94c6-45c1-87a5-c66112424d1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `req`, it can lead to a buffer overflow, which can cause a program crash or potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle this situation appropriately, for example by truncating the data or allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(req)) {\n    memcpy(req, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, `memcpy` is only called if `size` is less than or equal to the size of `req`. If `size` is larger, an error is handled instead.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at a future date."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e1206ceb-6e06-402a-b55f-6c6012c54520",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the `bytes` variable is larger than the size of `pData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (bytes <= sizeof(pData)) {\n    memcpy((void *)pData, dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, bytes);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `bytes` is less than or equal to the size of `pData` before calling `memcpy`. If `bytes` is larger than the size of `pData`, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b90957ec-8701-48fc-b603-8df54a151b9a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a fix could be to check the size of `err_node->err_info.mcm_info` before copying `mcm_info` into it. If `mcm_info` is larger, you should resize `err_node->err_info.mcm_info` or limit the amount of data copied to prevent overflow.\n\n```cpp\nif(sizeof(err_node->err_info.mcm_info) >= sizeof(*mcm_info)) {\n    memcpy(&err_node->err_info.mcm_info, mcm_info, sizeof(*mcm_info));\n} else {\n    // Handle error or resize destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` library (or `<string.h>` in C) to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-76459b7e-1cb9-42ce-a976-e8afc7550b7b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a9998e9b-cf3e-485f-9179-f12f275e344b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fe6ca20a-d868-4c8e-8a46-8e6b1ffb2081",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6dc50497-efe6-472c-86fe-33e37e825a75",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the source is greater than the size of the destination. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the vulnerability arises if the size of `ras_block` is greater than the size of `query_info->head`. This can lead to a buffer overflow condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow. For example, `strncpy` or `memcpy_s` (in C11) which take the size of the destination as an argument and ensure not to exceed it.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(query_info->head) >= sizeof(struct ras_common_if)) {\n    memcpy(&query_info->head, ras_block, sizeof(struct ras_common_if));\n} else {\n    // Handle the error condition\n}\n```\n\nIn this code, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7a488bec-417f-4521-822d-595e0b33b02d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often leading to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the buffer can hold, preventing buffer overflow.\n\n```cpp\nif (data->element_size <= sizeof(data->ring) - data->wptr) {\n    memcpy_s(&data->ring[data->wptr], sizeof(data->ring) - data->wptr, info->entry, data->element_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example does not require any additional library dependencies to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-26c7f5e3-8321-441a-b74c-0a8aa25a7529",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(entry) >= data->element_size) {\n    memcpy(&entry, &data->ring[data->rptr], data->element_size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check if the size of `entry` is larger or equal to `data->element_size` before calling `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a91134d8-fffe-4327-a86f-4ca41c711fac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `test->mqd_data_cpu_addr` to `mqd`. If the size of `struct MQD_INFO` is larger than the size of the destination buffer, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination before copying. Here is how you can modify the code:\n\n```cpp\n#include <algorithm>\n\nstd::copy(test->mqd_data_cpu_addr, test->mqd_data_cpu_addr + sizeof(struct MQD_INFO), ++mqd);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<algorithm>` for `std::copy`\n- Any other libraries required by `struct MQD_INFO` and `test->mqd_data_cpu_addr`\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4fe613eb-8a43-46e0-9baf-9de923c28524",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2ceb05a5-760d-4516-93df-3e6a303d71fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (data->count * sizeof(*data->bps) <= sizeof(bps)) {\n    memcpy(bps, data->bps, data->count * sizeof(*data->bps));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer `bps` is large enough to hold the data being copied. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-be40694e-172b-47cc-bd93-2671b55e2e0b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t len = strlen(head->debugfs_name) + 1;\nif (len > sizeof(obj->fs_data.debugfs_name)) {\n    len = sizeof(obj->fs_data.debugfs_name);\n}\nmemcpy(obj->fs_data.debugfs_name, head->debugfs_name, len);\n```\n\nIn this version, we first calculate the length of the source string, including the null terminator. We then check if this length is greater than the size of the destination buffer. If it is, we truncate the length to the size of the destination buffer. Finally, we call `memcpy` with the calculated length.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fb05a3b4-6e27-4c1d-992a-f02ce6be3f07",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4e92cbbe-8436-4552-9f38-ebd07caacbdf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-296e60b4-d7f1-4435-9ffd-fd50efcb09e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4214a948-db28-4f37-a8df-9f94249eee50",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a20b6681-c22c-4928-869f-812d8d6dee0c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7b2595a1-05e3-4b97-a79c-68881d629fab",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d8460ad9-6e20-4ffb-b436-513102fad969",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-60fe7c7b-5d44-49da-89d4-70c3f3bfec2a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e0670bf4-8b8c-406c-8ac7-f350f4288505",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to write beyond it.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(set_hw_resources.osssys_base) >= sizeof(uint32_t)) {\n    memcpy(set_hw_resources.osssys_base, adev->reg_offset[OSSSYS_HWIP][0], sizeof(uint32_t));\n} else {\n    // Handle the error condition\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-40f0790e-0e7e-4750-bde3-3bab4778e0ca",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when unsafe C functions, such as `sscanf`, are used. These functions can lead to buffer overflows, format string vulnerabilities, and other security issues if not used carefully. `sscanf` is particularly risky because it does not perform bounds checking on the input buffer, which can lead to buffer overflows if the input is larger than expected.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer functions like `snprintf` or C++ streams (`std::stringstream`) that provide bounds checking and type safety.\n2. **Input Validation**: Always validate input data before processing it.\n3. **Bounds Checking**: Ensure that buffers are large enough to hold the expected input and that the input is properly null-terminated.\n4. **Compiler Warnings**: Enable compiler warnings to detect unsafe function usage.\n5. **Static Analysis Tools**: Use static analysis tools to detect and refactor unsafe code patterns.\n\n### Source Code Fix Recommendation\n\n#### Vulnerable Code Example\n\n```cpp\n#include <cstdio>\n\nvoid processInput(const char* input) {\n    char buffer[10];\n    sscanf(input, \"%s\", buffer); // Vulnerable to buffer overflow\n}\n```\n\n#### Fixed Code Example\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n\nvoid processInput(const std::string& input) {\n    std::istringstream iss(input);\n    std::string buffer;\n    iss >> buffer; // Safer alternative using C++ streams\n    if (buffer.length() > 9) {\n        std::cerr << \"Input too long!\" << std::endl;\n        return;\n    }\n    // Process buffer safely\n}\n```\n\n### Library Dependencies\n\nTo execute the fixed code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<sstream>`: For string stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dfa42e31-0d3b-47a5-8291-1ee9bc6733b5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\n#include <string.h> // for memcpy_s\n\n// ...\n\nif(sizeof(set_hw_resources.mmhub_base) >= sizeof(uint32_t)) {\n    memcpy_s(set_hw_resources.mmhub_base, sizeof(set_hw_resources.mmhub_base), adev->reg_offset[MMHUB_HWIP][0], sizeof(uint32_t));\n} else {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<string.h>`: This library is required for the `memcpy_s` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c386267f-6ef4-4685-9949-9aad4e2dc40b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4013d093-3faf-4e37-aa73-f2629911d691",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ba9f3c2a-e166-4eae-903c-cff55a3df33f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (fw_size <= sizeof(adev->mes.data_fw_ptr[pipe])) {\n    memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_size`) is less than or equal to the size of the destination buffer (`sizeof(adev->mes.data_fw_ptr[pipe])`). If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2295f8bb-719c-4fa7-8369-d2d6c17f01b7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy` is used to copy `fw_size` bytes from `fw_data` to `adev->mes.ucode_fw_ptr[pipe]`. If `fw_size` is larger than the size of `adev->mes.ucode_fw_ptr[pipe]`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo prevent buffer overflow vulnerabilities, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. In C++, this can be achieved by using the `std::copy` function from the `<algorithm>` library, which checks the size of the destination before copying the data.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `std::copy`:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw_data, fw_data + fw_size, adev->mes.ucode_fw_ptr[pipe]);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<algorithm>` for `std::copy`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c6b042a5-96f7-41b7-be4d-d66246f7df86",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function:\n\n```cpp\nmemcpy_s(misc_pkt.set_shader_debugger.tcp_watch_cntl, sizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl),\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fd3807e7-f9c9-4adb-8929-85822454f274",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `entry` is larger than `node->entry`, it can lead to a buffer overflow, causing unexpected behavior, data corruption, and potentially allowing an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(node->entry) >= sizeof(*entry)) {\n    memcpy(&node->entry, entry, sizeof(*entry));\n} else {\n    // Handle the error, e.g., by logging it or returning an error code\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-868c0133-157d-4510-86a4-a0e1e4890afd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"mca.mpio\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"mca.mpio\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"mca.mpio\", sizeof(ras->ras_block.ras_comm.name) - 1);\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nThis code will copy at most `sizeof(ras->ras_block.ras_comm.name) - 1` characters from \"mca.mpio\" to `ras->ras_block.ras_comm.name`, ensuring that the destination buffer is not overflowed. The last line ensures that the destination string is null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-ea61f94d-4f86-49a6-b7fd-032fc8a1c5dd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"mca.mp0\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"mca.mp0\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy` as follows:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"mca.mp0\", sizeof(ras->ras_block.ras_comm.name) - 1);\n```\n\nThis will copy at most `sizeof(ras->ras_block.ras_comm.name) - 1` characters from \"mca.mp0\" to `ras->ras_block.ras_comm.name`, preventing a buffer overflow. The `- 1` is to leave space for the null terminator.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-0c30bf89-9f4a-4fb0-825d-8a693f327011",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"mca.mp1\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"mca.mp1\", a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet using `strncpy`:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"mca.mp1\", sizeof(ras->ras_block.ras_comm.name) - 1);\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nIn this code, `strncpy` will copy at most `sizeof(ras->ras_block.ras_comm.name) - 1` characters from \"mca.mp1\" to `ras->ras_block.ras_comm.name`. The `- 1` is to leave space for the null terminator, which is manually added in the next line.\n\n## Library Dependencies\n\nThe code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-d0c24ca5-05b2-4a11-9f55-1c9313450df9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-17410206-609a-4dc4-82e9-069b0fcfd2e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fe5c968e-8660-46fc-a887-e61d5de18c10",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-900d4ae0-b6da-4442-a2c8-40ff6006b370",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f2402662-0ed0-4e73-9a83-c508c6d834b7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-725c9cd7-5f3b-4d28-83a4-8f85209a0c27",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes size checks. Here is an example of how to do this:\n\n```cpp\n#include <cstring> // for memcpy\n#include <algorithm> // for min\n\nsize_t size_to_copy = std::min(sizeof(table_loc), sizeof(direct_poll));\nmemcpy((void *)table_loc, &direct_poll, size_to_copy);\n```\n\nIn this example, the `std::min` function is used to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::min` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-86b40c23-c309-493d-baaa-5cf25435c790",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the `size` is larger than the size of `table_loc`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to serious security issues, including arbitrary code execution, data corruption, and application crashes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &end, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-61ec85f3-f9e4-4010-87d1-1a8e27422d19",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include size checks.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &direct_wt, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `table_loc` is greater than or equal to `size`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1c313e03-3e77-4ca2-8090-6049a5ca288c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c8142dfc-e40a-4eaa-8813-f47c43d19f62",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` function is called. If the source data is larger than the destination buffer, then the `memcpy` function should not be called.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (sizeof(table_loc) >= size) {\n    memcpy((void *)table_loc, &direct_rd_mod_wt, size);\n} else {\n    // Handle error condition\n}\n```\n\nIn this code, the `sizeof` function is used to get the size of the destination buffer. If the size of the destination buffer is greater than or equal to the size of the source data, then the `memcpy` function is called. Otherwise, an error condition is handled.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-54b329a3-447f-48a3-9241-bab50177e5e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2a49b1dc-aa4d-4a39-b739-b787a13da861",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `adev->gfx.mec.mqd_backup[mqd_idx]` should be checked before the `memcpy` function is called. If the size of `mqd` is greater than the size of the destination buffer, the `memcpy` function should not be called to prevent buffer overflow.\n\n```cpp\nif(sizeof(adev->gfx.mec.mqd_backup[mqd_idx]) >= sizeof(*mqd)) {\n    memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(*mqd));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9d47b0ad-1224-4c4c-9306-67cba4ba3887",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `adev->gfx.mec.mqd_backup[mqd_idx]` to `mqd`. If the size of `mqd` is smaller than `sizeof(*mqd)`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo prevent this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the destination range before copying. Here is how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(adev->gfx.mec.mqd_backup[mqd_idx], adev->gfx.mec.mqd_backup[mqd_idx] + sizeof(*mqd), mqd);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstring>` for `memcpy`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cfb58698-0c40-4967-920a-f08ebe39a8a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues, such as code execution, data corruption, and application crashes.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)\n```\n\nThe `memcpy` function is copying `fw_ucode_size` bytes from the memory area pointed to by `fw_ucode` to the memory area pointed to by `fw_ucode_ptr`. If `fw_ucode_size` is larger than the size of the memory area that `fw_ucode_ptr` points to, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination before copying. Here's how you can use it:\n\n```cpp\n#include <algorithm>\n\nstd::copy(fw_ucode, fw_ucode + fw_ucode_size, fw_ucode_ptr);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file to use it. If you choose to use `std::copy` instead, you need to include the `<algorithm>` header file.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-23b2b106-87b4-4c64-815c-1db1e1c83021",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the destination buffer before using `memcpy`. If the size of the source data is larger than the destination buffer, you should not proceed with the copy operation. Instead, you should handle the error in a way that does not compromise the security of your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (fw_data_size <= sizeof(adev->gfx.me.me_fw_data_ptr)) {\n    memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`fw_data_size`) is less than or equal to the size of the destination buffer (`sizeof(adev->gfx.me.me_fw_data_ptr)`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the code example to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eda3d008-03e8-41ea-9895-57faae74773c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nif (fw_ucode_size <= sizeof(adev->gfx.me.me_fw_ptr)) {\n    memcpy_s(adev->gfx.me.me_fw_ptr, sizeof(adev->gfx.me.me_fw_ptr), fw_ucode, fw_ucode_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0d27326e-05cc-4821-9a77-82af6b86cad1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the source data before copying.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function as shown below:\n\n```cpp\nif(fw_data_size <= sizeof(adev->gfx.pfp.pfp_fw_data_ptr)) {\n    memcpy_s(adev->gfx.pfp.pfp_fw_data_ptr, sizeof(adev->gfx.pfp.pfp_fw_data_ptr), fw_data, fw_data_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4551979a-c791-4424-a173-320bab16b2d9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow, or cause a program crash (Denial of Service).\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. Here is an example using `memcpy_s`:\n\n```cpp\nif (fw_ucode_size <= sizeof(adev->gfx.pfp.pfp_fw_ptr)) {\n    memcpy_s(adev->gfx.pfp.pfp_fw_ptr, sizeof(adev->gfx.pfp.pfp_fw_ptr), fw_ucode, fw_ucode_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7d60799b-06c2-483f-b76a-fe2b430e5745",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. In the provided code snippet, if `fw_size` is larger than the size of the buffer at `ptr + toc_offset`, it can lead to a buffer overflow, potentially allowing an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (fw_size <= sizeof(ptr) - toc_offset) {\n    memcpy(ptr + toc_offset, fw_data, fw_size);\n} else {\n    // Handle error condition, such as resizing the buffer or truncating the data\n}\n```\n\nIn this code, we first check if `fw_size` is less than or equal to the size of the buffer at `ptr + toc_offset`. If it is, we proceed with the `memcpy`. If not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4374c1e4-9a20-4507-8be5-5cf570128d67",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-0e2df409-39e2-4f09-8e5b-7ae69083aa9e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-01211d03-0374-4215-ac55-befe61058240",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-bf52df88-ca43-47d7-ad0d-eb93c4c5fde6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues, such as code execution, data corruption, and denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `dig_connector->dpcd` to `dp_info.dpcd`. If the size of `dig_connector->dpcd` is larger than `dp_info.dpcd`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes a buffer size check. For example:\n\n```cpp\nif (sizeof(dp_info.dpcd) >= DP_RECEIVER_CAP_SIZE) {\n    memcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c2e8a3ae-6d70-47f6-9006-28524573cb6e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE)`, the `memcpy` function is copying `DP_DPCD_SIZE` bytes from the `msg` source to the `dig_connector->dpcd` destination. If `DP_DPCD_SIZE` is larger than the size of `dig_connector->dpcd`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which includes a parameter for the maximum number of characters to be copied. Here's how you can modify the code:\n\n```cpp\nif (sizeof(dig_connector->dpcd) >= DP_DPCD_SIZE) {\n    strncpy(dig_connector->dpcd, msg, DP_DPCD_SIZE);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your code.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-81f460ce-ac7c-44f4-8be1-ac3b7c78b130",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-53b9ce8c-1e5d-4d71-afe5-b05e49451518",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size)\n```\n\nThe `memcpy` function is copying `msg->size` bytes from `msg->buffer` to `tx_buf + HEADER_SIZE`. If `msg->size` is larger than the size of `tx_buf - HEADER_SIZE`, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (msg->size <= sizeof(tx_buf) - HEADER_SIZE) {\n    memcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if `msg->size` is less than or equal to the size of `tx_buf - HEADER_SIZE`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-74333125-4151-4dcc-a967-f9e6ed8c7cff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy` is used to copy the string \"jpeg\" into `ras->ras_block.ras_comm.name`. If the size of `ras->ras_block.ras_comm.name` is less than the size of the string \"jpeg\" (including the null terminator), a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied from the source string.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nstrncpy(ras->ras_block.ras_comm.name, \"jpeg\", sizeof(ras->ras_block.ras_comm.name) - 1);\nras->ras_block.ras_comm.name[sizeof(ras->ras_block.ras_comm.name) - 1] = '\\0';\n```\n\nIn this fixed version, `strncpy` is used instead of `strcpy`, and the size of `ras->ras_block.ras_comm.name` is passed as the third argument to `strncpy`. This ensures that no more than `sizeof(ras->ras_block.ras_comm.name) - 1` characters are copied from the source string, preventing a buffer overflow. The line after the `strncpy` call ensures that the destination string is null-terminated.\n\n## Library Dependencies\n\nThe code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-404dd023-e9a9-4bdf-8d16-86eccc6fab66",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vsnprintf`.\n\nThe `vsnprintf` function is a variant of `sprintf` that takes a maximum size parameter to prevent buffer overflows. However, it can still lead to vulnerabilities if not used correctly. For example, if the size argument is not correctly calculated, it can lead to buffer overflows. Also, like `sprintf`, `vsnprintf` can lead to format string vulnerabilities if the format string is not controlled or if user input is directly used as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `vsnprintf` and other similar functions if possible. Instead, use safer alternatives that are less prone to misuse, such as `snprintf`. Always control the format string and never use user input as the format string. Also, always correctly calculate the size argument to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `vsnprintf` with `snprintf` and ensure the size argument is correctly calculated. For example, if you have the following code:\n\n```cpp\nchar buffer[1024];\nvsnprintf(buffer, sizeof(buffer), format, args);\n```\n\nYou can replace it with:\n\n```cpp\nchar buffer[1024];\nsnprintf(buffer, sizeof(buffer), \"%s\", format);\n```\n\n## Library Dependencies\n\nThe `vsnprintf` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9fa0a3d8-acd5-424f-836a-b45a0edcd20b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9a47ce38-99ec-4281-9045-8367ec79e1e1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. If the data is too large, the program should handle this condition gracefully, for example by truncating the data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t buffer_size = sizeof(ring->ring) - ring->wptr;\nif (chunk <= buffer_size) {\n    memcpy(&ring->ring[ring->wptr], s, chunk);\n} else {\n    // Handle the error condition, for example by truncating the data\n    memcpy(&ring->ring[ring->wptr], s, buffer_size);\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-39d2226b-dbd7-4e50-b6eb-ef84d4e764d3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do perform size checking, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = reg_count * sizeof(uint32_t);\nif (size <= sizeof(section->ctx.reg_dump)) {\n    memcpy(section->ctx.reg_dump, reg_dump, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy`)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1592b2ed-144d-443c-b8ed-5415e7e011c0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer size is less than the source buffer size, it can lead to buffer overflow, which can cause the program to crash or can be exploited to execute arbitrary code.\n\nIn the provided code snippet, `memcpy(hdr->record_id, record_id, 8)`, the vulnerability arises if the size of `hdr->record_id` is less than 8 bytes. This would cause `memcpy` to write beyond the end of `hdr->record_id`, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which takes the size of the destination buffer as an argument and ensures that no more than this many bytes are written to the destination. Here's how you could use `strncpy` to fix the vulnerability:\n\n```cpp\nstrncpy(hdr->record_id, record_id, sizeof(hdr->record_id));\nhdr->record_id[sizeof(hdr->record_id) - 1] = '\\0'; // Ensure null-termination\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-91700cce-1434-4f83-a7e5-5efb1bd80b11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `output`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle the error in a way that is appropriate for your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(output)) {\n    memcpy(&output, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `size` is less than or equal to the size of `output` before calling `memcpy`. If `size` is larger, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-09ed8486-2792-4741-8e11-7cf9fc1783b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `size` is larger than the size of `output`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is too large, you should handle the error in a way that is appropriate for your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(output)) {\n    memcpy(&output, info->buffer.pointer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `size` is less than or equal to the size of `output` before calling `memcpy`. If `size` is larger, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c45d0abe-bef1-4fe1-87c3-77f09c2683f0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(ring->ring, src, chunk2)`, if `chunk2` is larger than the size of `ring->ring`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nsize_t ring_size = sizeof(ring->ring);\nif (chunk2 <= ring_size) {\n    memcpy(ring->ring, src, chunk2);\n} else {\n    // Handle error: chunk2 is too large for the destination buffer\n}\n```\n\nIn this code, we first check if `chunk2` is larger than the size of `ring->ring`. If it is, we handle the error appropriately. If it's not, we proceed with the `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ee1f2384-b2a7-402e-872a-0ff90ae57c4a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often referred to as \"Detected Vulnerability in C Function (memcpy)\".\n\nBuffer overflow can lead to various security issues such as data corruption, system crash, or even allowing an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which checks the size of the destination buffer. Here is how you can do it:\n\n```cpp\nsize_t size = sizeof(ring->ring[occupied]);\nif(chunk1 <= size) {\n    memcpy_s(&ring->ring[occupied], size, src, chunk1);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\nFor `memcpy_s`, it is part of the C11 standard, so you need to include the `cstddef` header:\n\n```cpp\n#include <cstddef>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a3545f57-f062-47ee-8641-a2b394adc9ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-19eefafb-c9bb-4f03-85d8-52cad1d70581",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-8e444a0e-ea0d-46b7-8805-229df913e9e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-64b2484e-8a2e-46f8-ac08-cf10e3308fd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(nps_desc[i])` with `strnlen(nps_desc[i], MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of the string.\n\n```cpp\n// Before\nsize_t len = strlen(nps_desc[i]);\n\n// After\nsize_t len = strnlen(nps_desc[i], MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\nFor `strnlen()`, you need to include the `string.h` header:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2f532aa8-0bb8-49d6-a85c-cc2bd7006f2e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-19614eb9-4baf-4779-96d2-b1afda833be9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash of the application, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the destination buffer can hold.\n\n```cpp\n// Old vulnerable code\nmemcpy(dest, source, bytes);\n\n// Recommended fixed code\nmemcpy_s(dest, sizeof(dest), source, bytes);\n```\n\n## Library Dependencies\n\nThe `memcpy` and `memcpy_s` functions are part of the C Standard Library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8c3a71e1-5661-4579-b957-f93218cc1288",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c4aa607a-37ac-440d-8ff1-038f800428bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-8150ed94-196b-43e6-a92d-1f1de4fbf664",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d135e957-e75f-4361-9491-9737863fc2bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9f6f4556-c429-4ad1-bfd8-0dabcffbe179",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `fw_info` is larger than `dmub->meta_info`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(*fw_info) <= sizeof(dmub->meta_info)) {\n    memcpy(&dmub->meta_info, fw_info, sizeof(*fw_info));\n} else {\n    // Handle error: source data is too large for destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d4e38cf6-7124-46a8-9973-78466fc18a54",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the code:\n\n```cpp\nif (sizeof(data->bps[data->count]) >= sizeof(err_rec[j])) {\n    memcpy(&data->bps[data->count], &(err_rec[j]), sizeof(struct eeprom_table_record));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `#include <cstring>`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-22843b33-6860-4cb0-909a-7e24014e0c3d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the source buffer is larger than the destination buffer. In the provided code snippet, `memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext))`, if the size of `dpcd_ext` is larger than `dpcd`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. This can allow an attacker to execute arbitrary code, leading to a full compromise of the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(dpcd) >= sizeof(dpcd_ext)) {\n    memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `dpcd` is larger or equal to the size of `dpcd_ext` before calling `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header file to use it:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9c7fa17f-7ace-47a4-acba-70b1d0b062c7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\nIn the provided code snippet, the vulnerability lies in the use of `memcpy` function without checking if the size of `acpi_out.band_list` is greater than the size of `out->band_list`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination before copying. Here is how you can modify the code:\n\n```cpp\n#include <algorithm>\n\nstd::copy(std::begin(acpi_out.band_list), std::end(acpi_out.band_list), std::begin(out->band_list));\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstring>` for `memcpy`\n- `<algorithm>` for `std::copy`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ee46ce88-9924-4331-8f2b-0c91ab4b906f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t dest_size = sizeof(caps->data_points);\nif (data_points_size <= dest_size) {\n    memcpy(caps->data_points, custom_backlight_profiles[config_no].data_points, data_points_size);\n} else {\n    // Handle error: source is larger than destination\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-17885cd5-e4d2-477d-ba4b-ee2f30c94c5c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3fc3bce5-1d3b-4772-8885-14db4ddb7dde",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-75250e5c-19e5-4c8c-821f-45de6fe6bfe7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready);\nif (size <= sizeof(msg_in->process.receiver_message)) {\n    memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.repeater_auth_stream_ready, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-da5a1fd2-7bc6-4bba-9ced-c697af3eb43f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability lies in the use of the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This can lead to crashes, data corruption, and potentially code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do perform size checking, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage,\n           &msg_out->prepare.transmitter_message[0],\n           size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the destination buffer and check if it is less than or equal to the size of the source buffer. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc2e451f-1399-47b8-87fe-809f45aeff03",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a check for the size of the destination buffer before the `memcpy` call:\n\n```cpp\nif (sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack) >= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.repeater_auth_ack,\n           &msg_out->prepare.transmitter_message[0],\n           sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-66bc3f3a-b877-48fb-adb4-3cf30b6c4241",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.rx_id_list);\nif (size <= sizeof(msg_in->process.receiver_message)) {\n    memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.rx_id_list, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the source buffer and then check if it is smaller than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4a28d67e-f4d6-4d56-9c16-7810c030a4ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This can lead to various security issues such as data corruption, crashes, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp);\nif (size <= sizeof(msg_out->prepare.transmitter_message) - sizeof(hdcp->auth.msg.hdcp2.ske_eks)) {\n    memcpy(hdcp->auth.msg.hdcp2.content_stream_type_dp,\n           &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)],\n           size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the data to be copied and then check if the destination buffer is large enough to hold this data. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies other than the standard C++ libraries. However, the actual dependencies may vary depending on the definitions and implementations of the `hdcp` and `msg_out` objects.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5b26a79d-64e9-4559-8484-17c3a7c8ce15",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to check the size of `hdcp->auth.msg.hdcp2.ske_eks` before calling `memcpy`:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.ske_eks);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.ske_eks,\n           &msg_out->prepare.transmitter_message[0],\n           size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the code would require the `<cstring>` or `<string.h>` header file in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2d79b6e5-d8fd-45bd-a7df-4635ce61690c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.lc_l_prime);\nif (size <= sizeof(msg_in->process.receiver_message)) {\n    memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.lc_l_prime, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0f8f6e8a-1738-42d2-bea5-340fa2cac656",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.lc_init);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.lc_init, &msg_out->prepare.transmitter_message[0], size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is less than or equal to the size of the source buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies other than the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of the `hdcp` and `msg_out` objects and their member functions and variables.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2c212785-07ee-4ead-a88a-535472dcc06d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. `memcpy` is a function that copies a certain amount of memory from one location to another. If not used properly, it can lead to various security issues such as buffer overflow, which can allow an attacker to execute arbitrary code, cause a system crash, or lead to information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `hdcp->auth.msg.hdcp2.ake_pairing_info` to `&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)]`. If the size of the data being copied is larger than the destination buffer, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t dest_size = sizeof(msg_in->process.receiver_message) - sizeof(hdcp->auth.msg.hdcp2.ake_h_prime);\nsize_t src_size = sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info);\n\nif (src_size <= dest_size) {\n    memcpy(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)],\n           hdcp->auth.msg.hdcp2.ake_pairing_info, src_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the destination buffer and the size of the source data. We then check if the source data can fit into the destination buffer before performing the `memcpy` operation.\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly show any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-866add56-3458-4be7-b20f-4a1acc1b943f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(msg_in->process.receiver_message) >= sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)) {\n    memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_h_prime,\n           sizeof(hdcp->auth.msg.hdcp2.ake_h_prime));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any additional library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6a87e556-b0fa-438c-ad6d-d4044905bbfa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, the `memcpy` function is copying data from `msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)]` to `hdcp->auth.msg.hdcp2.ake_stored_km`. If the size of the data being copied is larger than the size of `hdcp->auth.msg.hdcp2.ake_stored_km`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data before copying it. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.ake_stored_km);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.ake_stored_km,\n           &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)],\n           size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, the `memcpy` function is part of the C standard library, so the code will at least need to include `<cstring>`.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-65b5b983-de93-44a6-9f11-74bc11594896",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(hdcp->auth.msg.hdcp2.ake_no_stored_km,\n           &msg_out->prepare.transmitter_message[0],\n           size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is less than or equal to the size of the source buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7e857692-b698-4ca7-a566-29449f82f266",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(msg_in->process.receiver_message) >= sizeof(hdcp->auth.msg.hdcp2.ake_cert)) {\n    memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_cert, sizeof(hdcp->auth.msg.hdcp2.ake_cert));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source data. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the specific structures and types used (`msg_in`, `hdcp`, etc.) may be part of a custom library or framework.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e9ad37e8-d3e0-492f-825c-8c800973a7d9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp2.ake_init);\nif (size <= sizeof(msg_out->prepare.transmitter_message)) {\n    memcpy(&hdcp->auth.msg.hdcp2.ake_init[0], &msg_out->prepare.transmitter_message[0], size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the destination buffer is less than or equal to the size of the source buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d345ffeb-9162-4fc8-a7eb-b4dac05bbbb6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), whenever possible.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer `hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime` should be checked before the `memcpy` function is called. If the size of the source buffer `hdcp->auth.msg.hdcp1.vp` is larger than the destination buffer, the `memcpy` function should not be called to prevent a buffer overflow.\n\n```cpp\nsize_t dest_size = sizeof(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime);\nsize_t src_size = sizeof(hdcp->auth.msg.hdcp1.vp);\n\nif (src_size <= dest_size) {\n    memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, hdcp->auth.msg.hdcp1.vp, src_size);\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet to execute properly.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-09239c52-0dbb-46b5-8e7b-a2251fd4bd71",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the source buffer, it can lead to a buffer overflow. This can cause a program to crash, or in some cases, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `hdcp->auth.msg.hdcp1.ksvlist` to `hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list`. If `hdcp->auth.msg.hdcp1.ksvlist_size` is larger than the size of the destination buffer, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to add a check for the size of the destination buffer before calling `memcpy`. Here is an example:\n\n```cpp\nsize_t dest_size = sizeof(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list);\nif (hdcp->auth.msg.hdcp1.ksvlist_size <= dest_size) {\n    memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, hdcp->auth.msg.hdcp1.ksvlist,\n           hdcp->auth.msg.hdcp1.ksvlist_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, the `memcpy` function is part of the C standard library, so the program would at least need to include `<cstring>` or `<string.h>`.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9cc864d3-538e-4cbe-a6d8-74d0977e2576",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the size of the destination buffer `hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary` should be checked before the `memcpy` function is called. If the size of the destination buffer is less than `TA_HDCP__HDCP1_KSV_SIZE`, then the `memcpy` function should not be called.\n\n```cpp\nif(sizeof(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary) >= TA_HDCP__HDCP1_KSV_SIZE)\n{\n    memcpy(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, hdcp->auth.msg.hdcp1.bksv, TA_HDCP__HDCP1_KSV_SIZE);\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` library would need to be included for the code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2ee25329-c983-4ac7-b0a9-8cb98feff608",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp1.an);\nif (size <= sizeof(hdcp_cmd->out_msg.hdcp1_create_session.an_primary)) {\n    memcpy(hdcp->auth.msg.hdcp1.an, hdcp_cmd->out_msg.hdcp1_create_session.an_primary, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9440a52c-0f2b-4ac3-a0fd-2a00fe22c403",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, a potential fix would be to add a check for the size of the destination buffer before the `memcpy` call:\n\n```cpp\nif (sizeof(hdcp->auth.msg.hdcp1.aksv) >= sizeof(hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary)) {\n    memcpy(hdcp->auth.msg.hdcp1.aksv, hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary,\n           sizeof(hdcp->auth.msg.hdcp1.aksv));\n} else {\n    // Handle the error condition when the destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. The `memcpy` function is part of the C standard library, which is included in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9bbd3ef5-c47d-427f-86b5-d28eb69492de",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `hdcp->auth.msg.hdcp1.bksv` is larger than `bksv`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(hdcp->auth.msg.hdcp1.bksv);\nif (sizeof(bksv) >= size) {\n    memcpy(bksv, hdcp->auth.msg.hdcp1.bksv, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-08141f23-7dcb-42d1-ba4f-d2b3e208cba5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` function is called. \n\nAdditionally, consider using safer functions that include the size of the destination buffer as a parameter, such as `strncpy` or `memcpy_s` (in C11 or later), which will not write past the end of the buffer.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```cpp\nmemcpy(newp, p, oldsize);\n```\n\nWith:\n\n```cpp\nif (newsize >= oldsize) {\n    memcpy(newp, p, oldsize);\n} else {\n    // Handle error: newp is not large enough to hold oldsize bytes\n}\n```\n\nOr use a safer function:\n\n```cpp\nstrncpy(newp, p, oldsize);\n```\n\nOr:\n\n```cpp\nmemcpy_s(newp, newsize, p, oldsize);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-474349c1-8cbb-48d5-a4fa-b2c5d9f6290b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `obj->buffer.pointer` to `acpi_out` without checking if `obj->buffer.length` is larger than the size of `acpi_out`. This can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the source buffer is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(acpi_out) >= obj->buffer.length) {\n    memcpy(&acpi_out, obj->buffer.pointer, obj->buffer.length);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if `acpi_out` is large enough to hold the data from `obj->buffer.pointer`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d14ec2cd-e226-41ef-ad6c-03647c7c2d7a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy()` function is copying data from `smu13_thermal_policy[0]` to `range` without checking if the size of `smu_temperature_range` is larger than the size of `range`. This can potentially lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy()`. If the size of the data being copied is larger than the size of the destination buffer, do not perform the copy operation.\n\n## Source Code Fix Recommendation\n\n```cpp\nif(sizeof(range) >= sizeof(struct smu_temperature_range)) {\n    memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn the above code, we first check if the size of `range` is larger or equal to the size of `smu_temperature_range`. If it is, we proceed with the `memcpy()` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d23b4aa1-1091-4472-8064-e46b11b9fb7e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ee2d7796-2b42-4570-95bd-176f392ee24d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `user_od_table` is larger than `size of OverDriveTableExternal_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy()`. Additionally, consider using safer functions such as `memcpy_s()` or `strncpy()`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(user_od_table) <= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `user_od_table` is less than or equal to the size of `OverDriveTableExternal_t`. If it is, we proceed with the `memcpy()`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-24571de9-1908-46ad-a294-8ebcaa9c7fbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(user_od_table_bak) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the size of `user_od_table_bak` is large enough to hold the data from `user_od_table`. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d29cf58c-21df-4390-8d4b-89bd6684f186",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8a31d611-6b63-426a-836b-51c5f57a19b7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif(sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error, e.g., by logging it or by stopping the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7cf5b23f-edb9-42b9-aa5b-455dc6a4543b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-86bd79df-9f56-4f33-ba6d-465733f04aae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy()` function is copying data from `smu13_thermal_policy[0]` to `range` without checking if the size of `smu_temperature_range` is larger than the size of `range`. This can potentially lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy()`. If the size of the data being copied is larger than the size of the destination buffer, do not perform the copy operation.\n\n## Source Code Fix Recommendation\n\n```cpp\nif(sizeof(range) >= sizeof(struct smu_temperature_range)) {\n    memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn the above code, we first check if the size of `range` is larger or equal to the size of `smu_temperature_range`. If it is, we proceed with the `memcpy()` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a78a4e1c-1d19-459b-8862-0f63b697f6fb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, the program should handle this condition gracefully, for example by allocating a larger buffer or by truncating the data to fit.\n\n## Source Code Fix Recommendation\n\nIn the given code, the size of the destination buffer `table_context->user_overdrive_table + offset_of_voltageoffset` is not checked before calling `memcpy`. A possible fix would be to add a check before the `memcpy` call:\n\n```cpp\nsize_t size = sizeof(OverDriveTableExternal_t);\nif (offset_of_voltageoffset + size <= sizeof(table_context->user_overdrive_table)) {\n    memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n           (u8 *)od_table + offset_of_voltageoffset,\n           size);\n} else {\n    // handle error condition\n}\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies beyond the standard C++ library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-96b3da90-d853-4de1-b20a-86ceb41c36f3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy()` function is copying data from `table_context->boot_overdrive_table` to `od_table`. If the size of `boot_overdrive_table` is larger than `od_table`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy()`. Additionally, consider using safer functions such as `strncpy()` or `memcpy_s()` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, table_context->boot_overdrive_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9d613c81-2056-4486-a4da-882b8bb92835",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `smc_dpm_table->BoardTable` is larger than `BoardTable_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which includes an additional parameter for the size of the destination buffer. This ensures that the function does not copy more data than the destination buffer can hold.\n\n```cpp\nmemcpy_s(BoardTable, sizeof(BoardTable_t), &smc_dpm_table->BoardTable, sizeof(BoardTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bbe9025e-e2dc-4b5f-ab20-eb68914d641a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-59aecbf3-274e-4839-9b73-3a0b78b9bde4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e0ae3403-7d11-4eff-86ad-1b97807abc9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3beef734-975e-46fa-a2d5-8ab82b355b37",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (table_size <= sizeof(table->cpu_addr)) {\n    memcpy(table->cpu_addr, table_data, table_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`table_size`) is less than or equal to the size of the destination buffer (`sizeof(table->cpu_addr)`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4dbb30b4-6a8f-4f7f-89a9-edc4ea7084f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8098d99a-c5f6-4b0c-8930-5159e2306ac6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the buffer can hold, preventing buffer overflow.\n\n```cpp\nif (table_size <= sizeof(smu_table->metrics_table)) {\n    memcpy_s(smu_table->metrics_table, sizeof(smu_table->metrics_table), table->cpu_addr, table_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE guidelines for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-43c88419-4194-4d3c-9c4b-8e1cce04174c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often referred to as \"Detected Vulnerability in C Function (memcpy)\".\n\nBuffer overflow can lead to various security issues such as data corruption, system crash, or even code execution. This can be exploited by attackers to execute arbitrary code or to cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function:\n\n```cpp\nif (table_size <= sizeof(metrics_table)) {\n    memcpy_s(metrics_table, sizeof(metrics_table), smu_table->metrics_table, table_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-87ecfff0-4eb0-44eb-842f-dad3ddf5d2e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the buffer can hold, preventing buffer overflow.\n\n```cpp\nif (table_size <= sizeof(smu_table->metrics_table)) {\n    memcpy_s(smu_table->metrics_table, sizeof(smu_table->metrics_table), table->cpu_addr, table_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE guidelines for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a54c4c25-d1e7-4d58-bd2a-c505af5c1838",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-af8d3209-5a53-4c74-8e9b-0c5586899bb0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7c713b9e-4987-4ede-bf5b-1f0f28568deb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `user_od_table` is larger than `size of OverDriveTableExternal_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy()`. Additionally, consider using safer functions such as `memcpy_s()` or `strncpy()`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(user_od_table) <= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `user_od_table` is less than or equal to the size of `OverDriveTableExternal_t`. If it is, we proceed with the `memcpy()`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ea99f8d9-5379-4c3c-a3e5-523037460287",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-53606a2e-d05e-4e89-83c6-c09cd1601517",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0bcce434-84e4-478f-8cf8-9fd1974c56cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f700483d-6062-4179-96f7-2214795f7203",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(user_od_table_bak) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the size of `user_od_table_bak` is large enough to hold the data from `user_od_table`. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-58303d23-e133-4c07-bb47-29144a18911f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif(sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error, e.g., by logging it or by stopping the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f9d902ea-4ed6-4053-a68d-d8c346b46225",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy()` function is copying data from `smu13_thermal_policy[0]` to `range` without checking if the size of `smu_temperature_range` is larger than the size of `range`. This can potentially lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy()`. If the size of the data being copied is larger than the size of the destination buffer, do not perform the copy operation.\n\n## Source Code Fix Recommendation\n\n```cpp\nif(sizeof(range) >= sizeof(struct smu_temperature_range)) {\n    memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn the above code, we first check if the size of `range` is larger or equal to the size of `smu_temperature_range`. If it is, we proceed with the `memcpy()` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1bd350c6-523b-458b-bcad-05504edb392e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, the program should handle this condition gracefully, for example by allocating a larger buffer or by truncating the data to fit.\n\n## Source Code Fix Recommendation\n\nIn the given code, the size of the destination buffer `table_context->user_overdrive_table + offset_of_voltageoffset` is not checked before calling `memcpy`. A possible fix would be to add a check before the `memcpy` call:\n\n```cpp\nsize_t size = sizeof(OverDriveTableExternal_t);\nif (offset_of_voltageoffset + size <= sizeof(table_context->user_overdrive_table)) {\n    memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n           (u8 *)od_table + offset_of_voltageoffset,\n           size);\n} else {\n    // handle error condition\n}\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies beyond the standard C++ library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b1ae1912-5d47-4f2d-9a42-d02edc5b289a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, the `memcpy()` function is copying data from `table_context->boot_overdrive_table` to `od_table`. If the size of `boot_overdrive_table` is larger than `od_table`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy()`. Additionally, consider using safer functions such as `strncpy()` or `memcpy_s()` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table,\n           table_context->boot_overdrive_table,\n           sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3455f849-1cc2-4e38-9ce8-d5a76af59401",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `smc_dpm_table->BoardTable` is larger than `BoardTable_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which includes an additional parameter for the size of the destination buffer. This ensures that the function does not copy more data than the destination buffer can hold.\n\n```cpp\nmemcpy_s(BoardTable, sizeof(BoardTable_t), &smc_dpm_table->BoardTable, sizeof(BoardTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e7dd3cfa-3ba1-4abc-98a7-fb4404e02def",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-29967a8b-b31f-44cf-bfcc-ae5f90e0e10a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-17344acc-feaa-477f-b195-31e8fb459b80",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-59eb3176-8518-46de-9f0b-c6e4b98fead3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4a6cbccd-f8b6-4249-9844-c0b8ca441f1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the destination buffer is not large enough, the program should handle this condition gracefully, for example by allocating a larger buffer or by truncating the data to fit.\n\n## Source Code Fix Recommendation\n\nIn the given code, the size of the destination buffer `table_context->user_overdrive_table + offset_of_voltageoffset` is not checked before calling `memcpy`. A possible fix would be to add a check before the `memcpy` call:\n\n```cpp\nsize_t size = sizeof(OverDriveTableExternal_t);\nif (offset_of_voltageoffset + size <= sizeof(table_context->user_overdrive_table)) {\n    memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n           (u8 *)od_table + offset_of_voltageoffset,\n           size);\n} else {\n    // handle error condition\n}\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies beyond the standard C++ library.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-642be8a9-0f7f-4b27-97c8-b7da36efe7f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, the `memcpy()` function is copying data from `table_context->boot_overdrive_table` to `od_table`. If the size of `boot_overdrive_table` is larger than `od_table`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy()`. Additionally, consider using safer functions such as `strncpy()` or `memcpy_s()` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table,\n           table_context->boot_overdrive_table,\n           sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are required for the provided code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e3e5a335-9c64-4e8e-ad81-af5951e6eba9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `user_od_table` is larger than `size of OverDriveTableExternal_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy()`. Additionally, consider using safer functions such as `memcpy_s()` or `strncpy()`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(user_od_table) <= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `user_od_table` is less than or equal to the size of `OverDriveTableExternal_t`. If it is, we proceed with the `memcpy()`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5503dbfe-3d1d-4842-914b-b9cbe610d721",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9e9f3f57-3c06-4d86-88c1-b26cce265632",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(user_od_table_bak) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the size of `user_od_table_bak` is large enough to hold the data from `user_od_table`. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f8e6ab18-8d68-436c-811f-28432cd549d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `boot_od_table` to `user_od_table`. If the size of `boot_od_table` is larger than `user_od_table`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. If the source buffer is larger, you should resize the destination buffer or truncate the source data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(boot_od_table) <= sizeof(user_od_table)) {\n    memcpy(user_od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n}\n```\n\nIn this fix, we first check if the size of `boot_od_table` is less than or equal to the size of `user_od_table`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-768d5c23-f010-4013-9770-7527d6ac4fd3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif(sizeof(od_table) >= sizeof(OverDriveTableExternal_t)) {\n    memcpy(od_table, boot_od_table, sizeof(OverDriveTableExternal_t));\n} else {\n    // Handle the error, e.g., by logging it or by stopping the program.\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-32f5b1ca-0d64-493c-be16-9db178b693fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s_s`, which include built-in checks to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstruct smu_temperature_range range;\nif (sizeof(range) >= sizeof(smu14_thermal_policy[0])) {\n    memcpy(&range, &smu14_thermal_policy[0], sizeof(smu14_thermal_policy[0]));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of `range` is large enough to hold the data from `smu14_thermal_policy[0]`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a2305d18-2d12-4e53-86cb-043618e964e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-07cd5cfb-89e1-4b6c-820f-618c4ba6986d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-72822e67-5efa-4fa1-b47d-967752fb044f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc2dd26d-e1f5-40df-9a92-f314e24435ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->average_core_c0_activity) >= sizeof(metrics.CoreC0Residency)) {\n    memcpy(&gpu_metrics->average_core_c0_activity[0],\n           &metrics.CoreC0Residency[0],\n           sizeof(metrics.CoreC0Residency));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-90a7633c-18e1-43c8-99eb-3e93692997a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code should be fixed to include a check for the size of the destination buffer before the `memcpy` function is called. Here is a corrected version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->average_ipu_activity) >= sizeof(metrics.IpuBusy)) {\n    memcpy(&gpu_metrics->average_ipu_activity[0],\n           &metrics.IpuBusy[0],\n           sizeof(metrics.IpuBusy));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d83c7d5a-1916-416d-81ce-13d6f8700739",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e4b547c5-7f3c-48f6-9ddc-dcfca9511aa6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crashes, and code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `smu_table->metrics_table` to `&metrics`. If the size of `SmuMetrics_NV12_t` is larger than the size of `metrics`, it can lead to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nAssuming `metrics` is of type `SmuMetrics_NV12_t`, the code is safe. If not, you should change the type of `metrics` to `SmuMetrics_NV12_t` to ensure it has the correct size. If changing the type of `metrics` is not possible, you should check the size of `metrics` before the `memcpy` call.\n\n```cpp\nif (sizeof(metrics) >= sizeof(SmuMetrics_NV12_t)) {\n    memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code snippet provided does not explicitly require any libraries other than the standard C++ library. However, the types `SmuMetrics_NV12_t` and the structure `smu_table` are not defined, so the actual code might have additional dependencies.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3fafcaa3-dd59-4f9d-b9aa-70472f53089b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the `metrics` buffer should be checked before calling `memcpy`. If `metrics` is not large enough to hold the data from `smu_table->metrics_table`, then `memcpy` should not be called. Here is a possible fix:\n\n```cpp\nif (sizeof(metrics) >= sizeof(SmuMetrics_NV12_legacy_t)) {\n    memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_legacy_t));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e7618688-ea51-488f-9cb6-733611650e02",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `smu_table->metrics_table` is larger than the size of `metrics`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy`. If the source data is larger than the destination buffer, you should either increase the size of the destination buffer or reduce the size of the source data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(smu_table->metrics_table) <= sizeof(SmuMetrics_t)) {\n    memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `smu_table->metrics_table` is less than or equal to the size of `metrics`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dae95026-6ef9-4205-b961-7964e2ba9bf1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `smu_table->metrics_table` to `&metrics`. If the size of `SmuMetrics_legacy_t` is larger than the size of `metrics`, this can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes a buffer size check. For example:\n\n```cpp\nif(sizeof(metrics) >= sizeof(SmuMetrics_legacy_t)) {\n    memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_legacy_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b5eb5bc7-df4d-429c-8444-c80ae760d183",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example, `memcpy(dummy_table, &DbiPrbs7[0], 0x1000)`, a block of memory of size `0x1000` is being copied to `dummy_table`. If the size of `dummy_table` is less than `0x1000`, this could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\nsize_t size = sizeof(DbiPrbs7);\nif (size <= sizeof(dummy_table)) {\n    memcpy_s(dummy_table, sizeof(dummy_table), &DbiPrbs7[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-13f96dae-d0a2-4957-863d-3db3236984af",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example, `memcpy(dummy_table, &NoDbiPrbs7[0], 0x1000)`, a block of memory of size `0x1000` is being copied to `dummy_table`. If the size of `dummy_table` is less than `0x1000`, this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\nsize_t size = sizeof(NoDbiPrbs7);\nif (size <= sizeof(dummy_table)) {\n    memcpy_s(dummy_table, sizeof(dummy_table), &NoDbiPrbs7[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-534ef6d4-80a4-47f1-8b2f-d9b1db5eb790",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes a size check. For example:\n\n```cpp\nif (sizeof(table_context->user_overdrive_table) >= sizeof(OverDriveTable_t)) {\n    memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error\n}\n```\n\nOr use `memcpy_s`:\n\n```cpp\nmemcpy_s(table_context->user_overdrive_table, sizeof(table_context->user_overdrive_table), od_table, sizeof(OverDriveTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d6059a25-fef0-4bc8-97e1-e2f83502a6e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the source buffer, it can lead to a buffer overflow, which can cause the program to crash or lead to execution of arbitrary code.\n\nIn the provided code snippet, the vulnerability arises if the size of `table_context->overdrive_table` is smaller than `table_context->boot_overdrive_table`. This would cause a buffer overflow when `memcpy` tries to copy more data than can fit into `table_context->overdrive_table`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the sizes of the buffers before calling `memcpy`.\n\nAdditionally, consider using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s` (in C11), to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to check the sizes of the buffers before calling `memcpy`:\n\n```cpp\nif (sizeof(table_context->overdrive_table) >= sizeof(OverDriveTable_t)) {\n    memcpy(table_context->overdrive_table, table_context->boot_overdrive_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a9149553-0653-4a80-bed6-a3b98af1737a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nmemcpy_s(user_od_table, sizeof(OverDriveTable_t), boot_od_table, sizeof(OverDriveTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-237c12ea-cbaf-4fb4-af61-15ffdb44efb1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `boot_od_table` is larger than `od_table`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy()`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy()` or `memcpy_s()`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(od_table) >= sizeof(boot_od_table)) {\n    memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4fa5f74f-bd5f-4527-a83d-69ddb667b26f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nstruct smu_temperature_range range;\nif (sizeof(range) >= sizeof(smu11_thermal_policy[0])) {\n    memcpy(&range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `range` is greater than or equal to the size of `smu11_thermal_policy[0]`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bb910135-8ed0-4785-9e0d-e9b45a0c6829",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6acf755d-f5e6-4113-be63-3f38859e73ba",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nstruct smu_temperature_range range;\nif (sizeof(range) >= sizeof(smu11_thermal_policy[0])) {\n    memcpy(&range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `range` is greater than or equal to the size of `smu11_thermal_policy[0]`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a503c0ee-23a4-4263-b70f-430201db13a4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter, thus providing an additional layer of safety.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(table_context->driver_pptable) >= sizeof(PPTable_t)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, sizeof(PPTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-211ec22d-41d2-46c3-8fb8-3f6d7a1c6f75",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `user_od_table` is larger than `size of OverDriveTable_t`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy()`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy()` or `memcpy_s()`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(user_od_table) <= sizeof(OverDriveTable_t)) {\n    memcpy(od_table, user_od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `user_od_table` is less than or equal to the size of `OverDriveTable_t`. If it is, we proceed with the `memcpy()`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-96aa2840-ad31-4ce2-9bbc-b3eff3a2d2a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes a size check. For example:\n\n```cpp\nif (sizeof(table_context->user_overdrive_table) >= sizeof(OverDriveTable_t)) {\n    memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error\n}\n```\n\nOr use `memcpy_s`:\n\n```cpp\nmemcpy_s(table_context->user_overdrive_table, sizeof(table_context->user_overdrive_table), od_table, sizeof(OverDriveTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-830574d8-a553-46f7-869e-1d52db2a3b70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(OverDriveTable_t);\nif (size <= sizeof(table_context->overdrive_table)) {\n    memcpy(table_context->overdrive_table, table_context->boot_overdrive_table, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5c51e203-9a14-4479-8f41-e776d326e325",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nmemcpy_s(user_od_table, sizeof(OverDriveTable_t), boot_od_table, sizeof(OverDriveTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d4e8899c-b22d-4997-bd1d-16e73e2c64aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability in the provided code:\n\n```cpp\nif (sizeof(user_od_table_bak) >= sizeof(OverDriveTable_t)) {\n    memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle the error\n}\n```\n\nIn this code, we first check if the size of `user_od_table_bak` is greater than or equal to the size of `OverDriveTable_t`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-abed2ba1-1859-4728-bb70-068b8ee72e6b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the copied data.\n\n```cpp\nmemcpy_s(user_od_table, sizeof(OverDriveTable_t), boot_od_table, sizeof(OverDriveTable_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-26a000fc-402a-42a4-b269-564f7d1ebe7d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy()` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `boot_od_table` is larger than `od_table`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy()`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy()` or `memcpy_s()`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(od_table) >= sizeof(boot_od_table)) {\n    memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy()` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3e13b00f-6098-4478-a9a2-e39daf591944",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nstruct smu_temperature_range range;\nif (sizeof(range) >= sizeof(smu11_thermal_policy[0])) {\n    memcpy(&range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of `range` is greater than or equal to the size of `smu11_thermal_policy[0]`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6c65f4d4-4d89-41b7-a61a-d41c970c3617",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the buffer size of the destination, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited to execute arbitrary code, alter the intended program flow or cause denial-of-service conditions.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11). Always ensure that the destination buffer is large enough to accommodate the data being copied from the source.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (table_size <= sizeof(table_context->driver_pptable)) {\n    memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable, table_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the `memcpy`. If it isn't, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-43a5df3f-ebc1-4e85-a9c2-ccfc28323263",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not specify the size of the data to be copied. This should be fixed by specifying the size of the data to be copied as the third argument to the `memcpy` function. The corrected code should look like this:\n\n```cpp\nmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS);\n```\n\nReplace `NUMBER_OF_ELEMENTS` with the actual number of elements to be copied.\n\n## Library Dependencies\n\nThe code snippet provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc01bd2f-0dd4-407c-a6eb-17a0998cda5b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is not checked before calling `memcpy`. This can be fixed by adding a check before the `memcpy` call:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.Current.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-11db823e-4c32-46da-91ca-60c6bb855ff5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not show the declaration of `gpu_metrics->temperature_core` and `metrics.Current.CoreTemperature`, so it's hard to provide a specific fix. However, a general fix would be to ensure that the size of the destination buffer is not less than the size of the source buffer. Here is an example:\n\n```cpp\nif (sizeof(gpu_metrics->temperature_core) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->temperature_core[0],\n           &metrics.Current.CoreTemperature[0],\n           sizeof(uint16_t));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6812d2da-d0c3-4318-a6ff-3bc98830b517",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `metrics.Current.CoreFrequency[0]` to `gpu_metrics->current_coreclk[0]` with a size of `sizeof(uint16_t)`. If the size of `gpu_metrics->current_coreclk[0]` is less than `sizeof(uint16_t)`, it could lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.Current.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-28ae68bd-b3bc-47c6-adb0-34de06e52820",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crashing of the program, or code execution.\n\nIn the provided code snippet, the `memcpy` function is copying data from `metrics.Average.CorePower[0]` to `gpu_metrics->average_core_power[0]` with a size of `sizeof(uint16_t)`. If the size of `gpu_metrics->average_core_power[0]` is less than `sizeof(uint16_t)`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(gpu_metrics->average_core_power[0]) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->average_core_power[0],\n           &metrics.Average.CorePower[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `gpu_metrics->average_core_power[0]` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly require any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-17be74b7-e520-454a-9a6f-71b3ec84af0e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `metrics.Average.CoreTemperature[0]` to `gpu_metrics->average_temperature_core[0]` without checking if the size of the data being copied is larger than the size of the destination buffer. This can lead to a buffer overflow, which can cause the program to crash or behave unpredictably.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling the `memcpy` function. If the size of the data is larger than the size of the buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_temperature_core)) {\n    memcpy(&gpu_metrics->average_temperature_core[0],\n           &metrics.Average.CoreTemperature[0],\n           size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied. Then, we check if this size is less than or equal to the size of the destination buffer. If it is, we proceed with the copy operation. Otherwise, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-518c829d-972a-43a9-b7a0-c083fc200cb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is not checked before calling `memcpy`. This can be fixed by adding a check before the `memcpy` call:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.Current.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-76af2667-52de-41a6-a285-a0878e08d026",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer is not checked before calling `memcpy`. This can be fixed by adding a check before the `memcpy` call:\n\n```cpp\nif (sizeof(gpu_metrics->temperature_core) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->temperature_core[0],\n           &metrics.Current.CoreTemperature[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bd26f877-11f2-4724-a401-c269178dc72e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not specify the size of the data to be copied. This should be fixed by specifying the size of the data to be copied as the third argument to the `memcpy` function. The corrected code should look like this:\n\n```cpp\nmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS);\n```\n\nReplace `NUMBER_OF_ELEMENTS` with the actual number of elements to be copied.\n\n## Library Dependencies\n\nThe code snippet provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dec80d3a-17ed-497d-9ee3-0f6aee15224f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the size of the source buffer, it can lead to a buffer overflow. This can cause a program to crash, or in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nThe code should be fixed to ensure that the size of the destination buffer is not smaller than the size of the source buffer. Here is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->average_temperature_core) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->average_temperature_core[0],\n           &metrics.Average.CoreTemperature[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-067aad44-4931-4580-8fbe-7417e68f8982",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not show the declaration of `gpu_metrics->temperature_core` and `metrics.Current.CoreTemperature`, so it's hard to provide a specific fix. However, a general fix would be to ensure that the size of the destination buffer is not less than the size of the source buffer. Here is an example:\n\n```cpp\nif (sizeof(gpu_metrics->temperature_core) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->temperature_core[0],\n           &metrics.Current.CoreTemperature[0],\n           sizeof(uint16_t));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3262104d-caba-41e6-84bf-c0b45029c62d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6d062f80-435b-45ec-b921-81b6d2f9abda",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2e83c8fd-d8ec-4422-9a87-668ded9fd117",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bbc0fd15-2028-4f6c-a9e7-5c4b8b6e6a43",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(gpu_metrics->current_coreclk) >= sizeof(uint16_t)) {\n    memcpy(&gpu_metrics->current_coreclk[0],\n           &metrics.CoreFrequency[0],\n           sizeof(uint16_t));\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first check if the size of `gpu_metrics->current_coreclk` is greater than or equal to `sizeof(uint16_t)`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not explicitly require any library dependencies beyond the standard C++ libraries. However, the actual dependencies may vary depending on the definitions of `gpu_metrics` and `metrics`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-19a69283-e65c-487c-87b0-5dcfd59f59fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sizeof(uint16_t);\nif (size <= sizeof(gpu_metrics->average_core_power)) {\n    memcpy(&gpu_metrics->average_core_power[0], &metrics.CorePower[0], size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c53e71bf-7152-4694-b697-5760cbeeb8d2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter, thus providing an additional layer of safety against buffer overflow.\n\n## Source Code Fix Recommendation\n\nThe code snippet provided does not include the third parameter for the `memcpy` function, which is the number of bytes to copy. This should be fixed as follows:\n\n```cpp\nmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * NUMBER_OF_ELEMENTS_TO_COPY);\n```\n\nReplace `NUMBER_OF_ELEMENTS_TO_COPY` with the actual number of elements you want to copy. Make sure that `gpu_metrics->temperature_core` has enough space to accommodate this number of elements.\n\n## Library Dependencies\n\nThe code snippet provided does not seem to require any specific library dependencies apart from the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d6b1da25-de8d-4103-874b-b12b91ced84b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer size is less than the source buffer size, it can lead to a buffer overflow. This can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\nsize_t size = smu->cpu_core_num * sizeof(uint16_t);\nif (size <= sizeof(value)) {\n    memcpy(value, &metrics->Current.CoreFrequency[0], size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data to be copied. Then, we check if the destination buffer (`value`) is large enough to hold this data. If it is, we proceed with the `memcpy`. If it's not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-27091760-4f91-4ce3-b52c-512b4669567a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is less than the size of the source buffer, a buffer overflow can occur. This can lead to various security issues, including arbitrary code execution, data corruption, and application crashes.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t copy_size = smu->cpu_core_num * sizeof(uint16_t);\nif (copy_size <= sizeof(value)) {\n    memcpy(value, &metrics->CoreFrequency[0], copy_size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<cstddef>`: for the `size_t` type\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4df4b10c-e07b-48cf-8975-2cca4c2bcc26",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to arbitrary code execution or denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy `hwmgr->ps_size` bytes from `hwmgr->request_ps` to `hwmgr->current_ps`. If `hwmgr->ps_size` is larger than the size of `hwmgr->current_ps`, this can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination buffer before copying. Here is how you can modify the code:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy(hwmgr->request_ps, hwmgr->request_ps + hwmgr->ps_size, hwmgr->current_ps);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<algorithm>`: This library provides the `std::copy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e3f6017e-f733-4422-b1ef-89daa6b7fd28",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy the `state` into `hwmgr->request_ps`. If the size of `state` is larger than `hwmgr->ps_size`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(state) <= hwmgr->ps_size) {\n    memcpy(hwmgr->request_ps, state, hwmgr->ps_size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `state` is less than or equal to `hwmgr->ps_size` before calling `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the following library to execute properly:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f300b0cd-4e40-4283-b1bb-c9aeb69362ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` if available.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (size <= sizeof(hwmgr->request_ps)) {\n    memcpy(hwmgr->request_ps, state, size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure that you are accessing trusted and secure websites when following external links."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-081157b4-e177-416a-8d6b-27ffe8468077",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the size of the source is greater than the size of the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11), whenever possible.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (size <= sizeof(hwmgr->current_ps)) {\n    memcpy(hwmgr->current_ps, state, size);\n} else {\n    // Handle error: size is too large\n}\n```\n\nIn this code, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-887b5fe2-9537-4c75-aa12-7485df57b076",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is assumed that `struct vega10_dpm_table` is the type of `data->dpm_table` and `data->golden_dpm_table`. If this is the case, the size of the destination buffer is correctly calculated using `sizeof(struct vega10_dpm_table)`. However, if `data->dpm_table` or `data->golden_dpm_table` are not of type `struct vega10_dpm_table`, the size calculation could be incorrect, leading to a buffer overflow.\n\nTo fix this, ensure that `data->dpm_table` and `data->golden_dpm_table` are indeed of type `struct vega10_dpm_table`. If they are not, adjust the size calculation accordingly.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bd0e9e86-c8d6-499c-ad58-71ed823ddde5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `thermal_data` is not checked before `memcpy` is called. A potential fix could be:\n\n```cpp\nstruct PP_TemperatureRange thermal_data[SIZE]; // Ensure SIZE is large enough\nif (sizeof(thermal_data) >= sizeof(struct PP_TemperatureRange)) {\n    memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-376cd684-3a6a-4f72-bcae-46541f9e6aa2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-451b4b0f-1b36-4770-95fe-8d3f200a28c4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-14bb293c-67d9-4c8f-a88e-6e37255d4a5f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-0c2dffa2-40d5-402f-9cb9-224695700a57",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f6f70b22-5a22-4494-8694-b8a394efb120",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9fa9f1e6-f062-49b0-aeb3-06da52d73b68",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1f43816e-51e0-4830-905b-800da6799f56",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-051b5947-7afd-4429-8b6e-ee0c95e7223a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b060d88b-9c1c-449a-80ea-f33b3f888a7a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dff8f7f1-9ba9-4ed2-8679-929836c59bb7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b024568f-94c0-4691-864b-8088c93de093",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f5ea91bb-6969-43e3-9049-52ad77b4a32a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-721e4f02-765e-428c-8f2f-1918b917e3f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7aaebf53-c1dd-445d-af91-27e134ee2103",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(data->golden_dpm_table) >= sizeof(data->dpm_table)) {\n    memcpy(&(data->golden_dpm_table), &(data->dpm_table), sizeof(struct vega10_dpm_table));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the size of `golden_dpm_table` is greater than or equal to the size of `dpm_table`. If it is, we proceed with the `memcpy`. If not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example provided does not appear to have any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b71c95c7-47c3-4d54-828c-a09e2eb02d3d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nmemcpy_s(vol_table, sizeof(struct pp_atomfwctrl_voltage_table), table, sizeof(struct pp_atomfwctrl_voltage_table));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing, but may change or become inactive over time."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-76285e7d-1aee-44c2-9247-637dffc4b7f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `thermal_data` is not checked before `memcpy` is called. A potential fix could be:\n\n```cpp\nstruct PP_TemperatureRange thermal_data[SIZE]; // Ensure SIZE is large enough\nif (sizeof(thermal_data) >= sizeof(struct PP_TemperatureRange)) {\n    memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b9030abc-5c74-4fa7-820b-8ce73de1bbdc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-871ee7ee-9304-474d-a569-8a4e98f0bb0c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-56f17130-38aa-454e-8990-4a74834416cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d555fe9d-9f8b-48cb-9fcd-bedb2feb2607",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b28ab71e-6024-4702-815f-e7364268d5d2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f51778ad-2fcb-4867-8c67-98209764850e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a80da833-5236-4da5-9a02-79b04699412b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5676308d-4428-4783-be86-87ff3ffdffcb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d6974ac7-d744-41bc-aa96-bed7507ac9e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6bd41499-fad1-4a26-b492-48803d677c6b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ad923652-08d0-4177-b073-b181bcff8310",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-302abe1b-f7c9-4d62-bceb-80b8ea1ca070",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-18ace9c1-e45d-4644-ba47-6f4eb2320d29",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-f2dc0ee2-6552-43e4-889d-d2c0391586ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5634e058-3f0f-4c60-aa3f-399f17815aee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-41e2e616-dbe5-4c27-98a9-8a4daed6ec1e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-27e926ee-30ec-48b5-ba9e-b43ee066c23a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-37458e99-65c5-4ae0-8f22-0c71042b4ee0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e217ae38-9f37-4733-a8a0-73e30325c20a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1437a77e-0aa2-420c-8ea3-3f8f6cab212f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b8b1f54d-44b3-439d-a596-b502201f34a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-60b74053-5db8-44c0-b7af-5c1475de5630",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-822229bc-6b2e-46e6-b2d5-82db276795b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-041c4c7e-5285-471a-b63e-a8b867f6f9aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76d528b6-f20e-4da1-9965-722972f8f947",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-373fc107-b757-487f-ad2a-b3bc15ad089a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1efbbe90-277d-47d4-adfe-bdce8c453c82",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-945c52b6-430b-48c0-b647-97022e32ca61",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-06236901-ef68-4e8d-95fb-edebcbc0eaa8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will ensure that the function does not write past the end of the buffer.\n\n```cpp\nmemcpy_s(metrics_table, sizeof(SmuMetrics_t), &data->metrics_table, sizeof(SmuMetrics_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d080e881-0f58-4fc5-990b-71d634d6d4fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pptable_information->smc_pptable` is larger than the size of `pp_table`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include built-in bounds checking to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(PPTable_t);\nif (size <= sizeof(pp_table)) {\n    memcpy(pp_table, pptable_information->smc_pptable, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `pp_table` is large enough to hold the data from `pptable_information->smc_pptable`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1602f932-8bbf-4c52-af55-804c4e4f2f03",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer and the source buffer is assumed to be the same. This can be dangerous if the assumption is incorrect. A safer version of the code would look like this:\n\n```cpp\nif (sizeof(data->golden_dpm_table) >= sizeof(struct vega20_dpm_table)) {\n    memcpy(&(data->golden_dpm_table), &(data->dpm_table), sizeof(struct vega20_dpm_table));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-15a63041-1c2d-4ff8-a6ad-640ee6fbf762",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `smu7_profiling[mode]` is larger than the size of `tmp`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(tmp) >= sizeof(smu7_profiling[mode])) {\n    memcpy(&tmp, &smu7_profiling[mode], sizeof(struct profile_mode_setting));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `tmp` is larger or equal to the size of `smu7_profiling[mode]`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet does not require any additional library dependencies to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8392cbb6-1466-4a96-9e91-1dd6f16d1261",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that limit the amount of data copied to the size of the destination buffer. Functions such as `strncpy`, `snprintf`, or `memcpy_s` (in C11) can be used to prevent buffer overflow. It is also important to validate and sanitize all inputs to ensure they are within expected ranges.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&data->current_profile_setting, sizeof(struct profile_mode_setting), &tmp, sizeof(struct profile_mode_setting));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e7547a0d-c020-4314-93e2-01cd96c9c7df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `SMU7ThermalPolicy[0]` is larger than `thermal_data`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(thermal_data) >= sizeof(struct PP_TemperatureRange)) {\n    memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if `thermal_data` is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-914a252c-b141-4b44-990e-e9df6fde9174",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-81c2f999-3685-48c2-bdba-ab2c117a4666",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d2862a4c-76e6-4d06-a035-9d5290290173",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dc53b50c-5814-4a8d-8671-a8fdf84535b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-de5cd990-e4ef-4b18-b009-287c0bd86118",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6c870e37-9e3b-4e57-90ec-52e4b889b9a7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3c289225-8c03-4f11-9bfb-b0c814df4af1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c3e49b81-67df-4c82-b44c-1dc584f0c0f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-62bb37dd-1437-4e35-ac15-aa20709d78eb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-51eecb69-239e-4064-8f7b-0ef548a6a422",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4130f382-b81e-4585-a896-e4b81524fe18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-280069ac-1a9e-406d-aa50-11d4048a0881",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer and the source buffer is assumed to be `sizeof(struct smu7_dpm_table)`. If this is not the case, it can lead to buffer overflow. To fix this, you should ensure that `golden_dpm_table` is large enough to hold `dpm_table`. If `golden_dpm_table` is a fixed-size array, you can do this by comparing `sizeof(golden_dpm_table)` with `sizeof(dpm_table)` before calling `memcpy`.\n\n```cpp\nif (sizeof(data->golden_dpm_table) >= sizeof(data->dpm_table)) {\n    memcpy(&(data->golden_dpm_table), &(data->dpm_table), sizeof(struct smu7_dpm_table));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to depend on the following libraries:\n\n- `string.h` (for `memcpy`)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3ebd6d3e-137c-437e-9bd9-16ee7b588b9c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the destination buffer is smaller than the source buffer. This can lead to overwriting of adjacent memory and can cause unpredictable behavior of the program, including crashes, data corruption, and code execution.\n\nIn the provided code snippet, `memcpy` is used to copy data from `table` to `vol_table`. If the size of `table` is larger than `vol_table`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no more than this size is written.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(vol_table) >= sizeof(struct pp_atomctrl_voltage_table)) {\n    memcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table));\n} else {\n    // Handle the error condition, e.g., by logging an error message or throwing an exception\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-86c9c26e-83fa-4d19-93b8-8917b4ea597d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `SMU7ThermalPolicy[0]` is larger than `thermal_data`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(thermal_data) >= sizeof(struct PP_TemperatureRange)) {\n    memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if `thermal_data` is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f6e3f6d3-cf04-4e30-b759-3510161f7b1a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-770f80da-393c-4617-8a46-ffff540e3a11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b5ecb438-ed98-4441-af6f-bbbb220e3b96",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which include the size of the destination as a parameter and can prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of `thermal_data` is not checked before `memcpy` is called. A potential fix could be:\n\n```cpp\nstruct PP_TemperatureRange thermal_data[SIZE]; // Ensure SIZE is large enough\nif (sizeof(thermal_data) >= sizeof(struct PP_TemperatureRange)) {\n    memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e29b2aef-1d49-4f0e-a38b-d3aefe12e689",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5248fc02-226d-4313-8fec-318106f3d062",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-25300bf7-55f0-4dd5-a851-c035e5fbaecf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76c0cab9-258d-4cbd-88ff-e3d48982ee2a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-78e40708-d38e-45f3-bb82-77175c3125e4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will ensure that the function does not write past the end of the buffer.\n\n```cpp\nmemcpy_s(metrics_table, sizeof(SmuMetrics_t), &data->metrics_table, sizeof(SmuMetrics_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-306b4486-6be0-4237-a266-f9024ff6e472",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `pptable_information->smc_pptable` is larger than the size of `pp_table`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include built-in bounds checking to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(PPTable_t);\nif (size <= sizeof(pp_table)) {\n    memcpy(pp_table, pptable_information->smc_pptable, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `pp_table` is large enough to hold the data from `pptable_information->smc_pptable`. If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b9a6ee7d-92ca-4d2a-92c3-5915847afceb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(data->golden_dpm_table) >= sizeof(data->dpm_table)) {\n    memcpy(&(data->golden_dpm_table), &(data->dpm_table), sizeof(struct vega12_dpm_table));\n} else {\n    // Handle the error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source buffer. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6430a3c4-30b6-4ba2-88be-77f27d4be0f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-43aa1c77-c828-4df0-a770-7cfc7f4b793e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1a8acd5e-b1c7-430d-93e7-0d65de83d58b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9329372a-712e-4a2f-8f71-31596356a6c2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-738748b7-adab-40df-a3be-b845d98bad64",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-0e5926e5-887d-476d-a7e8-62f8bb68af4d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-82cf17f5-053a-4d71-8365-652ba50b07db",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5f205812-dcdb-45d2-8cd7-0b9b0d5b6530",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c97b3f5f-3818-41a2-830f-121e09ea4eda",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-859785c1-7c99-4645-8c6d-e8baf0a148e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (size <= sizeof(priv->smu_tables.entry[table_id].table)) {\n    memcpy(priv->smu_tables.entry[table_id].table, table, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d78b9e83-5f5f-479a-ae65-a221bde243bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (sizeof(table) >= size) {\n    memcpy(table, priv->smu_tables.entry[table_id].table, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9973cb18-3e30-4dee-a0aa-ceee540bbb6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (size <= sizeof(priv->smu_tables.entry[table_id].table)) {\n    memcpy(priv->smu_tables.entry[table_id].table, table, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-54d8a526-92f0-49c8-b9de-23dc3348bfcc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (sizeof(table) >= size) {\n    memcpy(table, priv->smu_tables.entry[table_id].table, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-25e7f557-5af7-4e0b-a8b4-12f021c6b88c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (size <= sizeof(priv->smu_tables.entry[table_id].table)) {\n    memcpy(priv->smu_tables.entry[table_id].table, table, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c643d50d-8826-4c2a-80e7-7b95c60d05ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The problem arises when the size of the destination buffer is smaller than the source buffer. This can lead to buffer overflow, which is a serious security vulnerability as it can allow an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no buffer overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size;\nif (sizeof(table) >= size) {\n    memcpy(table, priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-60246e89-c078-4e63-bfa4-a9c799c51fe0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always check the size of the destination buffer before using `memcpy`. If the size of the source is larger than the destination, you should not proceed with the copy operation. Instead, you should handle the error in a way that is appropriate for your application.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (size > sizeof(table)) {\n    // Handle error\n} else {\n    memcpy(table, (uint8_t *)priv->smu_tables.entry[table_id].table, size);\n}\n```\n\nIn this code, we first check if the size of the source is larger than the size of the destination. If it is, we handle the error. Otherwise, we proceed with the `memcpy` operation.\n\n## Library Dependencies\n\nThe provided code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b3b76b79-43cd-4e15-a16d-34c80da9b0f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The problem arises when the size of the destination buffer is smaller than the source buffer. This can lead to buffer overflow, which is a serious security vulnerability as it can allow an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), whenever possible.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size;\nif (size <= sizeof(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table)) {\n    memcpy(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, table, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code example requires the `<cstring>` header file in C++.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3b44f226-cbfa-450a-bc35-47e0850f41a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (size <= sizeof(priv->smu_tables.entry[table_id].table)) {\n    memcpy(priv->smu_tables.entry[table_id].table, table, size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a8e6ede4-7d44-4ec9-8beb-f86e84d7eb1a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the given code:\n\n```cpp\nsize_t size = priv->smu_tables.entry[table_id].size;\nif (sizeof(table) >= size) {\n    memcpy(table, priv->smu_tables.entry[table_id].table, size);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eeb74c82-9dfb-415d-89fd-fad62d049cdd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vsnprintf`.\n\nThe `vsnprintf` function is a variant of `sprintf` that takes a maximum size parameter to prevent buffer overflows. However, it can still lead to vulnerabilities if not used correctly. For example, if the size argument is not correctly calculated, it can lead to buffer overflows. Also, like `sprintf`, `vsnprintf` can lead to format string vulnerabilities if the format string is not controlled or if user input is directly used as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `vsnprintf` and other similar functions if possible. Instead, use safer alternatives that are less prone to misuse, such as `snprintf`. Always control the format string and never use user input as the format string. Also, always correctly calculate the size argument to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `vsnprintf` with `snprintf` and ensure the size argument is correctly calculated. For example, if you have the following code:\n\n```cpp\nchar buffer[1024];\nvsnprintf(buffer, sizeof(buffer), format, args);\n```\n\nYou can replace it with:\n\n```cpp\nchar buffer[1024];\nsnprintf(buffer, sizeof(buffer), \"%s\", format);\n```\n\n## Library Dependencies\n\nThe `vsnprintf` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-a0452db4-d614-412e-b495-29b2d325ec82",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `stream_sub_state_cmd->config` is less than, equal to, or greater than the size of `context->bw_ctx.bw.dcn.fams2_stream_sub_params[i]`. To fix the potential vulnerability, you should ensure that the destination buffer is large enough to hold the copied data.\n\n```cpp\n// Ensure that the destination buffer is large enough\nassert(sizeof(stream_sub_state_cmd->config) >= sizeof(context->bw_ctx.bw.dcn.fams2_stream_sub_params[i]));\n\n// Then perform the memcpy operation\nmemcpy(&stream_sub_state_cmd->config,\n       &context->bw_ctx.bw.dcn.fams2_stream_sub_params[i],\n       sizeof(union dmub_cmd_fams2_config));\n```\n\n## Library Dependencies\n\nThe code example provided does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cbc27326-8960-40d8-8722-35acae4530b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer and the source buffer is checked using the `sizeof` operator before the `memcpy` function is called. This is a good practice, but it would be better to use a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&stream_base_cmd->config, sizeof(stream_base_cmd->config),\n         &context->bw_ctx.bw.dcn.fams2_stream_base_params[i], \n         sizeof(context->bw_ctx.bw.dcn.fams2_stream_base_params[i]));\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file should be included at the top of the file.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-00356fa8-7b8b-434f-bef5-e75af70f2949",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(metrics) >= sizeof(MetricsTable_t)) {\n    memcpy(metrics, smu_table->metrics_table, sizeof(MetricsTable_t));\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed for this code to execute.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2142910b-79ba-4c2c-b529-aebe4ec0b2b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, you should ensure that `global_cmd->config.global` is large enough to hold the data from `context->bw_ctx.bw.dcn.fams2_global_config`. If the sizes are not equal, you should resize `global_cmd->config.global` or limit the amount of data being copied.\n\n```cpp\n// Ensure the destination buffer is large enough\nassert(sizeof(global_cmd->config.global) >= sizeof(context->bw_ctx.bw.dcn.fams2_global_config));\n\n// Then perform the copy\nmemcpy(&global_cmd->config.global, &context->bw_ctx.bw.dcn.fams2_global_config, sizeof(struct dmub_cmd_fams2_global_config));\n```\n\n## Library Dependencies\n\nThe provided code snippet appears to be part of a larger program, and it's not clear what specific libraries it depends on. However, `memcpy` is part of the C standard library, so the program would at least need to include `<cstring>` or `<string.h>`.\n\n## Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## CWE\n\nThis vulnerability is related to [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e6d23402-8849-41ad-b717-21efb2ed6a9f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, it is not clear whether the size of `dc->ctx->dmub_srv->dmub->visual_confirm_color` is at least `sizeof(struct dmub_visual_confirm_color)`. If it is not, a buffer overflow could occur. To fix this, you should ensure that the destination buffer is large enough before calling `memcpy`.\n\n```cpp\nif (sizeof(dc->ctx->dmub_srv->dmub->visual_confirm_color) >= sizeof(struct dmub_visual_confirm_color)) {\n    memcpy(&dc->ctx->dmub_srv->dmub->visual_confirm_color,\n        &cmd.visual_confirm_color.visual_confirm_color_data,\n        sizeof(struct dmub_visual_confirm_color));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example appears to be part of a larger program, and it's not clear from the provided snippet what libraries are required. However, `memcpy` is part of the C standard library, so at a minimum, the program would need to `#include <cstring>`.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b3a91ac4-285d-4592-aeec-940678b2af75",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `cmd.query_feature_caps.query_feature_caps_data` to `dc_dmub_srv->dmub->feature_caps`. If the size of `cmd.query_feature_caps.query_feature_caps_data` is larger than `dc_dmub_srv->dmub->feature_caps`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet would be to add a check for the size of the source and destination buffers before the `memcpy` operation:\n\n```cpp\nif (sizeof(cmd.query_feature_caps.query_feature_caps_data) <= sizeof(struct dmub_feature_caps)) {\n    memcpy(&dc_dmub_srv->dmub->feature_caps,\n           &cmd.query_feature_caps.query_feature_caps_data,\n           sizeof(struct dmub_feature_caps));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly include any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` library would need to be included for the code to compile and run properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-34aa3d16-083a-493b-9c6e-28a809670466",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c2800b67-9f78-48e4-b47a-e252137b0103",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `dm_state->context` is larger than the size of `local_dc_state`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy`. If the source data is larger than the destination buffer, you should either increase the size of the destination buffer or reduce the size of the source data.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(dm_state->context) <= sizeof(struct dc_state)) {\n    memcpy(local_dc_state, dm_state->context, sizeof(struct dc_state));\n} else {\n    // Handle error: source data is too large\n}\n```\n\nIn this fix, we first check if the size of `dm_state->context` is less than or equal to the size of `local_dc_state`. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-703e2232-18e9-4a28-8d96-649d7d8281dc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-82480acc-0f24-4dd7-9f90-3524fe70e450",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e48aa6df-9400-4749-94df-a4468551bb2b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-d9696685-b567-4beb-95d4-4aa2c9f9853a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(buf, (void *)edid + start, len)`, if `len` is greater than the size of `buf`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution. Attackers can exploit this vulnerability to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the buffer and the size of the data before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (len <= sizeof(buf)) {\n    memcpy(buf, (void *)edid + start, len);\n} else {\n    // Handle error: data too large for buffer\n}\n```\n\nIn this fixed code, we first check if `len` is less than or equal to the size of `buf`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d054ac0b-8703-45a5-8e72-6b2e9669f85e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7d35a0a6-e39f-4b30-a566-0d2615121e7c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(buf, log_ctx->buf, log_ctx->buf->pos);\n```\n\nThe `memcpy` function is copying `log_ctx->pos` bytes from `log_ctx->buf` to `buf`. If `log_ctx->pos` is larger than the size of `buf`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(buf) >= log_ctx->pos) {\n    memcpy(buf, log_ctx->buf, log_ctx->pos);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fixed code, we first check if `buf` is large enough to hold `log_ctx->pos` bytes. If it is, we proceed with the `memcpy`. If not, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ebc6b782-4d14-4979-9977-707ff6d1a5f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory beyond the intended boundary, leading to a buffer overflow. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes a maximum length parameter and will not read beyond this limit.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(rd_buf)` with `strnlen(rd_buf, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of `rd_buf`.\n\n```cpp\n// Assuming MAX_LEN is defined and rd_buf is a char array\nsize_t len = strnlen(rd_buf, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-374a9bc9-b87f-417d-bb6f-68532e5804d4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `vsnprintf`.\n\nThe `vsnprintf` function is a variant of `sprintf` that takes a maximum size parameter to prevent buffer overflows. However, it can still lead to vulnerabilities if not used correctly. For example, if the size argument is not correctly calculated, it can lead to buffer overflows. Also, like `sprintf`, `vsnprintf` can lead to format string vulnerabilities if the format string is not controlled or if user input is directly used as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `vsnprintf` and other similar functions if possible. Instead, use safer alternatives that are less prone to misuse, such as `snprintf`. Always control the format string and never use user input as the format string. Also, always correctly calculate the size argument to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace `vsnprintf` with `snprintf` and ensure the size argument is correctly calculated. For example, if you have the following code:\n\n```cpp\nchar buffer[1024];\nvsnprintf(buffer, sizeof(buffer), format, args);\n```\n\nYou can replace it with:\n\n```cpp\nchar buffer[1024];\nsnprintf(buffer, sizeof(buffer), \"%s\", format);\n```\n\n## Library Dependencies\n\nThe `vsnprintf` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b1007c1d-6cfb-4924-960b-3785d951e0b4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. This function is used to calculate the length of a string, but it can lead to buffer overflow vulnerabilities if not used correctly. The `strlen` function counts the number of characters in a string up to, but not including, the null-terminating character. If the string does not have a null-terminating character, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow.\n\nIn the provided code snippet, `strlen(\"Preferred:  %d  0x%x  %d  \")`, there is no direct vulnerability as the string is a constant and well-terminated. However, if the string was replaced with a variable that could be manipulated by an attacker, it could lead to a vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this type of vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, there is no direct vulnerability. However, if the string was replaced with a variable, ensure it is null-terminated:\n\n```cpp\nchar str[] = \"Preferred:  %d  0x%x  %d  \";\nsize_t len = strlen(str);\n```\n\nOr use `strnlen`:\n\n```cpp\nchar str[] = \"Preferred:  %d  0x%x  %d  \";\nsize_t len = strnlen(str, sizeof(str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-6714608a-4d16-4b31-a5d3-b34393849847",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string does not have a null character, `strlen` will continue reading memory until it encounters one, which can lead to buffer overflows, memory corruption, and other security issues.\n\nIn the provided code snippet, `strlen(\"Reported:  %d  0x%x  %d  \")`, there is no direct vulnerability as the string is a constant and well-defined. However, if the string was replaced with a variable that could potentially not be null-terminated, it would pose a risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. If the length of the string is known at compile time, consider using `sizeof` instead of `strlen` to avoid potential issues. Additionally, consider using safer alternatives to `strlen` such as `strnlen` which takes a maximum length parameter and will not read past it.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is needed as the string is a constant and well-defined. However, if the string was a variable, a safer alternative would be:\n\n```cpp\nchar str[] = \"Reported:  %d  0x%x  %d  \";\nsize_t len = strnlen(str, sizeof(str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library (`<cstring>` in C++), so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2c6e58be-60b0-40ee-8f15-4441401bcc9a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string does not end with a null character, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"Verified:  %d  0x%x  %d  \")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was user input or from an untrusted source, it could lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate potential vulnerabilities with `strlen`, always ensure that strings are null-terminated. Avoid using `strlen` with user-supplied or untrusted strings. Consider using safer alternatives such as `strnlen` or `std::string::length` which are less prone to buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nIn this specific case, no fix is required as the string is a constant and properly null-terminated. However, if the string was from an untrusted source, you could use `strnlen` as follows:\n\n```cpp\n#include <string.h>\n\nsize_t len = strnlen(user_input, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are required for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-7ec87b89-2924-48cf-9b29-0c4ae3677d90",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` can continue reading past the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or even code execution.\n\nIn the provided code snippet, `strlen(\"Current:  %d  0x%x  %d  \")`, there is no direct vulnerability as the string is a constant and properly null-terminated. However, if the string was user input or from an untrusted source, it could potentially be a source of vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated. Avoid using `strlen` on strings from untrusted sources without validation. Consider using safer alternatives such as `strnlen`, which takes a maximum length parameter and will not read past this length.\n\n## Source Code Fix Recommendation\n\nIn this specific case, no fix is needed as the string is a constant and properly null-terminated. However, if the string was from an untrusted source, you could use `strnlen` as follows:\n\n```cpp\n#include <string.h>\n\nsize_t len = strnlen(user_input, MAX_LENGTH);\n```\n\nReplace `user_input` with the string you want to find the length of, and `MAX_LENGTH` with the maximum expected length of the string.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed for the provided code snippet.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-36a610c0-a50b-4fee-8b83-8b3451490050",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (p_notify->aux_reply.length <= sizeof(payload->data)) {\n    memcpy(payload->data, p_notify->aux_reply.data, p_notify->aux_reply.length);\n} else {\n    // Handle error: source data is too large for the destination buffer\n}\n```\n\nIn this fix, we first check if the size of the source data (`p_notify->aux_reply.length`) is less than or equal to the size of the destination buffer (`sizeof(payload->data)`). If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code example.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ace66e1c-fddc-4854-93bd-923e0b22c4ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the `length` of `data` is larger than the size of `input->payload`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution. Attackers can exploit this vulnerability to execute arbitrary code or to cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling the `memcpy` function.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include the size of the destination buffer as a parameter and can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (length <= sizeof(input->payload)) {\n    memcpy(input->payload, data, length);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the `length` of `data` is less than or equal to the size of `input->payload` before calling `memcpy`. If `length` is larger, we handle the error appropriately instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f6e85a01-50b6-4a44-a321-a4ef994c1efc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the source is larger than the destination. In the provided code snippet, `memcpy(&out->sb[i], &buf[4], 26)`, the function is copying 26 bytes of data from the source `buf[4]` to the destination `out->sb[i]`. If the size of `out->sb[i]` is less than 26 bytes, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source is larger than the destination, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(out->sb[i]) >= 26) {\n    memcpy(&out->sb[i], &buf[4], 26);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `out->sb[i]` is at least 26 bytes. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fc8de7d8-749b-4af3-8fec-34ccb41ae8da",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ programming arises when certain C standard library functions, which are known to be unsafe, are used in a way that can lead to security issues such as buffer overflows, data corruption, or undefined behavior. The `memmove` function, while safer than `memcpy` in overlapping memory scenarios, can still be misused if not properly handled, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the size and bounds of the data being moved to ensure it does not exceed the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer, higher-level abstractions or functions that perform bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect unsafe function usage and potential buffer overflows.\n4. **Code Review**: Regularly perform code reviews to catch unsafe practices and ensure adherence to secure coding standards.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risks associated with `memmove`, ensure that the destination buffer is large enough to hold the data being moved. Here is an example of how to safely use `memmove`:\n\n```cpp\n#include <cstring>  // Required for memmove\n#include <iostream>\n\nvoid safeMemmove(char* dest, const char* src, size_t count, size_t destSize) {\n    if (count <= destSize) {\n        memmove(dest, src, count);\n    } else {\n        std::cerr << \"Error: Buffer overflow detected!\" << std::endl;\n        // Handle error appropriately\n    }\n}\n\nint main() {\n    const size_t bufferSize = 10;\n    char buffer[bufferSize];\n    const char* data = \"Hello\";\n\n    safeMemmove(buffer, data, strlen(data) + 1, bufferSize);  // +1 for null terminator\n\n    std::cout << \"Buffer content: \" << buffer << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<cstring>`: For the `memmove` function.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-120: Buffer Copy without Checking Size of Input)](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-82fe45ba-4920-4edf-be80-0da290ec53cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy the content of `adev->bios` to `fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr`. If `adev->bios_size` is larger than the size of `fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr`, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `std::copy` from the `<algorithm>` library, which checks the size of the destination before copying. Here is how you can modify the code:\n\n```cpp\n#include <algorithm>\n\nstd::copy(adev->bios, adev->bios + adev->bios_size, fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<algorithm>` for `std::copy`\n- Any libraries required by the `fb_info`, `DMUB_WINDOW_3_VBIOS`, and `adev` objects.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5937bb56-4700-44cc-866d-3152ec96fdab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, then the data should be truncated or the buffer should be resized appropriately.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (fw_bss_data_size <= sizeof(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr)) {\n    memcpy(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr, fw_bss_data, fw_bss_data_size);\n} else {\n    // Handle error condition, e.g., by truncating data or resizing buffer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-53f80821-4017-4bbe-be84-835946764d3e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (sizeof(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr) >= fw_inst_const_size) {\n    memcpy(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, fw_inst_const, fw_inst_const_size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be available in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7036db69-02b9-4044-8ce5-71baf76d73e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nif (sizeof(adev->dm.dmub_notify) >= sizeof(struct dmub_notification)) {\n    memcpy(adev->dm.dmub_notify, notify, sizeof(struct dmub_notification));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest and most trusted resources for secure coding practices."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ee0421fa-819f-408f-af3f-b4ab98bc431e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying data from `crtc_ctx->roi` to `roi_cpy` without checking if the size of `crtc_ctx->roi` is larger than `roi_cpy`. This can lead to a buffer overflow vulnerability, which can cause the program to crash or allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(crtc_ctx->roi) <= sizeof(struct crc_window)) {\n    memcpy(roi_cpy, crtc_ctx->roi, sizeof(struct crc_window));\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `crtc_ctx->roi` is less than or equal to the size of `roi_cpy`. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3421b72b-97f6-41ed-afbf-06e2c3dd5c6e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes a size parameter for the destination buffer. This will prevent buffer overflow by ensuring that the destination buffer is large enough to hold the source data.\n\n```cpp\nmemcpy_s(crc_cpy, sizeof(struct crc_data), crtc_ctx->crc_info.crc, sizeof(struct crc_data));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e6f35a44-53a5-4e57-985a-53660a0c6550",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, the size of the destination buffer should be checked before calling `memcpy`. If the size of the source buffer is greater than the size of the destination buffer, then the copy operation should not be performed.\n\n```cpp\nif (sizeof(dm->secure_display_ctx.phy_id_mapping[idx].rad) >= sizeof(aconnector->mst_output_port->parent->rad)) {\n    memcpy(dm->secure_display_ctx.phy_id_mapping[idx].rad,\n           aconnector->mst_output_port->parent->rad, \n           sizeof(aconnector->mst_output_port->parent->rad));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided does not explicitly indicate any library dependencies. However, the `memcpy` function is part of the C Standard Library, so the `<cstring>` or `<string.h>` header file would need to be included.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible in the future."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e16d9b7d-ff82-45e1-947d-91d7f4ac0ca4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(buffer, srm + pos, count)`, if `count` is larger than the size of `buffer`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (count <= sizeof(buffer)) {\n    memcpy(buffer, srm + pos, count);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if `count` is less than or equal to the size of `buffer`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so the only library dependency for the provided code snippet is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-899e4a89-7e5a-454e-8be0-87597606c04e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `srm_size - pos` is larger than the size of `buffer`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t buffer_size = sizeof(buffer);\nsize_t copy_size = srm_size - pos;\n\nif (copy_size > buffer_size) {\n    // Handle error: data too large for buffer\n} else {\n    memcpy(buffer, srm + pos, copy_size);\n}\n```\n\nIn this fixed code, we first calculate the size of the buffer and the size of the data to be copied. We then check if the data is too large for the buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-42ed4649-7b00-46fd-a020-028bf5a8e2f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, as it can lead to unexpected behavior, crashes, and even code execution.\n\nIn the provided code snippet, `memcpy(work->srm, work->srm_temp, pos + count)`, there is no guarantee that `work->srm` can hold `pos + count` bytes. If `work->srm` is smaller than `pos + count`, this will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `memmove`, which also copies data from one location to another, but checks the size of the destination buffer to prevent buffer overflow. Here is how you can modify the code to use `memmove` instead:\n\n```cpp\nif (sizeof(work->srm) >= pos + count) {\n    memmove(work->srm, work->srm_temp, pos + count);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` and `memmove` functions are part of the C Standard Library, so you need to include the `<cstring>` header file in your code.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-88a12588-74e9-419e-ace0-7d10af9ca5e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the data being copied is larger than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, then the data should be truncated or the buffer should be resized appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (count <= sizeof(work->srm_temp) - pos) {\n    memcpy(work->srm_temp + pos, buffer, count);\n} else {\n    // Handle error: buffer is too small\n}\n```\n\nIn this code, we first check if the size of the data (`count`) is less than or equal to the size of the destination buffer (`sizeof(work->srm_temp) - pos`). If it is, then we proceed with the `memcpy`. If not, then we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b969c935-de3a-4203-a264-5479c87f72ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the source buffer, it can lead to a buffer overflow. This can cause a program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy the contents of `srm` into `hdcp_cmd->in_msg.hdcp_set_srm.srm_buf`. If `srm_size` is larger than the size of `hdcp_cmd->in_msg.hdcp_set_srm.srm_buf`, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source buffer. This can be done by checking the size of the source and destination buffers before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf) >= srm_size) {\n    memcpy(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, srm, srm_size);\n} else {\n    // Handle the error\n}\n```\n\nIn this fixed code, we first check if the size of `hdcp_cmd->in_msg.hdcp_set_srm.srm_buf` is greater than or equal to `srm_size`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `string.h`: This library contains the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-071545d7-4283-4822-938e-fb208b8d4fb2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is determined by `sizeof(uint64_t)`, which may be larger than the size of `new_mods`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(uint64_t);\nif (size <= sizeof(new_mods)) {\n    memcpy(new_mods, *mods, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied. Then, we check if this size is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in an appropriate manner.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e4633f17-e79d-4ca2-a774-50098f6f56e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause crashes, data corruption, or code execution.\n\nIn the provided code snippet, `memcpy(smu_table->hardcode_pptable, buf, size)`, if the `size` is greater than the size of `smu_table->hardcode_pptable`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (size <= sizeof(smu_table->hardcode_pptable)) {\n    memcpy(smu_table->hardcode_pptable, buf, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of the data being copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dc68a193-3608-45c8-9d28-307d51dfa63c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often referred to as \"Detected Vulnerability in C Function (memcpy)\".\n\nBuffer overflow can lead to various security issues such as data corruption, system crash, or even code execution. This can be exploited by attackers to execute arbitrary code or to cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use functions that check the size of the destination buffer such as `strncpy` or `memcpy_s` (in C11) instead of `memcpy`. Also, always ensure that the destination buffer is large enough to hold the data being copied.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` function:\n\n```cpp\nif (table_size <= sizeof(metrics_table)) {\n    memcpy_s(metrics_table, sizeof(metrics_table), smu_table->metrics_table, table_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-661f7bd4-e5d0-4f60-bb08-3944091822fa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions that do check the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (table_size <= sizeof(table_data)) {\n    memcpy(table_data, table->cpu_addr, table_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the destination buffer (`table_data`) is large enough to hold the data being copied. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ba84dd43-9289-495e-a3a1-eedc7dd7804c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling the `memcpy` function. If the source data is larger than the destination buffer, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (table_size <= sizeof(table->cpu_addr)) {\n    memcpy(table->cpu_addr, table_data, table_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the source data (`table_size`) is less than or equal to the size of the destination buffer (`sizeof(table->cpu_addr)`). If it is, we proceed with the `memcpy` operation. Otherwise, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your code:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8b24b94c-3d2f-4515-bec0-5221a314b226",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source buffer is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(hwmgr->hardcode_pp_table, buf, size)`, the `memcpy` function is copying the contents of `buf` into `hwmgr->hardcode_pp_table`. If the size of `buf` is larger than `hwmgr->hardcode_pp_table`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling the `memcpy` function.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of bytes to be copied. Here's how you can modify the code to use `strncpy`:\n\n```cpp\nstrncpy(hwmgr->hardcode_pp_table, buf, min(size, sizeof(hwmgr->hardcode_pp_table)));\n```\n\nIn this code, `min(size, sizeof(hwmgr->hardcode_pp_table))` ensures that the number of bytes copied does not exceed the size of the destination buffer.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so you need to include the `<cstring>` header file in your code.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9e782f13-deb5-4834-9c8b-804a1b8ef868",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming that can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(mgr->mst_primary->guid, &guid, 16)`, the function is copying 16 bytes from the memory location pointed to by `&guid` to the memory location pointed to by `mgr->mst_primary->guid`. If the destination buffer is smaller than 16 bytes, it will result in a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nAssuming `mgr->mst_primary->guid` is a character array of size 16, the code should be safe. However, to make it safer and more robust, you should add a size check before the `memcpy` call:\n\n```cpp\nif (sizeof(mgr->mst_primary->guid) >= 16) {\n    memcpy(mgr->mst_primary->guid, &guid, 16);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-7e7316d2-9d32-42d9-a76f-b9fbb66300bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                },
                "region": {
                  "startLine": 674,
                  "startColumn": 1,
                  "endLine": 674,
                  "endColumn": 116,
                  "charOffset": 24354,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24354,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_config, <size of in_out->optimized_display_config>,  in_out->base_display_config,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-48fe3ff9-78c9-4718-b899-66b25826b1df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                },
                "region": {
                  "startLine": 462,
                  "startColumn": 2,
                  "endLine": 462,
                  "endColumn": 95,
                  "charOffset": 14534,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14534,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_cfg, <size of in_out->optimized_display_cfg>,  in_out->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b5ba3b0c-1e23-4d89-80ff-aed5f0945e2f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 1,
                  "endLine": 393,
                  "endColumn": 48,
                  "charOffset": 12302,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12302,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_config, <size of in_out->optimized_display_config>, \n\t\t\tin_out->base_display_config, \n\t\t\tsizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-64da965d-12ce-445d-8993-9b62eb8b50ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/inc/dml2_debug.c"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 10,
                  "endLine": 20,
                  "endColumn": 17,
                  "charOffset": 313,
                  "charLength": 7,
                  "snippet": {
                    "text": "vprintf",
                    "rendered": {
                      "text": "vprintf",
                      "markdown": "`vprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a5236791-c130-4f4f-bc03-1b6309dc2791",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                },
                "region": {
                  "startLine": 616,
                  "startColumn": 1,
                  "endLine": 616,
                  "endColumn": 95,
                  "charOffset": 21012,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21012,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svp_expanded_display_cfg, <size of svp_expanded_display_cfg>,  &display_cfg->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a443e20-98ff-4267-af1d-cf3afdaf35aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 1,
                  "endLine": 577,
                  "endColumn": 60,
                  "charOffset": 18937,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(phantom, main, sizeof(struct dml2_stream_parameters)",
                    "rendered": {
                      "text": "memcpy(phantom, main, sizeof(struct dml2_stream_parameters)",
                      "markdown": "`memcpy(phantom, main, sizeof(struct dml2_stream_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18937,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(phantom, <size of phantom>,  main,  sizeof(struct dml2_stream_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc02232b-69ad-445a-aa7e-680ce26bd6b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 1153,
                  "startColumn": 3,
                  "endLine": 1153,
                  "endColumn": 78,
                  "charOffset": 50025,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                    "rendered": {
                      "text": "memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                      "markdown": "`memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50025,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml->ip_caps, <size of &dml->ip_caps>,  &in_out->ip_caps,  sizeof(struct dml2_ip_capabilities)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a262a299-348f-429b-a198-d6c284505227",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 1121,
                  "startColumn": 1,
                  "endLine": 1121,
                  "endColumn": 76,
                  "charOffset": 48694,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                    "rendered": {
                      "text": "memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                      "markdown": "`memcpy(&dml->ip_caps, &in_out->ip_caps, sizeof(struct dml2_ip_capabilities)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48694,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml->ip_caps, <size of &dml->ip_caps>,  &in_out->ip_caps,  sizeof(struct dml2_ip_capabilities)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a4284bb7-bacd-4a1c-b3dc-e37e6e2fcf93",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 1122,
                  "startColumn": 1,
                  "endLine": 1122,
                  "endColumn": 67,
                  "charOffset": 48773,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&dml->soc_bbox, &in_out->soc_bb, sizeof(struct dml2_soc_bb)",
                    "rendered": {
                      "text": "memcpy(&dml->soc_bbox, &in_out->soc_bb, sizeof(struct dml2_soc_bb)",
                      "markdown": "`memcpy(&dml->soc_bbox, &in_out->soc_bb, sizeof(struct dml2_soc_bb)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48773,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml->soc_bbox, <size of &dml->soc_bbox>,  &in_out->soc_bb,  sizeof(struct dml2_soc_bb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f25d5c77-1f8d-4e01-be1d-baff891c8759",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 974,
                  "startColumn": 2,
                  "endLine": 974,
                  "endColumn": 129,
                  "charOffset": 41133,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41133,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&l->base_display_config_with_meta, <size of &l->base_display_config_with_meta>,  &l->optimized_display_config_with_meta,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-80061067-e61e-4635-83fc-94d04d19e85c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 1,
                  "endLine": 590,
                  "endColumn": 59,
                  "charOffset": 19648,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(phantom, main, sizeof(struct dml2_plane_parameters)",
                    "rendered": {
                      "text": "memcpy(phantom, main, sizeof(struct dml2_plane_parameters)",
                      "markdown": "`memcpy(phantom, main, sizeof(struct dml2_plane_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19648,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(phantom, <size of phantom>,  main,  sizeof(struct dml2_plane_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28e7c552-f8b0-458b-ada4-7c6570d72bfa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 955,
                  "startColumn": 2,
                  "endLine": 955,
                  "endColumn": 129,
                  "charOffset": 40202,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40202,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&l->base_display_config_with_meta, <size of &l->base_display_config_with_meta>,  &l->optimized_display_config_with_meta,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-00a8cc0e-7f88-452e-a456-ac08d7c6e11a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 1,
                  "endLine": 910,
                  "endColumn": 128,
                  "charOffset": 37951,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37951,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&l->base_display_config_with_meta, <size of &l->base_display_config_with_meta>,  &l->optimized_display_config_with_meta,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e5bacf71-53c5-4a9c-aaa4-d04e6ebc54a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 2,
                  "endLine": 927,
                  "endColumn": 129,
                  "charOffset": 38868,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38868,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&l->base_display_config_with_meta, <size of &l->base_display_config_with_meta>,  &l->optimized_display_config_with_meta,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b1ad0b81-b7d6-4164-a530-74f0b5970a1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 883,
                  "startColumn": 2,
                  "endLine": 883,
                  "endColumn": 129,
                  "charOffset": 36843,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(&l->base_display_config_with_meta, &l->optimized_display_config_with_meta, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36843,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&l->base_display_config_with_meta, <size of &l->base_display_config_with_meta>,  &l->optimized_display_config_with_meta,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-48535670-639d-4f07-8f4e-b99af6c640e5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 838,
                  "startColumn": 1,
                  "endLine": 838,
                  "endColumn": 101,
                  "charOffset": 34370,
                  "charLength": 100,
                  "snippet": {
                    "text": "memcpy(&in_out->programming->display_config, in_out->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(&in_out->programming->display_config, in_out->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(&in_out->programming->display_config, in_out->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34370,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&in_out->programming->display_config, <size of &in_out->programming->display_config>,  in_out->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb8955af-c525-4d59-8243-3493b5ffbe89",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 722,
                  "startColumn": 3,
                  "endLine": 723,
                  "endColumn": 64,
                  "charOffset": 29850,
                  "charLength": 174,
                  "snippet": {
                    "text": "memcpy(params->allocations[i].global_mcache_ids_mall_plane1, params->allocations[i].global_mcache_ids_plane1,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane1)",
                    "rendered": {
                      "text": "memcpy(params->allocations[i].global_mcache_ids_mall_plane1, params->allocations[i].global_mcache_ids_plane1,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane1)",
                      "markdown": "`memcpy(params->allocations[i].global_mcache_ids_mall_plane1, params->allocations[i].global_mcache_ids_plane1,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29850,
                        "charLength": 174
                      },
                      "insertedContent": {
                        "text": "memcpy_s(params->allocations[i].global_mcache_ids_mall_plane1, <size of params->allocations[i].global_mcache_ids_mall_plane1>,  params->allocations[i].global_mcache_ids_plane1, \n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c913294c-388a-44ff-966d-d57460becc82",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 720,
                  "startColumn": 3,
                  "endLine": 721,
                  "endColumn": 64,
                  "charOffset": 29670,
                  "charLength": 174,
                  "snippet": {
                    "text": "memcpy(params->allocations[i].global_mcache_ids_mall_plane0, params->allocations[i].global_mcache_ids_plane0,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane0)",
                    "rendered": {
                      "text": "memcpy(params->allocations[i].global_mcache_ids_mall_plane0, params->allocations[i].global_mcache_ids_plane0,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane0)",
                      "markdown": "`memcpy(params->allocations[i].global_mcache_ids_mall_plane0, params->allocations[i].global_mcache_ids_plane0,\n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane0)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29670,
                        "charLength": 174
                      },
                      "insertedContent": {
                        "text": "memcpy_s(params->allocations[i].global_mcache_ids_mall_plane0, <size of params->allocations[i].global_mcache_ids_mall_plane0>,  params->allocations[i].global_mcache_ids_plane0, \n\t\t\t\tsizeof(params->allocations[i].global_mcache_ids_mall_plane0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-64828990-6d17-4554-9afb-8e4c14c4be55",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 2,
                  "endLine": 85,
                  "endColumn": 141,
                  "charOffset": 3833,
                  "charLength": 139,
                  "snippet": {
                    "text": "memcpy(params->display_config->stage2.per_plane_mcache_support, l->test_mcache.validate_admissibility_params.per_plane_status, sizeof(bool)",
                    "rendered": {
                      "text": "memcpy(params->display_config->stage2.per_plane_mcache_support, l->test_mcache.validate_admissibility_params.per_plane_status, sizeof(bool)",
                      "markdown": "`memcpy(params->display_config->stage2.per_plane_mcache_support, l->test_mcache.validate_admissibility_params.per_plane_status, sizeof(bool)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3833,
                        "charLength": 139
                      },
                      "insertedContent": {
                        "text": "memcpy_s(params->display_config->stage2.per_plane_mcache_support, <size of params->display_config->stage2.per_plane_mcache_support>,  l->test_mcache.validate_admissibility_params.per_plane_status,  sizeof(bool)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f52da1fa-a129-4683-a4eb-fc1b88c346de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 1,
                  "endLine": 26,
                  "endColumn": 63,
                  "charOffset": 1150,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(dst, src, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(dst, src, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(dst, src, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1150,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a2c1db31-0e5a-43ac-ac9f-d95705827b6a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 1,
                  "endLine": 14,
                  "endColumn": 77,
                  "charOffset": 467,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 467,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out->display_config, <size of &out->display_config>,  display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c89b05c3-3de0-41f4-981e-251f31f0f8fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 20,
                  "endColumn": 77,
                  "charOffset": 878,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(&out->display_config, display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_top/dml2_top_soc15.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 878,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out->display_config, <size of &out->display_config>,  display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5d58065a-bf1e-4607-8d1c-cf86cba4a171",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 2355,
                  "startColumn": 1,
                  "endLine": 2355,
                  "endColumn": 116,
                  "charOffset": 93125,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 93125,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_config, <size of in_out->optimized_display_config>,  in_out->base_display_config,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-930c9b68-303e-4461-a78b-c97cf648370a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 2234,
                  "startColumn": 1,
                  "endLine": 2234,
                  "endColumn": 116,
                  "charOffset": 88036,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(in_out->optimized_display_config, in_out->base_display_config, sizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 88036,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_config, <size of in_out->optimized_display_config>,  in_out->base_display_config,  sizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-96d93bfa-bec6-475e-9b93-c0ae0d1e40bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 2022,
                  "startColumn": 2,
                  "endLine": 2024,
                  "endColumn": 40,
                  "charOffset": 77683,
                  "charLength": 155,
                  "snippet": {
                    "text": "memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)",
                    "rendered": {
                      "text": "memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)",
                      "markdown": "`memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77683,
                        "charLength": 155
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&display_config->stage3.stream_svp_meta[stream_index], <size of &display_config->stage3.stream_svp_meta[stream_index]>, \n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index], \n\t\t\tsizeof(struct dml2_implicit_svp_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17126a98-da0f-4ee0-9a35-2469f58106b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 2147,
                  "startColumn": 2,
                  "endLine": 2149,
                  "endColumn": 33,
                  "charOffset": 83617,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(&display_config->stage3.stream_fams2_meta,\n\t\t\t&scratch->pmo_dcn4.stream_fams2_meta,\n\t\t\tsizeof(struct dml2_fams2_meta)",
                    "rendered": {
                      "text": "memcpy(&display_config->stage3.stream_fams2_meta,\n\t\t\t&scratch->pmo_dcn4.stream_fams2_meta,\n\t\t\tsizeof(struct dml2_fams2_meta)",
                      "markdown": "`memcpy(&display_config->stage3.stream_fams2_meta,\n\t\t\t&scratch->pmo_dcn4.stream_fams2_meta,\n\t\t\tsizeof(struct dml2_fams2_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 83617,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&display_config->stage3.stream_fams2_meta, <size of &display_config->stage3.stream_fams2_meta>, \n\t\t\t&scratch->pmo_dcn4.stream_fams2_meta, \n\t\t\tsizeof(struct dml2_fams2_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-38ad753d-6092-4e10-a931-25c0154e0d57",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 1999,
                  "startColumn": 2,
                  "endLine": 2001,
                  "endColumn": 40,
                  "charOffset": 76882,
                  "charLength": 155,
                  "snippet": {
                    "text": "memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)",
                    "rendered": {
                      "text": "memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)",
                      "markdown": "`memcpy(&display_config->stage3.stream_svp_meta[stream_index],\n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index],\n\t\t\tsizeof(struct dml2_implicit_svp_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76882,
                        "charLength": 155
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&display_config->stage3.stream_svp_meta[stream_index], <size of &display_config->stage3.stream_svp_meta[stream_index]>, \n\t\t\t&scratch->pmo_dcn4.stream_svp_meta[stream_index], \n\t\t\tsizeof(struct dml2_implicit_svp_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c3e6fef-2433-4e9d-99fd-f73801718060",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 1,
                  "endLine": 859,
                  "endColumn": 48,
                  "charOffset": 29103,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)",
                      "markdown": "`memcpy(in_out->optimized_display_config,\n\t\t\tin_out->base_display_config,\n\t\t\tsizeof(struct display_configuation_with_meta)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29103,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_config, <size of in_out->optimized_display_config>, \n\t\t\tin_out->base_display_config, \n\t\t\tsizeof(struct display_configuation_with_meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c606048d-af4c-4bab-95d0-10be435c6a6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 567,
                  "startColumn": 1,
                  "endLine": 567,
                  "endColumn": 81,
                  "charOffset": 18874,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&variant_strategy, base_strategy, sizeof(struct dml2_pmo_pstate_strategy)",
                    "rendered": {
                      "text": "memcpy(&variant_strategy, base_strategy, sizeof(struct dml2_pmo_pstate_strategy)",
                      "markdown": "`memcpy(&variant_strategy, base_strategy, sizeof(struct dml2_pmo_pstate_strategy)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18874,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&variant_strategy, <size of &variant_strategy>,  base_strategy,  sizeof(struct dml2_pmo_pstate_strategy)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ffd84251-702a-480e-a654-e72b337e3b43",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 565,
                  "startColumn": 1,
                  "endLine": 565,
                  "endColumn": 81,
                  "charOffset": 18765,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(num_streams_per_base_method, num_streams_per_method, sizeof(unsigned int)",
                    "rendered": {
                      "text": "memcpy(num_streams_per_base_method, num_streams_per_method, sizeof(unsigned int)",
                      "markdown": "`memcpy(num_streams_per_base_method, num_streams_per_method, sizeof(unsigned int)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18765,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(num_streams_per_base_method, <size of num_streams_per_base_method>,  num_streams_per_method,  sizeof(unsigned int)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c0bd394-0fae-47d3-baa3-bd3c33a50d5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 2,
                  "endLine": 296,
                  "endColumn": 95,
                  "charOffset": 9421,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(in_out->optimized_display_cfg, in_out->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9421,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(in_out->optimized_display_cfg, <size of in_out->optimized_display_cfg>,  in_out->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ddfecf4a-0b07-4eb2-af86-46672a7511bc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                },
                "region": {
                  "startLine": 428,
                  "startColumn": 2,
                  "endLine": 428,
                  "endColumn": 127,
                  "charOffset": 13983,
                  "charLength": 125,
                  "snippet": {
                    "text": "memcpy(&expanded_strategy_list[*num_expanded_strategies], per_stream_pstate_strategy, sizeof(struct dml2_pmo_pstate_strategy)",
                    "rendered": {
                      "text": "memcpy(&expanded_strategy_list[*num_expanded_strategies], per_stream_pstate_strategy, sizeof(struct dml2_pmo_pstate_strategy)",
                      "markdown": "`memcpy(&expanded_strategy_list[*num_expanded_strategies], per_stream_pstate_strategy, sizeof(struct dml2_pmo_pstate_strategy)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_pmo/dml2_pmo_dcn4_fams2.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13983,
                        "charLength": 125
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&expanded_strategy_list[*num_expanded_strategies], <size of &expanded_strategy_list[*num_expanded_strategies]>,  per_stream_pstate_strategy,  sizeof(struct dml2_pmo_pstate_strategy)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-68c7f283-0baa-4e83-8de4-72b48187a62c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 599,
                  "startColumn": 4,
                  "endLine": 601,
                  "endColumn": 50,
                  "charOffset": 33677,
                  "charLength": 196,
                  "snippet": {
                    "text": "memcpy(&in_out->programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t\t\t&in_out->display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                    "rendered": {
                      "text": "memcpy(&in_out->programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t\t\t&in_out->display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                      "markdown": "`memcpy(&in_out->programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t\t\t&in_out->display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33677,
                        "charLength": 196
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&in_out->programming->plane_programming[plane_index].mcache_allocation, <size of &in_out->programming->plane_programming[plane_index].mcache_allocation>, \n\t\t\t\t\t&in_out->display_cfg->stage2.mcache_allocations[plane_index], \n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-34538d93-1e01-4792-b18e-aa4ae98d8e6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 572,
                  "startColumn": 3,
                  "endLine": 572,
                  "endColumn": 100,
                  "charOffset": 31358,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy(&in_out->programming->display_config, in_out->display_cfg, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(&in_out->programming->display_config, in_out->display_cfg, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(&in_out->programming->display_config, in_out->display_cfg, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31358,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&in_out->programming->display_config, <size of &in_out->programming->display_config>,  in_out->display_cfg,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee197b29-af0a-4e14-98a1-6d089c23a002",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 376,
                  "startColumn": 2,
                  "endLine": 378,
                  "endColumn": 48,
                  "charOffset": 18889,
                  "charLength": 210,
                  "snippet": {
                    "text": "memcpy(&programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation,\n\t\t\t&programming->plane_programming[main_plane_index].mcache_allocation,\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                    "rendered": {
                      "text": "memcpy(&programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation,\n\t\t\t&programming->plane_programming[main_plane_index].mcache_allocation,\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                      "markdown": "`memcpy(&programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation,\n\t\t\t&programming->plane_programming[main_plane_index].mcache_allocation,\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18889,
                        "charLength": 210
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation, <size of &programming->plane_programming[main_plane_index].phantom_plane.mcache_allocation>, \n\t\t\t&programming->plane_programming[main_plane_index].mcache_allocation, \n\t\t\tsizeof(struct dml2_mcache_surface_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bcd7fd2b-d62b-4d65-a4ff-50cab4197a5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 371,
                  "startColumn": 2,
                  "endLine": 371,
                  "endColumn": 136,
                  "charOffset": 18430,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(&programming->plane_programming[main_plane_index].phantom_plane.descriptor, phantom_plane, sizeof(struct dml2_plane_parameters)",
                    "rendered": {
                      "text": "memcpy(&programming->plane_programming[main_plane_index].phantom_plane.descriptor, phantom_plane, sizeof(struct dml2_plane_parameters)",
                      "markdown": "`memcpy(&programming->plane_programming[main_plane_index].phantom_plane.descriptor, phantom_plane, sizeof(struct dml2_plane_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18430,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&programming->plane_programming[main_plane_index].phantom_plane.descriptor, <size of &programming->plane_programming[main_plane_index].phantom_plane.descriptor>,  phantom_plane,  sizeof(struct dml2_plane_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aa0b1438-f25e-4eab-960a-abb52c708b09",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 2,
                  "endLine": 331,
                  "endColumn": 48,
                  "charOffset": 15795,
                  "charLength": 176,
                  "snippet": {
                    "text": "memcpy(&programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t&display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                    "rendered": {
                      "text": "memcpy(&programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t&display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                      "markdown": "`memcpy(&programming->plane_programming[plane_index].mcache_allocation,\n\t\t\t&display_cfg->stage2.mcache_allocations[plane_index],\n\t\t\tsizeof(struct dml2_mcache_surface_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15795,
                        "charLength": 176
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&programming->plane_programming[plane_index].mcache_allocation, <size of &programming->plane_programming[plane_index].mcache_allocation>, \n\t\t\t&display_cfg->stage2.mcache_allocations[plane_index], \n\t\t\tsizeof(struct dml2_mcache_surface_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-364113a8-6b44-4166-a7b3-5271f2a134e3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 3,
                  "endLine": 297,
                  "endColumn": 137,
                  "charOffset": 14294,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(&programming->stream_programming[stream_index].phantom_stream.descriptor, phantom_stream, sizeof(struct dml2_stream_parameters)",
                    "rendered": {
                      "text": "memcpy(&programming->stream_programming[stream_index].phantom_stream.descriptor, phantom_stream, sizeof(struct dml2_stream_parameters)",
                      "markdown": "`memcpy(&programming->stream_programming[stream_index].phantom_stream.descriptor, phantom_stream, sizeof(struct dml2_stream_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14294,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&programming->stream_programming[stream_index].phantom_stream.descriptor, <size of &programming->stream_programming[stream_index].phantom_stream.descriptor>,  phantom_stream,  sizeof(struct dml2_stream_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-13ac954b-4518-4f67-854b-57e91db79964",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 1,
                  "endLine": 267,
                  "endColumn": 99,
                  "charOffset": 12468,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(&programming->display_config, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(&programming->display_config, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(&programming->display_config, &display_cfg->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12468,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&programming->display_config, <size of &programming->display_config>,  &display_cfg->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef8a0037-3608-42a0-979d-c3131901301e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 1,
                  "endLine": 198,
                  "endColumn": 95,
                  "charOffset": 8649,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                    "rendered": {
                      "text": "memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)",
                      "markdown": "`memcpy(svp_expanded_display_cfg, &display_cfg->display_config, sizeof(struct dml2_display_cfg)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8649,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(svp_expanded_display_cfg, <size of svp_expanded_display_cfg>,  &display_cfg->display_config,  sizeof(struct dml2_display_cfg)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-511d0da6-de47-499d-a089-0b3f0b9b1513",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 1,
                  "endLine": 172,
                  "endColumn": 59,
                  "charOffset": 7294,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(phantom, main, sizeof(struct dml2_plane_parameters)",
                    "rendered": {
                      "text": "memcpy(phantom, main, sizeof(struct dml2_plane_parameters)",
                      "markdown": "`memcpy(phantom, main, sizeof(struct dml2_plane_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7294,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(phantom, <size of phantom>,  main,  sizeof(struct dml2_plane_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76883674-5116-4edf-86de-e649de7adb89",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 60,
                  "charOffset": 6583,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(phantom, main, sizeof(struct dml2_stream_parameters)",
                    "rendered": {
                      "text": "memcpy(phantom, main, sizeof(struct dml2_stream_parameters)",
                      "markdown": "`memcpy(phantom, main, sizeof(struct dml2_stream_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6583,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(phantom, <size of phantom>,  main,  sizeof(struct dml2_stream_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1609de2d-75d0-4e0e-96cb-bfbbfc7b52e5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 1,
                  "endLine": 150,
                  "endColumn": 83,
                  "charOffset": 6199,
                  "charLength": 82,
                  "snippet": {
                    "text": "memcpy(&core->clean_me_up.mode_lib.soc, in_out->soc_bb, sizeof(struct dml2_soc_bb)",
                    "rendered": {
                      "text": "memcpy(&core->clean_me_up.mode_lib.soc, in_out->soc_bb, sizeof(struct dml2_soc_bb)",
                      "markdown": "`memcpy(&core->clean_me_up.mode_lib.soc, in_out->soc_bb, sizeof(struct dml2_soc_bb)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6199,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&core->clean_me_up.mode_lib.soc, <size of &core->clean_me_up.mode_lib.soc>,  in_out->soc_bb,  sizeof(struct dml2_soc_bb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c1664db8-fdf7-41d2-bb54-9680de012bb8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 1,
                  "endLine": 151,
                  "endColumn": 97,
                  "charOffset": 6285,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(&core->clean_me_up.mode_lib.ip_caps, in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                    "rendered": {
                      "text": "memcpy(&core->clean_me_up.mode_lib.ip_caps, in_out->ip_caps, sizeof(struct dml2_ip_capabilities)",
                      "markdown": "`memcpy(&core->clean_me_up.mode_lib.ip_caps, in_out->ip_caps, sizeof(struct dml2_ip_capabilities)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6285,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&core->clean_me_up.mode_lib.ip_caps, <size of &core->clean_me_up.mode_lib.ip_caps>,  in_out->ip_caps,  sizeof(struct dml2_ip_capabilities)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d580193-7236-4ea8-bf7e-f2fd66b3d250",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 3,
                  "endLine": 144,
                  "endColumn": 101,
                  "charOffset": 5954,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(&core->clean_me_up.mode_lib.ip, &core_dcn4_ip_caps_base, sizeof(struct dml2_core_ip_params)",
                    "rendered": {
                      "text": "memcpy(&core->clean_me_up.mode_lib.ip, &core_dcn4_ip_caps_base, sizeof(struct dml2_core_ip_params)",
                      "markdown": "`memcpy(&core->clean_me_up.mode_lib.ip, &core_dcn4_ip_caps_base, sizeof(struct dml2_core_ip_params)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5954,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&core->clean_me_up.mode_lib.ip, <size of &core->clean_me_up.mode_lib.ip>,  &core_dcn4_ip_caps_base,  sizeof(struct dml2_core_ip_params)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0f7db18d-d81d-406b-974d-91fccc9023a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 2,
                  "endLine": 134,
                  "endColumn": 93,
                  "charOffset": 5219,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&core->clean_me_up.mode_lib.ip, in_out->explicit_ip_bb, in_out->explicit_ip_bb_size)",
                    "rendered": {
                      "text": "memcpy(&core->clean_me_up.mode_lib.ip, in_out->explicit_ip_bb, in_out->explicit_ip_bb_size)",
                      "markdown": "`memcpy(&core->clean_me_up.mode_lib.ip, in_out->explicit_ip_bb, in_out->explicit_ip_bb_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5219,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&core->clean_me_up.mode_lib.ip, <size of &core->clean_me_up.mode_lib.ip>,  in_out->explicit_ip_bb,  in_out->explicit_ip_bb_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b09e340e-a31c-49f7-ac04-60f954327144",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                },
                "region": {
                  "startLine": 1819,
                  "startColumn": 1,
                  "endLine": 1819,
                  "endColumn": 8,
                  "charOffset": 57846,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-33e43961-bff7-4fc8-a42b-f6d2406921cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                },
                "region": {
                  "startLine": 1805,
                  "startColumn": 1,
                  "endLine": 1805,
                  "endColumn": 8,
                  "charOffset": 57546,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3913f997-e720-458d-bbb1-32167ed402b2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                },
                "region": {
                  "startLine": 1682,
                  "startColumn": 5,
                  "endLine": 1682,
                  "endColumn": 54,
                  "charOffset": 53808,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(dpcd_data, ext_cap_data, sizeof(dpcd_data)",
                    "rendered": {
                      "text": "memcpy(dpcd_data, ext_cap_data, sizeof(dpcd_data)",
                      "markdown": "`memcpy(dpcd_data, ext_cap_data, sizeof(dpcd_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53808,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dpcd_data, <size of dpcd_data>,  ext_cap_data,  sizeof(dpcd_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c2c80c2d-bc6c-4040-9be2-299f8a6caef8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                },
                "region": {
                  "startLine": 1207,
                  "startColumn": 2,
                  "endLine": 1207,
                  "endColumn": 9,
                  "charOffset": 37592,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c45927d2-3bd8-478c-b41d-6c738761fbc8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_capability.c"
                },
                "region": {
                  "startLine": 1028,
                  "startColumn": 1,
                  "endLine": 1028,
                  "endColumn": 8,
                  "charOffset": 31619,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4501ee4-221a-4c63-bdca-6ee655b2383f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn351/dcn351_fpu.c"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 1,
                  "endLine": 348,
                  "endColumn": 34,
                  "charOffset": 10843,
                  "charLength": 81,
                  "snippet": {
                    "text": "memcpy(dcn3_51_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_51_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(dcn3_51_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_51_soc.clock_limits)",
                      "markdown": "`memcpy(dcn3_51_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_51_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn351/dcn351_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10843,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dcn3_51_soc.clock_limits, <size of dcn3_51_soc.clock_limits>,  clock_limits, \n\t\tsizeof(dcn3_51_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c3e26378-de1c-4cf2-85b5-1a808827c74d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c"
                },
                "region": {
                  "startLine": 1988,
                  "startColumn": 6,
                  "endLine": 1988,
                  "endColumn": 117,
                  "charOffset": 77687,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(&pipe->bottom_pipe->stream_res, &pipe->bottom_pipe->top_pipe->stream_res, sizeof(struct stream_resource)",
                    "rendered": {
                      "text": "memcpy(&pipe->bottom_pipe->stream_res, &pipe->bottom_pipe->top_pipe->stream_res, sizeof(struct stream_resource)",
                      "markdown": "`memcpy(&pipe->bottom_pipe->stream_res, &pipe->bottom_pipe->top_pipe->stream_res, sizeof(struct stream_resource)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77687,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pipe->bottom_pipe->stream_res, <size of &pipe->bottom_pipe->stream_res>,  &pipe->bottom_pipe->top_pipe->stream_res,  sizeof(struct stream_resource)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6a8a0599-27e8-4a81-8db9-f6251926690f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_training.c"
                },
                "region": {
                  "startLine": 1271,
                  "startColumn": 1,
                  "endLine": 1271,
                  "endColumn": 8,
                  "charOffset": 39222,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7bbff306-59ab-414d-aebb-83de26152ebf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dp_phy.c"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 1,
                  "endLine": 117,
                  "endColumn": 8,
                  "charOffset": 3923,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5e298b9d-5e6a-4e3c-ba03-3e50f16029a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 1,
                  "endLine": 193,
                  "endColumn": 59,
                  "charOffset": 7205,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(&extended_data[offset], reduced_data, reduced_size)",
                    "rendered": {
                      "text": "memcpy(&extended_data[offset], reduced_data, reduced_size)",
                      "markdown": "`memcpy(&extended_data[offset], reduced_data, reduced_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7205,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&extended_data[offset], <size of &extended_data[offset]>,  reduced_data,  reduced_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6976515-d558-4260-8db6-9691ec0a2e16",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                },
                "region": {
                  "startLine": 794,
                  "startColumn": 1,
                  "endLine": 794,
                  "endColumn": 69,
                  "charOffset": 29719,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(dcn3_16_soc.clock_limits, s, sizeof(dcn3_16_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(dcn3_16_soc.clock_limits, s, sizeof(dcn3_16_soc.clock_limits)",
                      "markdown": "`memcpy(dcn3_16_soc.clock_limits, s, sizeof(dcn3_16_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29719,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dcn3_16_soc.clock_limits, <size of dcn3_16_soc.clock_limits>,  s,  sizeof(dcn3_16_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4fc61bf8-1b73-41b6-9b11-a7722df6283b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn35/dcn35_fpu.c"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 33,
                  "charOffset": 10513,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(dcn3_5_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_5_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(dcn3_5_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_5_soc.clock_limits)",
                      "markdown": "`memcpy(dcn3_5_soc.clock_limits, clock_limits,\n\t\tsizeof(dcn3_5_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn35/dcn35_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10513,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dcn3_5_soc.clock_limits, <size of dcn3_5_soc.clock_limits>,  clock_limits, \n\t\tsizeof(dcn3_5_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-984b5684-3dd0-44e5-85cf-da1d7972fd64",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                },
                "region": {
                  "startLine": 739,
                  "startColumn": 1,
                  "endLine": 739,
                  "endColumn": 69,
                  "charOffset": 27632,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(s, dcn3_16_soc.clock_limits, sizeof(dcn3_16_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(s, dcn3_16_soc.clock_limits, sizeof(dcn3_16_soc.clock_limits)",
                      "markdown": "`memcpy(s, dcn3_16_soc.clock_limits, sizeof(dcn3_16_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27632,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(s, <size of s>,  dcn3_16_soc.clock_limits,  sizeof(dcn3_16_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e951bfa5-0533-4dc8-8041-a7aa224f5048",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                },
                "region": {
                  "startLine": 654,
                  "startColumn": 1,
                  "endLine": 654,
                  "endColumn": 67,
                  "charOffset": 24132,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(dcn3_1_soc.clock_limits, s, sizeof(dcn3_1_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(dcn3_1_soc.clock_limits, s, sizeof(dcn3_1_soc.clock_limits)",
                      "markdown": "`memcpy(dcn3_1_soc.clock_limits, s, sizeof(dcn3_1_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24132,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dcn3_1_soc.clock_limits, <size of dcn3_1_soc.clock_limits>,  s,  sizeof(dcn3_1_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4b3cdd5b-04b0-46b8-a22c-965a976db723",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 1,
                  "endLine": 600,
                  "endColumn": 67,
                  "charOffset": 22067,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(s, dcn3_1_soc.clock_limits, sizeof(dcn3_1_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(s, dcn3_1_soc.clock_limits, sizeof(dcn3_1_soc.clock_limits)",
                      "markdown": "`memcpy(s, dcn3_1_soc.clock_limits, sizeof(dcn3_1_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn31/dcn31_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22067,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(s, <size of s>,  dcn3_1_soc.clock_limits,  sizeof(dcn3_1_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf6e3c1a-5986-4262-9cdd-0b5a2f9dc0cf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                },
                "region": {
                  "startLine": 2452,
                  "startColumn": 1,
                  "endLine": 2452,
                  "endColumn": 68,
                  "charOffset": 85607,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(&dcn2_1_soc.clock_limits, s, sizeof(dcn2_1_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(&dcn2_1_soc.clock_limits, s, sizeof(dcn2_1_soc.clock_limits)",
                      "markdown": "`memcpy(&dcn2_1_soc.clock_limits, s, sizeof(dcn2_1_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85607,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dcn2_1_soc.clock_limits, <size of &dcn2_1_soc.clock_limits>,  s,  sizeof(dcn2_1_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f78e8c80-4a0a-41b2-92ca-37f9e9c8ce11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                },
                "region": {
                  "startLine": 2419,
                  "startColumn": 1,
                  "endLine": 2419,
                  "endColumn": 67,
                  "charOffset": 84341,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(s, dcn2_1_soc.clock_limits, sizeof(dcn2_1_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(s, dcn2_1_soc.clock_limits, sizeof(dcn2_1_soc.clock_limits)",
                      "markdown": "`memcpy(s, dcn2_1_soc.clock_limits, sizeof(dcn2_1_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84341,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(s, <size of s>,  dcn2_1_soc.clock_limits,  sizeof(dcn2_1_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a664f068-893c-46ee-afda-bf2f8acbc25e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                },
                "region": {
                  "startLine": 1910,
                  "startColumn": 1,
                  "endLine": 1910,
                  "endColumn": 138,
                  "charOffset": 66552,
                  "charLength": 137,
                  "snippet": {
                    "text": "memcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st)",
                    "rendered": {
                      "text": "memcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st)",
                      "markdown": "`memcpy(&bb->clock_limits[num_calculated_states], &bb->clock_limits[num_calculated_states - 1], sizeof(struct _vcs_dpi_voltage_scaling_st)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn20/dcn20_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66552,
                        "charLength": 137
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&bb->clock_limits[num_calculated_states], <size of &bb->clock_limits[num_calculated_states]>,  &bb->clock_limits[num_calculated_states - 1],  sizeof(struct _vcs_dpi_voltage_scaling_st)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d5584a3-85ae-4110-99b0-b9d3a32ecfb3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 1,
                  "endLine": 107,
                  "endColumn": 45,
                  "charOffset": 3046,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(qps, table[index].qps, sizeof(qp_set)",
                    "rendered": {
                      "text": "memcpy(qps, table[index].qps, sizeof(qp_set)",
                      "markdown": "`memcpy(qps, table[index].qps, sizeof(qp_set)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dsc/rc_calc_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3046,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(qps, <size of qps>,  table[index].qps,  sizeof(qp_set)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-41805cb0-0007-42c8-84d0-4795d51c8435",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/hpo/dcn31/dcn31_hpo_dp_stream_encoder.c"
                },
                "region": {
                  "startLine": 571,
                  "startColumn": 3,
                  "endLine": 571,
                  "endColumn": 50,
                  "charOffset": 19197,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)",
                    "rendered": {
                      "text": "memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)",
                      "markdown": "`memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/hpo/dcn31/dcn31_hpo_dp_stream_encoder.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19197,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pps_sdp.sb, <size of pps_sdp.sb>,  &dsc_packed_pps[i * 32],  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7bf7180c-d7fa-473a-bf20-c97b29cfedcd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn301/dcn301_fpu.c"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 1,
                  "endLine": 333,
                  "endColumn": 69,
                  "charOffset": 10310,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(s, dcn3_01_soc.clock_limits, sizeof(dcn3_01_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(s, dcn3_01_soc.clock_limits, sizeof(dcn3_01_soc.clock_limits)",
                      "markdown": "`memcpy(s, dcn3_01_soc.clock_limits, sizeof(dcn3_01_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn301/dcn301_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10310,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(s, <size of s>,  dcn3_01_soc.clock_limits,  sizeof(dcn3_01_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-107ebb80-9e1b-42ca-975a-a7f4fd117752",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn301/dcn301_fpu.c"
                },
                "region": {
                  "startLine": 375,
                  "startColumn": 1,
                  "endLine": 375,
                  "endColumn": 69,
                  "charOffset": 12021,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(dcn3_01_soc.clock_limits, s, sizeof(dcn3_01_soc.clock_limits)",
                    "rendered": {
                      "text": "memcpy(dcn3_01_soc.clock_limits, s, sizeof(dcn3_01_soc.clock_limits)",
                      "markdown": "`memcpy(dcn3_01_soc.clock_limits, s, sizeof(dcn3_01_soc.clock_limits)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/dcn301/dcn301_fpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12021,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dcn3_01_soc.clock_limits, <size of dcn3_01_soc.clock_limits>,  s,  sizeof(dcn3_01_soc.clock_limits)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ed278d9-88f1-49ee-9c78-4d70ade2a3f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 2027,
                  "startColumn": 1,
                  "endLine": 2027,
                  "endColumn": 61,
                  "charOffset": 54734,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                    "rendered": {
                      "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                      "markdown": "`memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54734,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dml2_opt, <size of dml2_opt>,  &dc->dml2_options,  sizeof(dc->dml2_options)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e48b3df3-6338-4ef6-ba3a-9d9dc3ec526a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1698,
                  "startColumn": 1,
                  "endLine": 1698,
                  "endColumn": 81,
                  "charOffset": 44736,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)",
                      "markdown": "`memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44736,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->dst, <size of &phantom_stream->dst>,  &ref_pipe->stream->dst,  sizeof(phantom_stream->dst)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15da87fb-b39d-4922-aeca-329694820029",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1697,
                  "startColumn": 1,
                  "endLine": 1697,
                  "endColumn": 81,
                  "charOffset": 44652,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)",
                      "markdown": "`memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44652,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->src, <size of &phantom_stream->src>,  &ref_pipe->stream->src,  sizeof(phantom_stream->src)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-40bb803a-edbf-4e89-90a5-36e05f898bf8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1666,
                  "startColumn": 2,
                  "endLine": 1666,
                  "endColumn": 86,
                  "charOffset": 43500,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)",
                      "markdown": "`memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43500,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dcc, <size of &phantom_plane->dcc>,  &curr_pipe->plane_state->dcc,  sizeof(phantom_plane->dcc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-061e6eb8-cecb-4a76-9b40-6ab94221b2aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1696,
                  "startColumn": 1,
                  "endLine": 1696,
                  "endColumn": 90,
                  "charOffset": 44559,
                  "charLength": 89,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)",
                      "markdown": "`memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44559,
                        "charLength": 89
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->timing, <size of &phantom_stream->timing>,  &ref_pipe->stream->timing,  sizeof(phantom_stream->timing)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-00c513db-3d8e-4ad8-815c-8532ed86a093",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1664,
                  "startColumn": 2,
                  "endLine": 1665,
                  "endColumn": 38,
                  "charOffset": 43383,
                  "charLength": 112,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)",
                      "markdown": "`memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43383,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->tiling_info, <size of &phantom_plane->tiling_info>,  &curr_pipe->plane_state->tiling_info, \n\t\t\t\tsizeof(phantom_plane->tiling_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-41621996-e8bf-4aa3-a1d1-49a9d1fd3b20",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1662,
                  "startColumn": 2,
                  "endLine": 1663,
                  "endColumn": 37,
                  "charOffset": 43269,
                  "charLength": 109,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)",
                      "markdown": "`memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43269,
                        "charLength": 109
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->plane_size, <size of &phantom_plane->plane_size>,  &curr_pipe->plane_state->plane_size, \n\t\t\t\tsizeof(phantom_plane->plane_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c91e3120-cbe7-4115-ab9e-5835686ab471",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1660,
                  "startColumn": 2,
                  "endLine": 1660,
                  "endColumn": 101,
                  "charOffset": 43058,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)",
                      "markdown": "`memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43058,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dst_rect, <size of &phantom_plane->dst_rect>,  &curr_pipe->plane_state->dst_rect,  sizeof(phantom_plane->dst_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-255b365c-780e-4bc7-9869-d4d28576bc5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1661,
                  "startColumn": 2,
                  "endLine": 1661,
                  "endColumn": 104,
                  "charOffset": 43162,
                  "charLength": 102,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)",
                      "markdown": "`memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43162,
                        "charLength": 102
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->clip_rect, <size of &phantom_plane->clip_rect>,  &curr_pipe->plane_state->clip_rect,  sizeof(phantom_plane->clip_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef7dfa71-abbf-422c-80f0-ae2dfb251a7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1659,
                  "startColumn": 2,
                  "endLine": 1659,
                  "endColumn": 101,
                  "charOffset": 42954,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)",
                      "markdown": "`memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42954,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->src_rect, <size of &phantom_plane->src_rect>,  &curr_pipe->plane_state->src_rect,  sizeof(phantom_plane->src_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25f5bbc5-2ff0-4d53-bb4b-c8d9bf46d3cc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1657,
                  "startColumn": 2,
                  "endLine": 1658,
                  "endColumn": 42,
                  "charOffset": 42825,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)",
                      "markdown": "`memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42825,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->scaling_quality, <size of &phantom_plane->scaling_quality>,  &curr_pipe->plane_state->scaling_quality, \n\t\t\t\tsizeof(phantom_plane->scaling_quality)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7901251d-86b5-4811-a35c-78f4807af050",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c"
                },
                "region": {
                  "startLine": 1583,
                  "startColumn": 1,
                  "endLine": 1583,
                  "endColumn": 61,
                  "charOffset": 41089,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                    "rendered": {
                      "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                      "markdown": "`memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41089,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dml2_opt, <size of dml2_opt>,  &dc->dml2_options,  sizeof(dc->dml2_options)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-63d35e1f-dd6a-4ef5-bc4f-50cb0880c8d8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                },
                "region": {
                  "startLine": 1656,
                  "startColumn": 2,
                  "endLine": 1656,
                  "endColumn": 98,
                  "charOffset": 42724,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)",
                      "markdown": "`memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42724,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->address, <size of &phantom_plane->address>,  &curr_pipe->plane_state->address,  sizeof(phantom_plane->address)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9f6feec1-6aa1-4848-bc8f-c092395f4be1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c"
                },
                "region": {
                  "startLine": 1613,
                  "startColumn": 1,
                  "endLine": 1613,
                  "endColumn": 61,
                  "charOffset": 42090,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                    "rendered": {
                      "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                      "markdown": "`memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42090,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dml2_opt, <size of dml2_opt>,  &dc->dml2_options,  sizeof(dc->dml2_options)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0fe05bc1-d69b-4074-8a30-27993d9011d5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce100/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 1,
                  "endLine": 445,
                  "endColumn": 33,
                  "charOffset": 14787,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce100/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14787,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr->max_clks_by_state, <size of clk_mgr->max_clks_by_state>, \n\t\tdce80_max_clks_by_state, \n\t\tsizeof(dce80_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ed8626fb-7bcb-46c7-af55-19680bd27880",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn10/dcn10_resource.c"
                },
                "region": {
                  "startLine": 1461,
                  "startColumn": 1,
                  "endLine": 1461,
                  "endColumn": 65,
                  "charOffset": 37164,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults)",
                    "rendered": {
                      "text": "memcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults)",
                      "markdown": "`memcpy(dc->dcn_ip, &dcn10_ip_defaults, sizeof(dcn10_ip_defaults)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn10/dcn10_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37164,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dc->dcn_ip, <size of dc->dcn_ip>,  &dcn10_ip_defaults,  sizeof(dcn10_ip_defaults)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8c318c72-a62d-43a7-8637-d30b79c716a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn10/dcn10_resource.c"
                },
                "region": {
                  "startLine": 1462,
                  "startColumn": 1,
                  "endLine": 1462,
                  "endColumn": 68,
                  "charOffset": 37232,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults)",
                    "rendered": {
                      "text": "memcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults)",
                      "markdown": "`memcpy(dc->dcn_soc, &dcn10_soc_defaults, sizeof(dcn10_soc_defaults)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/resource/dcn10/dcn10_resource.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37232,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dc->dcn_soc, <size of dc->dcn_soc>,  &dcn10_soc_defaults,  sizeof(dcn10_soc_defaults)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a78eccdc-d9d2-481a-be09-dee28edf7650",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 495,
                  "startColumn": 2,
                  "endLine": 497,
                  "endColumn": 47,
                  "charOffset": 19099,
                  "charLength": 168,
                  "snippet": {
                    "text": "memcpy(&context->bw_ctx.bw.dcn.fams2_global_config,\n\t\t\t\t&dml_ctx->v21.mode_programming.programming->fams2_global_config,\n\t\t\t\tsizeof(struct dmub_cmd_fams2_global_config)",
                    "rendered": {
                      "text": "memcpy(&context->bw_ctx.bw.dcn.fams2_global_config,\n\t\t\t\t&dml_ctx->v21.mode_programming.programming->fams2_global_config,\n\t\t\t\tsizeof(struct dmub_cmd_fams2_global_config)",
                      "markdown": "`memcpy(&context->bw_ctx.bw.dcn.fams2_global_config,\n\t\t\t\t&dml_ctx->v21.mode_programming.programming->fams2_global_config,\n\t\t\t\tsizeof(struct dmub_cmd_fams2_global_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19099,
                        "charLength": 168
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&context->bw_ctx.bw.dcn.fams2_global_config, <size of &context->bw_ctx.bw.dcn.fams2_global_config>, \n\t\t\t\t&dml_ctx->v21.mode_programming.programming->fams2_global_config, \n\t\t\t\tsizeof(struct dmub_cmd_fams2_global_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-225fcbf5-a40a-43bb-aa11-c828aedf37bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 417,
                  "startColumn": 3,
                  "endLine": 419,
                  "endColumn": 40,
                  "charOffset": 16475,
                  "charLength": 167,
                  "snippet": {
                    "text": "memcpy(static_sub_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                    "rendered": {
                      "text": "memcpy(static_sub_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                      "markdown": "`memcpy(static_sub_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16475,
                        "charLength": 167
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_sub_state, <size of static_sub_state>, \n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_sub_params, \n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2221eb4a-f1ba-45a6-954f-ded00bfd1515",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 414,
                  "startColumn": 3,
                  "endLine": 416,
                  "endColumn": 40,
                  "charOffset": 16300,
                  "charLength": 169,
                  "snippet": {
                    "text": "memcpy(static_base_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_base_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                    "rendered": {
                      "text": "memcpy(static_base_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_base_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                      "markdown": "`memcpy(static_base_state,\n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_base_params,\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16300,
                        "charLength": 169
                      },
                      "insertedContent": {
                        "text": "memcpy_s(static_base_state, <size of static_base_state>, \n\t\t\t\t\t&dml_ctx->v21.mode_programming.programming->stream_programming[dml_stream_idx].fams2_base_params, \n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-918423ee-d08d-4514-9b8b-800ced02d431",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 303,
                  "startColumn": 1,
                  "endLine": 304,
                  "endColumn": 36,
                  "charOffset": 11784,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->tiling_info, &main_plane->tiling_info,\n\t\tsizeof(phantom_plane->tiling_info)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->tiling_info, &main_plane->tiling_info,\n\t\tsizeof(phantom_plane->tiling_info)",
                      "markdown": "`memcpy(&phantom_plane->tiling_info, &main_plane->tiling_info,\n\t\tsizeof(phantom_plane->tiling_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11784,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->tiling_info, <size of &phantom_plane->tiling_info>,  &main_plane->tiling_info, \n\t\tsizeof(phantom_plane->tiling_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-673039c1-8cd4-4d93-b9a2-577ab884e312",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 1,
                  "endLine": 305,
                  "endColumn": 73,
                  "charOffset": 11886,
                  "charLength": 72,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dcc, &main_plane->dcc, sizeof(phantom_plane->dcc)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dcc, &main_plane->dcc, sizeof(phantom_plane->dcc)",
                      "markdown": "`memcpy(&phantom_plane->dcc, &main_plane->dcc, sizeof(phantom_plane->dcc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11886,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dcc, <size of &phantom_plane->dcc>,  &main_plane->dcc,  sizeof(phantom_plane->dcc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ff5e1a93-7857-4836-a953-025da56a4b28",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 1,
                  "endLine": 302,
                  "endColumn": 35,
                  "charOffset": 11685,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->plane_size, &main_plane->plane_size,\n\t\tsizeof(phantom_plane->plane_size)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->plane_size, &main_plane->plane_size,\n\t\tsizeof(phantom_plane->plane_size)",
                      "markdown": "`memcpy(&phantom_plane->plane_size, &main_plane->plane_size,\n\t\tsizeof(phantom_plane->plane_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11685,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->plane_size, <size of &phantom_plane->plane_size>,  &main_plane->plane_size, \n\t\tsizeof(phantom_plane->plane_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef350aed-3ac2-4d8a-8aa5-d57edd056fcd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 1,
                  "endLine": 300,
                  "endColumn": 91,
                  "charOffset": 11591,
                  "charLength": 90,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->clip_rect, &main_plane->clip_rect, sizeof(phantom_plane->clip_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->clip_rect, &main_plane->clip_rect, sizeof(phantom_plane->clip_rect)",
                      "markdown": "`memcpy(&phantom_plane->clip_rect, &main_plane->clip_rect, sizeof(phantom_plane->clip_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11591,
                        "charLength": 90
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->clip_rect, <size of &phantom_plane->clip_rect>,  &main_plane->clip_rect,  sizeof(phantom_plane->clip_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bc86cc48-5a8b-47d1-b909-f75b96448541",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 1,
                  "endLine": 299,
                  "endColumn": 88,
                  "charOffset": 11500,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dst_rect, &main_plane->dst_rect, sizeof(phantom_plane->dst_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dst_rect, &main_plane->dst_rect, sizeof(phantom_plane->dst_rect)",
                      "markdown": "`memcpy(&phantom_plane->dst_rect, &main_plane->dst_rect, sizeof(phantom_plane->dst_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11500,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dst_rect, <size of &phantom_plane->dst_rect>,  &main_plane->dst_rect,  sizeof(phantom_plane->dst_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7e52e040-41de-49a6-943a-ce7eef0769de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 298,
                  "startColumn": 1,
                  "endLine": 298,
                  "endColumn": 88,
                  "charOffset": 11409,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->src_rect, &main_plane->src_rect, sizeof(phantom_plane->src_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->src_rect, &main_plane->src_rect, sizeof(phantom_plane->src_rect)",
                      "markdown": "`memcpy(&phantom_plane->src_rect, &main_plane->src_rect, sizeof(phantom_plane->src_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11409,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->src_rect, <size of &phantom_plane->src_rect>,  &main_plane->src_rect,  sizeof(phantom_plane->src_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-02ecf688-6155-4dd7-977b-ac6ee3a1e5f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 1,
                  "endLine": 297,
                  "endColumn": 40,
                  "charOffset": 11295,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->scaling_quality, &main_plane->scaling_quality,\n\t\tsizeof(phantom_plane->scaling_quality)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->scaling_quality, &main_plane->scaling_quality,\n\t\tsizeof(phantom_plane->scaling_quality)",
                      "markdown": "`memcpy(&phantom_plane->scaling_quality, &main_plane->scaling_quality,\n\t\tsizeof(phantom_plane->scaling_quality)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11295,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->scaling_quality, <size of &phantom_plane->scaling_quality>,  &main_plane->scaling_quality, \n\t\tsizeof(phantom_plane->scaling_quality)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-863f5bd6-be56-4ff8-a694-14852b947dce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 1,
                  "endLine": 295,
                  "endColumn": 85,
                  "charOffset": 11207,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->address, &main_plane->address, sizeof(phantom_plane->address)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->address, &main_plane->address, sizeof(phantom_plane->address)",
                      "markdown": "`memcpy(&phantom_plane->address, &main_plane->address, sizeof(phantom_plane->address)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11207,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->address, <size of &phantom_plane->address>,  &main_plane->address,  sizeof(phantom_plane->address)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58ee6609-8251-4f08-bbcd-795bea496fb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 1,
                  "endLine": 257,
                  "endColumn": 76,
                  "charOffset": 9709,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->dst, &main_stream->dst, sizeof(phantom_stream->dst)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->dst, &main_stream->dst, sizeof(phantom_stream->dst)",
                      "markdown": "`memcpy(&phantom_stream->dst, &main_stream->dst, sizeof(phantom_stream->dst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9709,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->dst, <size of &phantom_stream->dst>,  &main_stream->dst,  sizeof(phantom_stream->dst)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72d955f3-b06e-4212-919d-67ca5542d76a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 1,
                  "endLine": 256,
                  "endColumn": 76,
                  "charOffset": 9630,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->src, &main_stream->src, sizeof(phantom_stream->src)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->src, &main_stream->src, sizeof(phantom_stream->src)",
                      "markdown": "`memcpy(&phantom_stream->src, &main_stream->src, sizeof(phantom_stream->src)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9630,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->src, <size of &phantom_stream->src>,  &main_stream->src,  sizeof(phantom_stream->src)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7cbece57-f8f1-40f8-9f58-302889528cb9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 1,
                  "endLine": 255,
                  "endColumn": 85,
                  "charOffset": 9542,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->timing, &main_stream->timing, sizeof(phantom_stream->timing)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->timing, &main_stream->timing, sizeof(phantom_stream->timing)",
                      "markdown": "`memcpy(&phantom_stream->timing, &main_stream->timing, sizeof(phantom_stream->timing)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9542,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->timing, <size of &phantom_stream->timing>,  &main_stream->timing,  sizeof(phantom_stream->timing)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0bb899eb-9253-4072-b150-25be31fea78b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 2,
                  "endLine": 221,
                  "endColumn": 129,
                  "charOffset": 7991,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&pipe_ctx->hubp_regs, pln_prog->phantom_plane.pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)",
                    "rendered": {
                      "text": "memcpy(&pipe_ctx->hubp_regs, pln_prog->phantom_plane.pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)",
                      "markdown": "`memcpy(&pipe_ctx->hubp_regs, pln_prog->phantom_plane.pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7991,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pipe_ctx->hubp_regs, <size of &pipe_ctx->hubp_regs>,  pln_prog->phantom_plane.pipe_regs[pipe_reg_index],  sizeof(struct dml2_dchub_per_pipe_register_set)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9ab63754-4df6-4246-ba01-8112e8601d64",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 1,
                  "endLine": 159,
                  "endColumn": 44,
                  "charOffset": 5569,
                  "charLength": 90,
                  "snippet": {
                    "text": "memcpy(&pipe_ctx->global_sync,\n\t\tglobal_sync,\n\t\tsizeof(union dml2_global_sync_programming)",
                    "rendered": {
                      "text": "memcpy(&pipe_ctx->global_sync,\n\t\tglobal_sync,\n\t\tsizeof(union dml2_global_sync_programming)",
                      "markdown": "`memcpy(&pipe_ctx->global_sync,\n\t\tglobal_sync,\n\t\tsizeof(union dml2_global_sync_programming)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5569,
                        "charLength": 90
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pipe_ctx->global_sync, <size of &pipe_ctx->global_sync>, \n\t\tglobal_sync, \n\t\tsizeof(union dml2_global_sync_programming)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c7ca281-7aeb-43b1-a2e3-59cfe6cae4cf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 1,
                  "endLine": 416,
                  "endColumn": 120,
                  "charOffset": 17535,
                  "charLength": 119,
                  "snippet": {
                    "text": "memcpy(dst_dml2_programming, src_dml_ctx->v21.mode_programming.programming, sizeof(struct dml2_display_cfg_programming)",
                    "rendered": {
                      "text": "memcpy(dst_dml2_programming, src_dml_ctx->v21.mode_programming.programming, sizeof(struct dml2_display_cfg_programming)",
                      "markdown": "`memcpy(dst_dml2_programming, src_dml_ctx->v21.mode_programming.programming, sizeof(struct dml2_display_cfg_programming)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17535,
                        "charLength": 119
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_dml2_programming, <size of dst_dml2_programming>,  src_dml_ctx->v21.mode_programming.programming,  sizeof(struct dml2_display_cfg_programming)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7eea08ec-aafd-4c3e-acf8-86f09d58911a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 2,
                  "endLine": 225,
                  "endColumn": 115,
                  "charOffset": 8204,
                  "charLength": 113,
                  "snippet": {
                    "text": "memcpy(&pipe_ctx->hubp_regs, pln_prog->pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)",
                    "rendered": {
                      "text": "memcpy(&pipe_ctx->hubp_regs, pln_prog->pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)",
                      "markdown": "`memcpy(&pipe_ctx->hubp_regs, pln_prog->pipe_regs[pipe_reg_index], sizeof(struct dml2_dchub_per_pipe_register_set)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8204,
                        "charLength": 113
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pipe_ctx->hubp_regs, <size of &pipe_ctx->hubp_regs>,  pln_prog->pipe_regs[pipe_reg_index],  sizeof(struct dml2_dchub_per_pipe_register_set)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b7c97696-7c22-4ced-9b01-2a1346efdbbf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 5,
                  "endLine": 395,
                  "endColumn": 48,
                  "charOffset": 16715,
                  "charLength": 209,
                  "snippet": {
                    "text": "memcpy(&dc_phantom_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_phantom_prog_idx][dc_pipe_index],\n\t\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)",
                    "rendered": {
                      "text": "memcpy(&dc_phantom_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_phantom_prog_idx][dc_pipe_index],\n\t\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)",
                      "markdown": "`memcpy(&dc_phantom_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_phantom_prog_idx][dc_pipe_index],\n\t\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16715,
                        "charLength": 209
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc_phantom_pipes[dc_pipe_index]->mcache_regs, <size of &dc_phantom_pipes[dc_pipe_index]->mcache_regs>, \n\t\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_phantom_prog_idx][dc_pipe_index], \n\t\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-46008326-36ba-4345-9c57-65f2808051ad",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 1,
                  "endLine": 415,
                  "endColumn": 96,
                  "charOffset": 17436,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(dst_dml2_instance, src_dml_ctx->v21.dml_init.dml2_instance, sizeof(struct dml2_instance)",
                    "rendered": {
                      "text": "memcpy(dst_dml2_instance, src_dml_ctx->v21.dml_init.dml2_instance, sizeof(struct dml2_instance)",
                      "markdown": "`memcpy(dst_dml2_instance, src_dml_ctx->v21.dml_init.dml2_instance, sizeof(struct dml2_instance)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17436,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_dml2_instance, <size of dst_dml2_instance>,  src_dml_ctx->v21.dml_init.dml2_instance,  sizeof(struct dml2_instance)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1cde1156-e50e-48ad-ad5c-990d5fd7ce24",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 1,
                  "endLine": 412,
                  "endColumn": 61,
                  "charOffset": 17349,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(dst_dml_ctx, src_dml_ctx, sizeof(struct dml2_context)",
                    "rendered": {
                      "text": "memcpy(dst_dml_ctx, src_dml_ctx, sizeof(struct dml2_context)",
                      "markdown": "`memcpy(dst_dml_ctx, src_dml_ctx, sizeof(struct dml2_context)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17349,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_dml_ctx, <size of dst_dml_ctx>,  src_dml_ctx,  sizeof(struct dml2_context)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d10c45d1-c122-4035-b75e-b44738a1b593",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 4,
                  "endLine": 381,
                  "endColumn": 47,
                  "charOffset": 16094,
                  "charLength": 196,
                  "snippet": {
                    "text": "memcpy(&dc_main_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index],\n\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)",
                    "rendered": {
                      "text": "memcpy(&dc_main_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index],\n\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)",
                      "markdown": "`memcpy(&dc_main_pipes[dc_pipe_index]->mcache_regs,\n\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index],\n\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16094,
                        "charLength": 196
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc_main_pipes[dc_pipe_index]->mcache_regs, <size of &dc_main_pipes[dc_pipe_index]->mcache_regs>, \n\t\t\t\t\t\tl->build_mcache_programming_params.per_plane_pipe_mcache_regs[dml_prog_idx][dc_pipe_index], \n\t\t\t\t\t\tsizeof(struct dml2_hubp_pipe_mcache_regs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7c203d95-99a4-44e7-8238-2e724adc9e72",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 3,
                  "endLine": 175,
                  "endColumn": 50,
                  "charOffset": 6694,
                  "charLength": 172,
                  "snippet": {
                    "text": "memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx],\n\t\t\t\t\t&pln_prog->phantom_plane.mcache_allocation,\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                    "rendered": {
                      "text": "memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx],\n\t\t\t\t\t&pln_prog->phantom_plane.mcache_allocation,\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)",
                      "markdown": "`memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx],\n\t\t\t\t\t&pln_prog->phantom_plane.mcache_allocation,\n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6694,
                        "charLength": 172
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx], <size of &context->bw_ctx.bw.dcn.mcache_allocations[dml_phantom_prog_idx]>, \n\t\t\t\t\t&pln_prog->phantom_plane.mcache_allocation, \n\t\t\t\t\tsizeof(struct dml2_mcache_surface_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e16f1ae5-27f1-4a69-87ec-3b28774b3012",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 1,
                  "endLine": 132,
                  "endColumn": 143,
                  "charOffset": 4912,
                  "charLength": 142,
                  "snippet": {
                    "text": "memcpy(&context->bw_ctx.bw.dcn.arb_regs, &in_ctx->v21.mode_programming.programming->global_regs.arb_regs, sizeof(struct dml2_display_arb_regs)",
                    "rendered": {
                      "text": "memcpy(&context->bw_ctx.bw.dcn.arb_regs, &in_ctx->v21.mode_programming.programming->global_regs.arb_regs, sizeof(struct dml2_display_arb_regs)",
                      "markdown": "`memcpy(&context->bw_ctx.bw.dcn.arb_regs, &in_ctx->v21.mode_programming.programming->global_regs.arb_regs, sizeof(struct dml2_display_arb_regs)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4912,
                        "charLength": 142
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&context->bw_ctx.bw.dcn.arb_regs, <size of &context->bw_ctx.bw.dcn.arb_regs>,  &in_ctx->v21.mode_programming.programming->global_regs.arb_regs,  sizeof(struct dml2_display_arb_regs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c1b1ec3-3c08-4349-bd8d-cec24a628673",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 1128,
                  "startColumn": 3,
                  "endLine": 1130,
                  "endColumn": 44,
                  "charOffset": 44208,
                  "charLength": 109,
                  "snippet": {
                    "text": "memcpy(wm_regs,\n\t\t\t\t&programming->global_regs.wm_regs[wm_index],\n\t\t\t\tsizeof(struct dml2_dchub_watermark_regs)",
                    "rendered": {
                      "text": "memcpy(wm_regs,\n\t\t\t\t&programming->global_regs.wm_regs[wm_index],\n\t\t\t\tsizeof(struct dml2_dchub_watermark_regs)",
                      "markdown": "`memcpy(wm_regs,\n\t\t\t\t&programming->global_regs.wm_regs[wm_index],\n\t\t\t\tsizeof(struct dml2_dchub_watermark_regs)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44208,
                        "charLength": 109
                      },
                      "insertedContent": {
                        "text": "memcpy_s(wm_regs, <size of wm_regs>, \n\t\t\t\t&programming->global_regs.wm_regs[wm_index], \n\t\t\t\tsizeof(struct dml2_dchub_watermark_regs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c4fe9058-9829-44e3-9191-0997e7b33c0d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 2,
                  "endLine": 171,
                  "endColumn": 142,
                  "charOffset": 6509,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx], &pln_prog->mcache_allocation, sizeof(struct dml2_mcache_surface_allocation)",
                    "rendered": {
                      "text": "memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx], &pln_prog->mcache_allocation, sizeof(struct dml2_mcache_surface_allocation)",
                      "markdown": "`memcpy(&context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx], &pln_prog->mcache_allocation, sizeof(struct dml2_mcache_surface_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6509,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx], <size of &context->bw_ctx.bw.dcn.mcache_allocations[dml_prog_idx]>,  &pln_prog->mcache_allocation,  sizeof(struct dml2_mcache_surface_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-313799b2-260f-44b2-bf17-188277feb18e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 1,
                  "endLine": 63,
                  "endColumn": 72,
                  "charOffset": 1829,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(&dml_init->ip_caps, ip_caps, sizeof(struct dml2_ip_capabilities)",
                    "rendered": {
                      "text": "memcpy(&dml_init->ip_caps, ip_caps, sizeof(struct dml2_ip_capabilities)",
                      "markdown": "`memcpy(&dml_init->ip_caps, ip_caps, sizeof(struct dml2_ip_capabilities)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1829,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml_init->ip_caps, <size of &dml_init->ip_caps>,  ip_caps,  sizeof(struct dml2_ip_capabilities)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8e842e29-630c-41c0-874d-38a5e7aedcb1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 1,
                  "endLine": 48,
                  "endColumn": 109,
                  "charOffset": 1394,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(&dml_init->ip_caps, &config->external_socbb_ip_params->ip_params, sizeof(struct dml2_ip_capabilities)",
                    "rendered": {
                      "text": "memcpy(&dml_init->ip_caps, &config->external_socbb_ip_params->ip_params, sizeof(struct dml2_ip_capabilities)",
                      "markdown": "`memcpy(&dml_init->ip_caps, &config->external_socbb_ip_params->ip_params, sizeof(struct dml2_ip_capabilities)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1394,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml_init->ip_caps, <size of &dml_init->ip_caps>,  &config->external_socbb_ip_params->ip_params,  sizeof(struct dml2_ip_capabilities)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0ef37a4c-49fd-4021-8caa-47adddf753e3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 1,
                  "endLine": 42,
                  "endColumn": 96,
                  "charOffset": 1152,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(&dml_init->soc_bb, &config->external_socbb_ip_params->soc_bb, sizeof(struct dml2_soc_bb)",
                    "rendered": {
                      "text": "memcpy(&dml_init->soc_bb, &config->external_socbb_ip_params->soc_bb, sizeof(struct dml2_soc_bb)",
                      "markdown": "`memcpy(&dml_init->soc_bb, &config->external_socbb_ip_params->soc_bb, sizeof(struct dml2_soc_bb)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1152,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml_init->soc_bb, <size of &dml_init->soc_bb>,  &config->external_socbb_ip_params->soc_bb,  sizeof(struct dml2_soc_bb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5037be97-001d-45af-9134-a22ea1892377",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce112/dce112_clk_mgr.c"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 1,
                  "endLine": 231,
                  "endColumn": 34,
                  "charOffset": 8225,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce112/dce112_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8225,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr->max_clks_by_state, <size of clk_mgr->max_clks_by_state>, \n\t\tdce112_max_clks_by_state, \n\t\tsizeof(dce112_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-050570f5-77fc-4059-b425-a6fc6d098088",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 1,
                  "endLine": 36,
                  "endColumn": 92,
                  "charOffset": 911,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&dml_init->soc_bb.qos_parameters, qos_params, sizeof(struct dml2_soc_qos_parameters)",
                    "rendered": {
                      "text": "memcpy(&dml_init->soc_bb.qos_parameters, qos_params, sizeof(struct dml2_soc_qos_parameters)",
                      "markdown": "`memcpy(&dml_init->soc_bb.qos_parameters, qos_params, sizeof(struct dml2_soc_qos_parameters)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 911,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml_init->soc_bb.qos_parameters, <size of &dml_init->soc_bb.qos_parameters>,  qos_params,  sizeof(struct dml2_soc_qos_parameters)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2201bd19-c659-4176-85be-dc5c05ef5c9d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 1,
                  "endLine": 33,
                  "endColumn": 61,
                  "charOffset": 822,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(&dml_init->soc_bb, soc_bb, sizeof(struct dml2_soc_bb)",
                    "rendered": {
                      "text": "memcpy(&dml_init->soc_bb, soc_bb, sizeof(struct dml2_soc_bb)",
                      "markdown": "`memcpy(&dml_init->soc_bb, soc_bb, sizeof(struct dml2_soc_bb)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml21/dml21_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 822,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dml_init->soc_bb, <size of &dml_init->soc_bb>,  soc_bb,  sizeof(struct dml2_soc_bb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-92607bc0-4eca-4caa-a7f4-bd5d61a567c1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce110/dce110_clk_mgr.c"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 1,
                  "endLine": 289,
                  "endColumn": 34,
                  "charOffset": 9695,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce110/dce110_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9695,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr->max_clks_by_state, <size of clk_mgr->max_clks_by_state>, \n\t\tdce110_max_clks_by_state, \n\t\tsizeof(dce110_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d9fe3837-e1aa-432d-bf22-4f56af969e90",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce120/dce120_clk_mgr.c"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 34,
                  "charOffset": 4908,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce120/dce120_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4908,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr->max_clks_by_state, <size of clk_mgr->max_clks_by_state>, \n\t\tdce120_max_clks_by_state, \n\t\tsizeof(dce120_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-376d03fa-a03a-4994-b4c0-91f51921f20a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c"
                },
                "region": {
                  "startLine": 1329,
                  "startColumn": 1,
                  "endLine": 1329,
                  "endColumn": 66,
                  "charOffset": 53201,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(&new_clocks, &clk_mgr_base->clks, sizeof(struct dc_clocks)",
                    "rendered": {
                      "text": "memcpy(&new_clocks, &clk_mgr_base->clks, sizeof(struct dc_clocks)",
                      "markdown": "`memcpy(&new_clocks, &clk_mgr_base->clks, sizeof(struct dc_clocks)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn401/dcn401_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53201,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&new_clocks, <size of &new_clocks>,  &clk_mgr_base->clks,  sizeof(struct dc_clocks)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b2d175f7-e497-43aa-9cd8-4b08ef751687",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce60/dce60_clk_mgr.c"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 1,
                  "endLine": 167,
                  "endColumn": 33,
                  "charOffset": 5554,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce60_max_clks_by_state,\n\t\tsizeof(dce60_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr->max_clks_by_state,\n\t\tdce60_max_clks_by_state,\n\t\tsizeof(dce60_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr->max_clks_by_state,\n\t\tdce60_max_clks_by_state,\n\t\tsizeof(dce60_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/clk_mgr/dce60/dce60_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5554,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr->max_clks_by_state, <size of clk_mgr->max_clks_by_state>, \n\t\tdce60_max_clks_by_state, \n\t\tsizeof(dce60_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd3a3adf-b416-455f-9417-4bbce538fea5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/mmhubbub/dcn20/dcn20_mmhubbub.c"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 1,
                  "endLine": 287,
                  "endColumn": 81,
                  "charOffset": 13226,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(dest_luma_buffer,   luma_buffer,   mcif_params->luma_pitch * dest_height)",
                    "rendered": {
                      "text": "memcpy(dest_luma_buffer,   luma_buffer,   mcif_params->luma_pitch * dest_height)",
                      "markdown": "`memcpy(dest_luma_buffer,   luma_buffer,   mcif_params->luma_pitch * dest_height)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/mmhubbub/dcn20/dcn20_mmhubbub.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13226,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_luma_buffer, <size of dest_luma_buffer>,    luma_buffer,    mcif_params->luma_pitch * dest_height)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-68e09390-6bd6-4f91-885a-fa1e2228f380",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/mmhubbub/dcn20/dcn20_mmhubbub.c"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 1,
                  "endLine": 288,
                  "endColumn": 87,
                  "charOffset": 13309,
                  "charLength": 86,
                  "snippet": {
                    "text": "memcpy(dest_chroma_buffer, chroma_buffer, mcif_params->chroma_pitch * dest_height / 2)",
                    "rendered": {
                      "text": "memcpy(dest_chroma_buffer, chroma_buffer, mcif_params->chroma_pitch * dest_height / 2)",
                      "markdown": "`memcpy(dest_chroma_buffer, chroma_buffer, mcif_params->chroma_pitch * dest_height / 2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/mmhubbub/dcn20/dcn20_mmhubbub.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13309,
                        "charLength": 86
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_chroma_buffer, <size of dest_chroma_buffer>,  chroma_buffer,  mcif_params->chroma_pitch * dest_height / 2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19471ac0-e6f0-4eb6-93c5-2ac99bf3e9a5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_dscl.c"
                },
                "region": {
                  "startLine": 1094,
                  "startColumn": 2,
                  "endLine": 1095,
                  "endColumn": 19,
                  "charOffset": 42529,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(dpp->scl_data.dscl_prog_data.isharp_delta, scl_data->dscl_prog_data.isharp_delta,\n\t\t\tsizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(dpp->scl_data.dscl_prog_data.isharp_delta, scl_data->dscl_prog_data.isharp_delta,\n\t\t\tsizeof(uint32_t)",
                      "markdown": "`memcpy(dpp->scl_data.dscl_prog_data.isharp_delta, scl_data->dscl_prog_data.isharp_delta,\n\t\t\tsizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dpp/dcn401/dcn401_dpp_dscl.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42529,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dpp->scl_data.dscl_prog_data.isharp_delta, <size of dpp->scl_data.dscl_prog_data.isharp_delta>,  scl_data->dscl_prog_data.isharp_delta, \n\t\t\tsizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-992e36ac-24c9-4c76-9ffb-4910048ed830",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dio/dcn30/dcn30_dio_stream_encoder.c"
                },
                "region": {
                  "startLine": 348,
                  "startColumn": 3,
                  "endLine": 348,
                  "endColumn": 50,
                  "charOffset": 10014,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)",
                    "rendered": {
                      "text": "memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)",
                      "markdown": "`memcpy(pps_sdp.sb, &dsc_packed_pps[i * 32], 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dio/dcn30/dcn30_dio_stream_encoder.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10014,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pps_sdp.sb, <size of pps_sdp.sb>,  &dsc_packed_pps[i * 32],  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9b43e332-74e8-42a9-a33d-d92407309948",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dio/dcn20/dcn20_stream_encoder.c"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 2,
                  "endLine": 313,
                  "endColumn": 59,
                  "charOffset": 9262,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb)",
                    "rendered": {
                      "text": "memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb)",
                      "markdown": "`memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dio/dcn20/dcn20_stream_encoder.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9262,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pps_sdp.sb[0], <size of &pps_sdp.sb[0]>,  dsc_packed_pps,  sizeof(pps_sdp.sb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-95560c8d-9c2d-414a-a741-ade4581ad936",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c"
                },
                "region": {
                  "startLine": 2667,
                  "startColumn": 2,
                  "endLine": 2667,
                  "endColumn": 113,
                  "charOffset": 85194,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(&pipe_ctx->plane_state->visual_confirm_color, &(pipe_ctx->visual_confirm_color), sizeof(struct tg_color)",
                    "rendered": {
                      "text": "memcpy(&pipe_ctx->plane_state->visual_confirm_color, &(pipe_ctx->visual_confirm_color), sizeof(struct tg_color)",
                      "markdown": "`memcpy(&pipe_ctx->plane_state->visual_confirm_color, &(pipe_ctx->visual_confirm_color), sizeof(struct tg_color)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85194,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&pipe_ctx->plane_state->visual_confirm_color, <size of &pipe_ctx->plane_state->visual_confirm_color>,  &(pipe_ctx->visual_confirm_color),  sizeof(struct tg_color)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c7b2b6f-28a0-4d0d-b343-7750e15d82fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v11.c"
                },
                "region": {
                  "startLine": 357,
                  "startColumn": 1,
                  "endLine": 357,
                  "endColumn": 30,
                  "charOffset": 11614,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v11.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11614,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07f20a86-bbd8-4d93-b4e1-3fa939540dc7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v11.c"
                },
                "region": {
                  "startLine": 342,
                  "startColumn": 1,
                  "endLine": 342,
                  "endColumn": 50,
                  "charOffset": 11196,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct v11_compute_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct v11_compute_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct v11_compute_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v11.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11196,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct v11_compute_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4feac01f-7985-45ad-80c1-45a647937975",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                },
                "region": {
                  "startLine": 467,
                  "startColumn": 1,
                  "endLine": 467,
                  "endColumn": 63,
                  "charOffset": 13904,
                  "charLength": 62,
                  "snippet": {
                    "text": "strcpy(amd_mem_client.version, AMD_PEER_BRIDGE_DRIVER_VERSION)",
                    "rendered": {
                      "text": "strcpy(amd_mem_client.version, AMD_PEER_BRIDGE_DRIVER_VERSION)",
                      "markdown": "`strcpy(amd_mem_client.version, AMD_PEER_BRIDGE_DRIVER_VERSION)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13904,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(amd_mem_client.version, <size of amd_mem_client.version>,  AMD_PEER_BRIDGE_DRIVER_VERSION)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13904,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(amd_mem_client.version,  AMD_PEER_BRIDGE_DRIVER_VERSION, <size of amd_mem_client.version>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cfe88839-c099-4c68-b1d4-87f87a2eaa51",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                },
                "region": {
                  "startLine": 466,
                  "startColumn": 1,
                  "endLine": 466,
                  "endColumn": 60,
                  "charOffset": 13842,
                  "charLength": 59,
                  "snippet": {
                    "text": "strcpy(amd_mem_client.name,    AMD_PEER_BRIDGE_DRIVER_NAME)",
                    "rendered": {
                      "text": "strcpy(amd_mem_client.name,    AMD_PEER_BRIDGE_DRIVER_NAME)",
                      "markdown": "`strcpy(amd_mem_client.name,    AMD_PEER_BRIDGE_DRIVER_NAME)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13842,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strcpy_s(amd_mem_client.name, <size of amd_mem_client.name>,     AMD_PEER_BRIDGE_DRIVER_NAME)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_peerdirect.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13842,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strlcpy(amd_mem_client.name,     AMD_PEER_BRIDGE_DRIVER_NAME, <size of amd_mem_client.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-038f5d79-5bb9-4f1b-b5fc-c738150479fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_spm.c"
                },
                "region": {
                  "startLine": 584,
                  "startColumn": 1,
                  "endLine": 584,
                  "endColumn": 59,
                  "charOffset": 16234,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(&user_spm_data, user_spm_ptr, sizeof(user_spm_data)",
                    "rendered": {
                      "text": "memcpy(&user_spm_data, user_spm_ptr, sizeof(user_spm_data)",
                      "markdown": "`memcpy(&user_spm_data, user_spm_ptr, sizeof(user_spm_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_spm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16234,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&user_spm_data, <size of &user_spm_data>,  user_spm_ptr,  sizeof(user_spm_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4cfdb243-82d5-4407-b0f0-8a220c334b68",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_spm.c"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 2,
                  "endLine": 253,
                  "endColumn": 45,
                  "charOffset": 7507,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(ring_start, ring_end, overflow_size)",
                    "rendered": {
                      "text": "memcpy(ring_start, ring_end, overflow_size)",
                      "markdown": "`memcpy(ring_start, ring_end, overflow_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_spm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7507,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ring_start, <size of ring_start>,  ring_end,  overflow_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-37faa9f4-fe88-416c-966b-c9c871a044bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                },
                "region": {
                  "startLine": 571,
                  "startColumn": 3,
                  "endLine": 573,
                  "endColumn": 48,
                  "charOffset": 14743,
                  "charLength": 120,
                  "snippet": {
                    "text": "memcpy(&ev_priv->memory_exception_data,\n\t\t\t\t&ev->memory_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_memory_exception_data)",
                    "rendered": {
                      "text": "memcpy(&ev_priv->memory_exception_data,\n\t\t\t\t&ev->memory_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_memory_exception_data)",
                      "markdown": "`memcpy(&ev_priv->memory_exception_data,\n\t\t\t\t&ev->memory_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_memory_exception_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14743,
                        "charLength": 120
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ev_priv->memory_exception_data, <size of &ev_priv->memory_exception_data>, \n\t\t\t\t&ev->memory_exception_data, \n\t\t\t\tsizeof(struct kfd_hsa_memory_exception_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef78a5fe-aac1-40fb-87b9-d9c4c35f0671",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                },
                "region": {
                  "startLine": 575,
                  "startColumn": 3,
                  "endLine": 577,
                  "endColumn": 44,
                  "charOffset": 14926,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(&ev_priv->hw_exception_data,\n\t\t\t\t&ev->hw_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_hw_exception_data)",
                    "rendered": {
                      "text": "memcpy(&ev_priv->hw_exception_data,\n\t\t\t\t&ev->hw_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_hw_exception_data)",
                      "markdown": "`memcpy(&ev_priv->hw_exception_data,\n\t\t\t\t&ev->hw_exception_data,\n\t\t\t\tsizeof(struct kfd_hsa_hw_exception_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14926,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ev_priv->hw_exception_data, <size of &ev_priv->hw_exception_data>, \n\t\t\t\t&ev->hw_exception_data, \n\t\t\t\tsizeof(struct kfd_hsa_hw_exception_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-56505e62-08d6-4410-86a3-9eeb349db2c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                },
                "region": {
                  "startLine": 512,
                  "startColumn": 2,
                  "endLine": 514,
                  "endColumn": 43,
                  "charOffset": 13403,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(&ev->hw_exception_data,\n\t\t\t&ev_priv->hw_exception_data,\n\t\t\tsizeof(struct kfd_hsa_hw_exception_data)",
                    "rendered": {
                      "text": "memcpy(&ev->hw_exception_data,\n\t\t\t&ev_priv->hw_exception_data,\n\t\t\tsizeof(struct kfd_hsa_hw_exception_data)",
                      "markdown": "`memcpy(&ev->hw_exception_data,\n\t\t\t&ev_priv->hw_exception_data,\n\t\t\tsizeof(struct kfd_hsa_hw_exception_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13403,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ev->hw_exception_data, <size of &ev->hw_exception_data>, \n\t\t\t&ev_priv->hw_exception_data, \n\t\t\tsizeof(struct kfd_hsa_hw_exception_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b99f50bb-eb37-41d7-aecd-c0ad1ab3d653",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 2,
                  "endLine": 507,
                  "endColumn": 47,
                  "charOffset": 13180,
                  "charLength": 118,
                  "snippet": {
                    "text": "memcpy(&ev->memory_exception_data,\n\t\t\t&ev_priv->memory_exception_data,\n\t\t\tsizeof(struct kfd_hsa_memory_exception_data)",
                    "rendered": {
                      "text": "memcpy(&ev->memory_exception_data,\n\t\t\t&ev_priv->memory_exception_data,\n\t\t\tsizeof(struct kfd_hsa_memory_exception_data)",
                      "markdown": "`memcpy(&ev->memory_exception_data,\n\t\t\t&ev_priv->memory_exception_data,\n\t\t\tsizeof(struct kfd_hsa_memory_exception_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_events.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13180,
                        "charLength": 118
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ev->memory_exception_data, <size of &ev->memory_exception_data>, \n\t\t\t&ev_priv->memory_exception_data, \n\t\t\tsizeof(struct kfd_hsa_memory_exception_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-95e36b6a-98ed-4784-b05c-58a67d341a53",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_process.c"
                },
                "region": {
                  "startLine": 1421,
                  "startColumn": 1,
                  "endLine": 1421,
                  "endColumn": 69,
                  "charOffset": 37939,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)",
                    "rendered": {
                      "text": "memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)",
                      "markdown": "`memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_process.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37939,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(qpd->cwsr_kaddr, <size of qpd->cwsr_kaddr>,  dev->kfd->cwsr_isa,  dev->kfd->cwsr_isa_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9a8724c5-8ab9-4841-a713-e508ec42e2c8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_process.c"
                },
                "region": {
                  "startLine": 1383,
                  "startColumn": 2,
                  "endLine": 1383,
                  "endColumn": 70,
                  "charOffset": 36921,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)",
                    "rendered": {
                      "text": "memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)",
                      "markdown": "`memcpy(qpd->cwsr_kaddr, dev->kfd->cwsr_isa, dev->kfd->cwsr_isa_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_process.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36921,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(qpd->cwsr_kaddr, <size of qpd->cwsr_kaddr>,  dev->kfd->cwsr_isa,  dev->kfd->cwsr_isa_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ec787e47-8b0c-4c8e-914b-7ec6db2cfd4e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_queue.c"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 1,
                  "endLine": 77,
                  "endColumn": 59,
                  "charOffset": 3037,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(&tmp_q->properties, properties, sizeof(*properties)",
                    "rendered": {
                      "text": "memcpy(&tmp_q->properties, properties, sizeof(*properties)",
                      "markdown": "`memcpy(&tmp_q->properties, properties, sizeof(*properties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_queue.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3037,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tmp_q->properties, <size of &tmp_q->properties>,  properties,  sizeof(*properties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f1b03318-f78c-482b-a905-31feb2b54ea2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                },
                "region": {
                  "startLine": 1584,
                  "startColumn": 1,
                  "endLine": 1584,
                  "endColumn": 60,
                  "charOffset": 46572,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(props, iolink1, sizeof(struct kfd_iolink_properties)",
                    "rendered": {
                      "text": "memcpy(props, iolink1, sizeof(struct kfd_iolink_properties)",
                      "markdown": "`memcpy(props, iolink1, sizeof(struct kfd_iolink_properties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46572,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(props, <size of props>,  iolink1,  sizeof(struct kfd_iolink_properties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7faad49b-b2a5-4aed-9040-bfa2b6d3de51",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                },
                "region": {
                  "startLine": 1541,
                  "startColumn": 3,
                  "endLine": 1541,
                  "endColumn": 61,
                  "charOffset": 45472,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(props2, props, sizeof(struct kfd_iolink_properties)",
                    "rendered": {
                      "text": "memcpy(props2, props, sizeof(struct kfd_iolink_properties)",
                      "markdown": "`memcpy(props2, props, sizeof(struct kfd_iolink_properties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45472,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(props2, <size of props2>,  props,  sizeof(struct kfd_iolink_properties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a963e442-f1de-47b2-9c2a-617ee7090f37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 2262,
                  "startColumn": 1,
                  "endLine": 2263,
                  "endColumn": 32,
                  "charOffset": 64516,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)",
                    "rendered": {
                      "text": "memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)",
                      "markdown": "`memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64516,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&crat_table->signature, <size of &crat_table->signature>,  CRAT_SIGNATURE, \n\t\t\tsizeof(crat_table->signature)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d8d33233-1199-4c05-995b-68b854facbd5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                },
                "region": {
                  "startLine": 1519,
                  "startColumn": 2,
                  "endLine": 1519,
                  "endColumn": 62,
                  "charOffset": 44617,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(props, gpu_link, sizeof(struct kfd_iolink_properties)",
                    "rendered": {
                      "text": "memcpy(props, gpu_link, sizeof(struct kfd_iolink_properties)",
                      "markdown": "`memcpy(props, gpu_link, sizeof(struct kfd_iolink_properties)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44617,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(props, <size of props>,  gpu_link,  sizeof(struct kfd_iolink_properties)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b7668c83-c424-447c-8293-a995c52e6797",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1918,
                  "startColumn": 1,
                  "endLine": 1918,
                  "endColumn": 68,
                  "charOffset": 53813,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(crat_table->oem_table_id, \"UNAVAIL\", CRAT_OEMTABLEID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(crat_table->oem_table_id, \"UNAVAIL\", CRAT_OEMTABLEID_LENGTH)",
                      "markdown": "`memcpy(crat_table->oem_table_id, \"UNAVAIL\", CRAT_OEMTABLEID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53813,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(crat_table->oem_table_id, <size of crat_table->oem_table_id>,  \"UNAVAIL\",  CRAT_OEMTABLEID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7a42344f-6488-4929-8e52-07850af257a9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1917,
                  "startColumn": 1,
                  "endLine": 1917,
                  "endColumn": 53,
                  "charOffset": 53758,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(crat_table->oem_id, \"INV\", CRAT_OEMID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(crat_table->oem_id, \"INV\", CRAT_OEMID_LENGTH)",
                      "markdown": "`memcpy(crat_table->oem_id, \"INV\", CRAT_OEMID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53758,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(crat_table->oem_id, <size of crat_table->oem_id>,  \"INV\",  CRAT_OEMID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-473b47a8-5569-4b50-961b-7d10b03b28b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1909,
                  "startColumn": 2,
                  "endLine": 1910,
                  "endColumn": 22,
                  "charOffset": 53526,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(crat_table->oem_id, acpi_table->oem_id,\n\t\t\t\tCRAT_OEMID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(crat_table->oem_id, acpi_table->oem_id,\n\t\t\t\tCRAT_OEMID_LENGTH)",
                      "markdown": "`memcpy(crat_table->oem_id, acpi_table->oem_id,\n\t\t\t\tCRAT_OEMID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53526,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(crat_table->oem_id, <size of crat_table->oem_id>,  acpi_table->oem_id, \n\t\t\t\tCRAT_OEMID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7baf6913-965c-4a13-98dd-37266c2c7be0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1911,
                  "startColumn": 2,
                  "endLine": 1912,
                  "endColumn": 27,
                  "charOffset": 53599,
                  "charLength": 86,
                  "snippet": {
                    "text": "memcpy(crat_table->oem_table_id, acpi_table->oem_table_id,\n\t\t\t\tCRAT_OEMTABLEID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(crat_table->oem_table_id, acpi_table->oem_table_id,\n\t\t\t\tCRAT_OEMTABLEID_LENGTH)",
                      "markdown": "`memcpy(crat_table->oem_table_id, acpi_table->oem_table_id,\n\t\t\t\tCRAT_OEMTABLEID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53599,
                        "charLength": 86
                      },
                      "insertedContent": {
                        "text": "memcpy_s(crat_table->oem_table_id, <size of crat_table->oem_table_id>,  acpi_table->oem_table_id, \n\t\t\t\tCRAT_OEMTABLEID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe3d0295-e588-447f-9401-32c15b6a0d2a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1899,
                  "startColumn": 1,
                  "endLine": 1900,
                  "endColumn": 32,
                  "charOffset": 53184,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)",
                    "rendered": {
                      "text": "memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)",
                      "markdown": "`memcpy(&crat_table->signature, CRAT_SIGNATURE,\n\t\t\tsizeof(crat_table->signature)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53184,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&crat_table->signature, <size of &crat_table->signature>,  CRAT_SIGNATURE, \n\t\t\tsizeof(crat_table->signature)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-61aefc79-5e72-4828-bd8d-6ce645fa0bb8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1400,
                  "startColumn": 1,
                  "endLine": 1401,
                  "endColumn": 26,
                  "charOffset": 37030,
                  "charLength": 82,
                  "snippet": {
                    "text": "memcpy(top_dev->oem_table_id, crat_table->oem_table_id,\n\t\t\tCRAT_OEMTABLEID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(top_dev->oem_table_id, crat_table->oem_table_id,\n\t\t\tCRAT_OEMTABLEID_LENGTH)",
                      "markdown": "`memcpy(top_dev->oem_table_id, crat_table->oem_table_id,\n\t\t\tCRAT_OEMTABLEID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37030,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "memcpy_s(top_dev->oem_table_id, <size of top_dev->oem_table_id>,  crat_table->oem_table_id, \n\t\t\tCRAT_OEMTABLEID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f58082a3-5c3e-4f3c-b543-a6ce6e18ff70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1399,
                  "startColumn": 1,
                  "endLine": 1399,
                  "endColumn": 63,
                  "charOffset": 36965,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(top_dev->oem_id, crat_table->oem_id, CRAT_OEMID_LENGTH)",
                    "rendered": {
                      "text": "memcpy(top_dev->oem_id, crat_table->oem_id, CRAT_OEMID_LENGTH)",
                      "markdown": "`memcpy(top_dev->oem_id, crat_table->oem_id, CRAT_OEMID_LENGTH)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36965,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(top_dev->oem_id, <size of top_dev->oem_id>,  crat_table->oem_id,  CRAT_OEMID_LENGTH)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cffd3aca-2a9a-40e8-ba18-127897cced2f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 3,
                  "endLine": 1203,
                  "endColumn": 26,
                  "charOffset": 30935,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(props->sibling_map, cache->sibling_map,\n\t\t\t\t\tCRAT_SIBLINGMAP_SIZE)",
                    "rendered": {
                      "text": "memcpy(props->sibling_map, cache->sibling_map,\n\t\t\t\t\tCRAT_SIBLINGMAP_SIZE)",
                      "markdown": "`memcpy(props->sibling_map, cache->sibling_map,\n\t\t\t\t\tCRAT_SIBLINGMAP_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_crat.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30935,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(props->sibling_map, <size of props->sibling_map>,  cache->sibling_map, \n\t\t\t\t\tCRAT_SIBLINGMAP_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c92b6d3-4777-4094-ba49-7229ff6b1d06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_chardev.c"
                },
                "region": {
                  "startLine": 2140,
                  "startColumn": 4,
                  "endLine": 2142,
                  "endColumn": 49,
                  "charOffset": 55189,
                  "charLength": 126,
                  "snippet": {
                    "text": "memcpy(bo_priv->ipc_share_handle,\n\t\t\t\t       kgd_mem->ipc_obj->share_handle,\n\t\t\t\t       sizeof(kgd_mem->ipc_obj->share_handle)",
                    "rendered": {
                      "text": "memcpy(bo_priv->ipc_share_handle,\n\t\t\t\t       kgd_mem->ipc_obj->share_handle,\n\t\t\t\t       sizeof(kgd_mem->ipc_obj->share_handle)",
                      "markdown": "`memcpy(bo_priv->ipc_share_handle,\n\t\t\t\t       kgd_mem->ipc_obj->share_handle,\n\t\t\t\t       sizeof(kgd_mem->ipc_obj->share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_chardev.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55189,
                        "charLength": 126
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bo_priv->ipc_share_handle, <size of bo_priv->ipc_share_handle>, \n\t\t\t\t       kgd_mem->ipc_obj->share_handle, \n\t\t\t\t       sizeof(kgd_mem->ipc_obj->share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a8e0c8ec-f73f-4099-9088-46078d05b06c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_smi_events.c"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 8,
                  "endLine": 213,
                  "endColumn": 17,
                  "charOffset": 5710,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4f855db4-3e7d-4e34-a5eb-c23758f7cf85",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 583,
                  "startColumn": 1,
                  "endLine": 583,
                  "endColumn": 30,
                  "charOffset": 18487,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18487,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e796f59d-6f24-46c9-85a6-b6beb1685165",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 568,
                  "startColumn": 1,
                  "endLine": 568,
                  "endColumn": 46,
                  "charOffset": 18056,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct v9_sdma_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct v9_sdma_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct v9_sdma_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18056,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct v9_sdma_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3dc6389c-82f7-4efe-9445-2d2c2501aa52",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 469,
                  "startColumn": 1,
                  "endLine": 469,
                  "endColumn": 49,
                  "charOffset": 15403,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(ctl_stack, ctl_stack_src, ctl_stack_size)",
                    "rendered": {
                      "text": "memcpy(ctl_stack, ctl_stack_src, ctl_stack_size)",
                      "markdown": "`memcpy(ctl_stack, ctl_stack_src, ctl_stack_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15403,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ctl_stack, <size of ctl_stack>,  ctl_stack_src,  ctl_stack_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-587b115f-1da9-4bc7-8605-8bbba918876b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 461,
                  "startColumn": 1,
                  "endLine": 461,
                  "endColumn": 30,
                  "charOffset": 15216,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15216,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6bac01ef-9156-4967-9564-66480ade6e9e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 445,
                  "startColumn": 1,
                  "endLine": 445,
                  "endColumn": 60,
                  "charOffset": 14795,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(ctl_stack_dst, ctl_stack, m->cp_hqd_cntl_stack_size)",
                    "rendered": {
                      "text": "memcpy(ctl_stack_dst, ctl_stack, m->cp_hqd_cntl_stack_size)",
                      "markdown": "`memcpy(ctl_stack_dst, ctl_stack, m->cp_hqd_cntl_stack_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14795,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ctl_stack_dst, <size of ctl_stack_dst>,  ctl_stack,  m->cp_hqd_cntl_stack_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cd6ede36-f91c-40f9-81a3-b98024e187d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                },
                "region": {
                  "startLine": 444,
                  "startColumn": 1,
                  "endLine": 444,
                  "endColumn": 41,
                  "charOffset": 14751,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct v9_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct v9_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct v9_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14751,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct v9_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e2f506e1-a5ee-42cc-b3e7-896d67cb4fa1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 1,
                  "endLine": 339,
                  "endColumn": 30,
                  "charOffset": 9877,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9877,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-924efad7-5bca-4545-b9b0-dd0837fca7d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 1,
                  "endLine": 324,
                  "endColumn": 57,
                  "charOffset": 9429,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct cik_sdma_rlc_registers)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct cik_sdma_rlc_registers)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct cik_sdma_rlc_registers)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9429,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct cik_sdma_rlc_registers)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-555dad8b-a4bf-45c4-a386-7b8109e94152",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 1,
                  "endLine": 301,
                  "endColumn": 30,
                  "charOffset": 8993,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8993,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc92e64e-0ec2-4cd1-9aa0-4e5b9194f3e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 1,
                  "endLine": 286,
                  "endColumn": 42,
                  "charOffset": 8599,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct cik_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct cik_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct cik_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_cik.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8599,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct cik_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a9c313f1-3077-43fe-a4fa-635a85a28886",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                },
                "region": {
                  "startLine": 4198,
                  "startColumn": 2,
                  "endLine": 4198,
                  "endColumn": 55,
                  "charOffset": 119004,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&svm_priv->attrs, query_attr, query_attr_size)",
                    "rendered": {
                      "text": "memcpy(&svm_priv->attrs, query_attr, query_attr_size)",
                      "markdown": "`memcpy(&svm_priv->attrs, query_attr, query_attr_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 119004,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&svm_priv->attrs, <size of &svm_priv->attrs>,  query_attr,  query_attr_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-70a9f340-b904-41df-a3c1-b5660799280e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                },
                "region": {
                  "startLine": 3999,
                  "startColumn": 2,
                  "endLine": 4000,
                  "endColumn": 43,
                  "charOffset": 113415,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy(set_attr, criu_svm_md->data.attrs, num_attrs *\n\t\t\t\t\tsizeof(struct kfd_ioctl_svm_attribute)",
                    "rendered": {
                      "text": "memcpy(set_attr, criu_svm_md->data.attrs, num_attrs *\n\t\t\t\t\tsizeof(struct kfd_ioctl_svm_attribute)",
                      "markdown": "`memcpy(set_attr, criu_svm_md->data.attrs, num_attrs *\n\t\t\t\t\tsizeof(struct kfd_ioctl_svm_attribute)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 113415,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s(set_attr, <size of set_attr>,  criu_svm_md->data.attrs,  num_attrs *\n\t\t\t\t\tsizeof(struct kfd_ioctl_svm_attribute)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dba6477d-1c3d-40d0-ae2f-2e42bcf2c49d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                },
                "region": {
                  "startLine": 923,
                  "startColumn": 2,
                  "endLine": 923,
                  "endColumn": 39,
                  "charOffset": 25658,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(dst, src, num_elements * size)",
                    "rendered": {
                      "text": "memcpy(dst, src, num_elements * size)",
                      "markdown": "`memcpy(dst, src, num_elements * size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_svm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25658,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  num_elements * size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c997064-c791-4669-9832-622c39037c81",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_ipc.c"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 1,
                  "endLine": 271,
                  "endColumn": 37,
                  "charOffset": 7075,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(ipc_handle, ipc_obj->share_handle,\n\t       sizeof(ipc_obj->share_handle)",
                    "rendered": {
                      "text": "memcpy(ipc_handle, ipc_obj->share_handle,\n\t       sizeof(ipc_obj->share_handle)",
                      "markdown": "`memcpy(ipc_handle, ipc_obj->share_handle,\n\t       sizeof(ipc_obj->share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_ipc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7075,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ipc_handle, <size of ipc_handle>,  ipc_obj->share_handle, \n\t       sizeof(ipc_obj->share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-60568e52-3d4b-40c7-882d-166544446796",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_ipc.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 2,
                  "endLine": 54,
                  "endColumn": 69,
                  "charOffset": 2063,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(obj->share_handle, restore_handle, sizeof(obj->share_handle)",
                    "rendered": {
                      "text": "memcpy(obj->share_handle, restore_handle, sizeof(obj->share_handle)",
                      "markdown": "`memcpy(obj->share_handle, restore_handle, sizeof(obj->share_handle)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_ipc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2063,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(obj->share_handle, <size of obj->share_handle>,  restore_handle,  sizeof(obj->share_handle)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-444f2c03-98d5-499e-bd4b-a58b7adc66db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_device.c"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 16,
                  "endLine": 24,
                  "endColumn": 23,
                  "charOffset": 1199,
                  "charLength": 7,
                  "snippet": {
                    "text": "bsearch",
                    "rendered": {
                      "text": "bsearch",
                      "markdown": "`bsearch`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-717b33fc-09d1-4cfe-8ff3-96ea9fbbb166",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                },
                "region": {
                  "startLine": 427,
                  "startColumn": 1,
                  "endLine": 427,
                  "endColumn": 30,
                  "charOffset": 13110,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13110,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a336970d-2003-4709-85be-b05a91f81c8f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                },
                "region": {
                  "startLine": 411,
                  "startColumn": 1,
                  "endLine": 411,
                  "endColumn": 47,
                  "charOffset": 12668,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct v10_sdma_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct v10_sdma_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct v10_sdma_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12668,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct v10_sdma_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef07b3bc-9b53-485e-b3e3-22dc403f6714",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 1,
                  "endLine": 292,
                  "endColumn": 50,
                  "charOffset": 9527,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct v10_compute_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct v10_compute_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct v10_compute_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9527,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct v10_compute_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aeade182-e086-441b-85ab-217ecf8899b2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 1,
                  "endLine": 307,
                  "endColumn": 30,
                  "charOffset": 9945,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_v10.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9945,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1f2bc7c3-59bd-4f9b-a439-5aabac259d12",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 2,
                  "endLine": 308,
                  "endColumn": 45,
                  "charOffset": 11718,
                  "charLength": 81,
                  "snippet": {
                    "text": "memcpy(patched_ihre, ih_ring_entry,\n\t\t\t\tdev->kfd->device_info.ih_ring_entry_size)",
                    "rendered": {
                      "text": "memcpy(patched_ihre, ih_ring_entry,\n\t\t\t\tdev->kfd->device_info.ih_ring_entry_size)",
                      "markdown": "`memcpy(patched_ihre, ih_ring_entry,\n\t\t\t\tdev->kfd->device_info.ih_ring_entry_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_int_process_v9.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11718,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "memcpy_s(patched_ihre, <size of patched_ihre>,  ih_ring_entry, \n\t\t\t\tdev->kfd->device_info.ih_ring_entry_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3162d135-c134-40ec-959d-032d417c5b1e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                },
                "region": {
                  "startLine": 634,
                  "startColumn": 1,
                  "endLine": 634,
                  "endColumn": 8,
                  "charOffset": 22986,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-93766537-c90a-426f-9c93-e398d744762a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 1,
                  "endLine": 590,
                  "endColumn": 8,
                  "charOffset": 21460,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a12a293-09fa-45a5-ba0a-0a28b9346101",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                },
                "region": {
                  "startLine": 1561,
                  "startColumn": 1,
                  "endLine": 1561,
                  "endColumn": 50,
                  "charOffset": 48634,
                  "charLength": 49,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"xgmi_wafl\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"xgmi_wafl\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"xgmi_wafl\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48634,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"xgmi_wafl\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48634,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"xgmi_wafl\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-63c91ec6-ced4-471c-9de3-fa6f98b3af47",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 2,
                  "endLine": 458,
                  "endColumn": 9,
                  "charOffset": 17269,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-518f943d-39b5-41e7-8ee6-cfa2f3b8daa1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                },
                "region": {
                  "startLine": 461,
                  "startColumn": 1,
                  "endLine": 461,
                  "endColumn": 30,
                  "charOffset": 14046,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14046,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d24b3727-5db4-4d3e-8ea7-5940e0e1fd9f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 2,
                  "endLine": 443,
                  "endColumn": 9,
                  "charOffset": 16837,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2059893d-7bec-4f76-b19f-f78c940b0cd3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                },
                "region": {
                  "startLine": 446,
                  "startColumn": 1,
                  "endLine": 446,
                  "endColumn": 46,
                  "charOffset": 13615,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct vi_sdma_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13615,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct vi_sdma_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d569a517-7603-4272-b521-c0a171146fd4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                },
                "region": {
                  "startLine": 356,
                  "startColumn": 1,
                  "endLine": 356,
                  "endColumn": 30,
                  "charOffset": 11276,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(m, mqd_src, sizeof(*m)",
                    "rendered": {
                      "text": "memcpy(m, mqd_src, sizeof(*m)",
                      "markdown": "`memcpy(m, mqd_src, sizeof(*m)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11276,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m, <size of m>,  mqd_src,  sizeof(*m)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ec3c8d7-1ea3-4fc5-986b-1f10de99d4f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                },
                "region": {
                  "startLine": 341,
                  "startColumn": 1,
                  "endLine": 341,
                  "endColumn": 41,
                  "charOffset": 10885,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(mqd_dst, m, sizeof(struct vi_mqd)",
                    "rendered": {
                      "text": "memcpy(mqd_dst, m, sizeof(struct vi_mqd)",
                      "markdown": "`memcpy(mqd_dst, m, sizeof(struct vi_mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkfd/kfd_mqd_manager_vi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10885,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd_dst, <size of mqd_dst>,  m,  sizeof(struct vi_mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5d92a5de-ea1a-4461-b493-39163284e50b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 3613,
                  "startColumn": 1,
                  "endLine": 3613,
                  "endColumn": 28,
                  "charOffset": 103331,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(buf_cpy, buf, count)",
                    "rendered": {
                      "text": "memcpy(buf_cpy, buf, count)",
                      "markdown": "`memcpy(buf_cpy, buf, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 103331,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf_cpy, <size of buf_cpy>,  buf,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-707b5e0f-25b8-4d6e-b9de-da0d95684918",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 2170,
                  "startColumn": 7,
                  "endLine": 2170,
                  "endColumn": 20,
                  "charOffset": 58736,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(param)",
                    "rendered": {
                      "text": "strlen(param)",
                      "markdown": "`strlen(param)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58736,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(param, <size of param>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58736,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(param, <size of param>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a7c07600-542f-4c6c-aa2b-5e7bf53eca8f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 3634,
                  "startColumn": 6,
                  "endLine": 3634,
                  "endColumn": 21,
                  "charOffset": 103733,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(sub_str)",
                    "rendered": {
                      "text": "strlen(sub_str)",
                      "markdown": "`strlen(sub_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 103733,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 103733,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9aeb62b6-7257-4160-b113-0f1a55f59121",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 1770,
                  "startColumn": 1,
                  "endLine": 1770,
                  "endColumn": 31,
                  "charOffset": 46557,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(buf, gpu_metrics, size)",
                    "rendered": {
                      "text": "memcpy(buf, gpu_metrics, size)",
                      "markdown": "`memcpy(buf, gpu_metrics, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46557,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  gpu_metrics,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f88ae71-bb14-44ee-8291-422af3e18908",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 2164,
                  "startColumn": 1,
                  "endLine": 2164,
                  "endColumn": 28,
                  "charOffset": 58585,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(tmp_buf, buf, count)",
                    "rendered": {
                      "text": "memcpy(tmp_buf, buf, count)",
                      "markdown": "`memcpy(tmp_buf, buf, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58585,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp_buf, <size of tmp_buf>,  buf,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-222c0993-ff2f-42b9-be70-abda9d12c255",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 1388,
                  "startColumn": 2,
                  "endLine": 1388,
                  "endColumn": 31,
                  "charOffset": 36272,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(buf_cpy, buf, count-i)",
                    "rendered": {
                      "text": "memcpy(buf_cpy, buf, count-i)",
                      "markdown": "`memcpy(buf_cpy, buf, count-i)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36272,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf_cpy, <size of buf_cpy>,  buf,  count-i)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-608e1af4-364f-455a-bb08-a106f66f2b70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 1391,
                  "startColumn": 7,
                  "endLine": 1391,
                  "endColumn": 22,
                  "charOffset": 36391,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(sub_str)",
                    "rendered": {
                      "text": "strlen(sub_str)",
                      "markdown": "`strlen(sub_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36391,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36391,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b632a3aa-507b-42bb-89cb-71bd56f2ea54",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 1035,
                  "startColumn": 6,
                  "endLine": 1035,
                  "endColumn": 21,
                  "charOffset": 28242,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(sub_str)",
                    "rendered": {
                      "text": "strlen(sub_str)",
                      "markdown": "`strlen(sub_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28242,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28242,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17122d14-321b-451e-8a03-3f7882c08ca7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 1031,
                  "startColumn": 1,
                  "endLine": 1031,
                  "endColumn": 28,
                  "charOffset": 28112,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(buf_cpy, buf, bytes)",
                    "rendered": {
                      "text": "memcpy(buf_cpy, buf, bytes)",
                      "markdown": "`memcpy(buf_cpy, buf, bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28112,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf_cpy, <size of buf_cpy>,  buf,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a0bb27bc-5889-42d3-afd9-02ac41884518",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 793,
                  "startColumn": 6,
                  "endLine": 793,
                  "endColumn": 21,
                  "charOffset": 22344,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(sub_str)",
                    "rendered": {
                      "text": "strlen(sub_str)",
                      "markdown": "`strlen(sub_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22344,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22344,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(sub_str, <size of sub_str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a645787b-2435-475a-b37f-22f5d352b7b5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 782,
                  "startColumn": 1,
                  "endLine": 782,
                  "endColumn": 28,
                  "charOffset": 22081,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(buf_cpy, buf, count)",
                    "rendered": {
                      "text": "memcpy(buf_cpy, buf, count)",
                      "markdown": "`memcpy(buf_cpy, buf, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22081,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf_cpy, <size of buf_cpy>,  buf,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-063f1d24-9b26-4807-99f4-7e22c989b80b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 573,
                  "startColumn": 1,
                  "endLine": 573,
                  "endColumn": 25,
                  "charOffset": 15809,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(buf, table, size)",
                    "rendered": {
                      "text": "memcpy(buf, table, size)",
                      "markdown": "`memcpy(buf, table, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15809,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  table,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-68f729bd-c963-413b-bbf0-d2c9fa458515",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 5,
                  "endLine": 499,
                  "endColumn": 16,
                  "charOffset": 14259,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(buf)",
                    "rendered": {
                      "text": "strlen(buf)",
                      "markdown": "`strlen(buf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14259,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14259,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(buf, <size of buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b0d696ca-836b-4501-ab8d-cae30debcba3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 45,
                  "endLine": 383,
                  "endColumn": 71,
                  "charOffset": 11417,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(\"perf_determinism\")",
                    "rendered": {
                      "text": "strlen(\"perf_determinism\")",
                      "markdown": "`strlen(\"perf_determinism\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11417,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"perf_determinism\", <size of \"perf_determinism\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11417,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(\"perf_determinism\", <size of \"perf_determinism\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-57808391-a2e9-4c5f-bcf7-d9f7e9140fb1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 381,
                  "startColumn": 41,
                  "endLine": 381,
                  "endColumn": 63,
                  "charOffset": 11295,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(\"profile_peak\")",
                    "rendered": {
                      "text": "strlen(\"profile_peak\")",
                      "markdown": "`strlen(\"profile_peak\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11295,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"profile_peak\", <size of \"profile_peak\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11295,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(\"profile_peak\", <size of \"profile_peak\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7f831fe6-7ded-44ce-a916-438d5363e8a2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 45,
                  "endLine": 379,
                  "endColumn": 71,
                  "charOffset": 11169,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(\"profile_min_mclk\")",
                    "rendered": {
                      "text": "strlen(\"profile_min_mclk\")",
                      "markdown": "`strlen(\"profile_min_mclk\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11169,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"profile_min_mclk\", <size of \"profile_min_mclk\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11169,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(\"profile_min_mclk\", <size of \"profile_min_mclk\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee9dcd36-a564-4eb0-b73a-fa9308a65918",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 377,
                  "startColumn": 45,
                  "endLine": 377,
                  "endColumn": 71,
                  "charOffset": 11039,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(\"profile_min_sclk\")",
                    "rendered": {
                      "text": "strlen(\"profile_min_sclk\")",
                      "markdown": "`strlen(\"profile_min_sclk\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11039,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"profile_min_sclk\", <size of \"profile_min_sclk\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11039,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(\"profile_min_sclk\", <size of \"profile_min_sclk\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bed47c6e-d737-48a7-aedf-1ffd1ac528a0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 375,
                  "startColumn": 45,
                  "endLine": 375,
                  "endColumn": 71,
                  "charOffset": 10909,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(\"profile_standard\")",
                    "rendered": {
                      "text": "strlen(\"profile_standard\")",
                      "markdown": "`strlen(\"profile_standard\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10909,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"profile_standard\", <size of \"profile_standard\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10909,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(\"profile_standard\", <size of \"profile_standard\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f4050e39-7669-4355-910f-2679d3ec90e2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                },
                "region": {
                  "startLine": 373,
                  "startColumn": 41,
                  "endLine": 373,
                  "endColumn": 63,
                  "charOffset": 10787,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(\"profile_exit\")",
                    "rendered": {
                      "text": "strlen(\"profile_exit\")",
                      "markdown": "`strlen(\"profile_exit\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10787,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"profile_exit\", <size of \"profile_exit\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/amdgpu_pm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10787,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(\"profile_exit\", <size of \"profile_exit\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4e399d7-1ba5-47ad-b536-02b4e935b1a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0_4.c"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 1,
                  "endLine": 176,
                  "endColumn": 66,
                  "charOffset": 4993,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0_4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4993,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  psp->sos.start_addr,  psp->sos.size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a4369c1-bdff-4aa6-931d-915a93a38122",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0_4.c"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 1,
                  "endLine": 113,
                  "endColumn": 68,
                  "charOffset": 3163,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0_4.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3163,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  bin_desc->start_addr,  bin_desc->size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4506267d-cae4-4b85-b010-777c22aeb46f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v3_1.c"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 1,
                  "endLine": 576,
                  "endColumn": 27,
                  "charOffset": 14376,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(&ucode_len, ptr, 4)",
                    "rendered": {
                      "text": "memcpy(&ucode_len, ptr, 4)",
                      "markdown": "`memcpy(&ucode_len, ptr, 4)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v3_1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14376,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ucode_len, <size of &ucode_len>,  ptr,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eec6c410-de01-4986-9173-826bd64212ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v3_1.c"
                },
                "region": {
                  "startLine": 578,
                  "startColumn": 1,
                  "endLine": 578,
                  "endColumn": 37,
                  "charOffset": 14424,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&adev->uvd.keyselect, ptr, 4)",
                    "rendered": {
                      "text": "memcpy(&adev->uvd.keyselect, ptr, 4)",
                      "markdown": "`memcpy(&adev->uvd.keyselect, ptr, 4)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v3_1.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14424,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&adev->uvd.keyselect, <size of &adev->uvd.keyselect>,  ptr,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8b8ba2b3-d2e9-4a5d-a885-28718a56d5f1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v3_1.c"
                },
                "region": {
                  "startLine": 563,
                  "startColumn": 1,
                  "endLine": 563,
                  "endColumn": 8,
                  "charOffset": 14082,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d5e06a9-a442-4f25-99e3-3741b6ac2f03",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c"
                },
                "region": {
                  "startLine": 282,
                  "startColumn": 1,
                  "endLine": 282,
                  "endColumn": 61,
                  "charOffset": 7321,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length)",
                    "rendered": {
                      "text": "memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length)",
                      "markdown": "`memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7321,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bios+offset, <size of bios+offset>,  obj->buffer.pointer,  obj->buffer.length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd1cdb61-dd6e-42ae-9fdf-71f6bb545dc3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 9,
                  "endLine": 182,
                  "endColumn": 36,
                  "charOffset": 4986,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(AMD_VBIOS_SIGNATURE)",
                    "rendered": {
                      "text": "strlen(AMD_VBIOS_SIGNATURE)",
                      "markdown": "`strlen(AMD_VBIOS_SIGNATURE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4986,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(AMD_VBIOS_SIGNATURE, <size of AMD_VBIOS_SIGNATURE>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_bios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4986,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(AMD_VBIOS_SIGNATURE, <size of AMD_VBIOS_SIGNATURE>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-50047a21-9159-4d64-97e7-ad1df1b98702",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v14_0.c"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 1,
                  "endLine": 220,
                  "endColumn": 66,
                  "charOffset": 6360,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v14_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6360,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  psp->sos.start_addr,  psp->sos.size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9291667a-6079-41ef-beff-c0ffcb219ea4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v14_0.c"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 1,
                  "endLine": 146,
                  "endColumn": 68,
                  "charOffset": 4172,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v14_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4172,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  bin_desc->start_addr,  bin_desc->size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3c7109f2-f6fa-4188-90b7-891a87a75f97",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v5_0.c"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 1,
                  "endLine": 118,
                  "endColumn": 8,
                  "charOffset": 3486,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9ed45fc1-aa79-42ec-a5f5-b23a97508fad",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 2,
                  "endLine": 185,
                  "endColumn": 9,
                  "charOffset": 6509,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-18d2fd25-066d-4c5e-94f3-b82b42538547",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v1_0.c"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 1,
                  "endLine": 163,
                  "endColumn": 8,
                  "charOffset": 5605,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-224c0eee-6f75-4f29-a28c-6f84e942b6be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
                },
                "region": {
                  "startLine": 937,
                  "startColumn": 2,
                  "endLine": 937,
                  "endColumn": 68,
                  "charOffset": 28886,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                      "markdown": "`memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28886,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  &end,  sizeof(struct mmsch_v1_0_cmd_end)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d44feef2-1caa-42fd-9c2a-68b99edf91a1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
                },
                "region": {
                  "startLine": 459,
                  "startColumn": 3,
                  "endLine": 459,
                  "endColumn": 10,
                  "charOffset": 12460,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-836a33c2-8da7-4acc-8c0f-363e4b2e2baf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c"
                },
                "region": {
                  "startLine": 448,
                  "startColumn": 3,
                  "endLine": 448,
                  "endColumn": 10,
                  "charOffset": 12138,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5078ec85-3552-4875-86dd-b803a0aeb0ed",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 1,
                  "endLine": 223,
                  "endColumn": 46,
                  "charOffset": 6118,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(&bank_error->info, info, sizeof(*info)",
                    "rendered": {
                      "text": "memcpy(&bank_error->info, info, sizeof(*info)",
                      "markdown": "`memcpy(&bank_error->info, info, sizeof(*info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6118,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&bank_error->info, <size of &bank_error->info>,  info,  sizeof(*info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d0bcb039-3d94-483e-8592-a9458cb0c240",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 1,
                  "endLine": 59,
                  "endColumn": 40,
                  "charOffset": 1970,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(&node->bank, bank, sizeof(*bank)",
                    "rendered": {
                      "text": "memcpy(&node->bank, bank, sizeof(*bank)",
                      "markdown": "`memcpy(&node->bank, bank, sizeof(*bank)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_aca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1970,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&node->bank, <size of &node->bank>,  bank,  sizeof(*bank)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ab481ce3-eb1d-4af2-b4e5-87caa861a371",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.c"
                },
                "region": {
                  "startLine": 1395,
                  "startColumn": 1,
                  "endLine": 1395,
                  "endColumn": 8,
                  "charOffset": 38312,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd6fd510-4300-44c5-9ddb-b3ac519a0b53",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.c"
                },
                "region": {
                  "startLine": 1270,
                  "startColumn": 1,
                  "endLine": 1270,
                  "endColumn": 44,
                  "charOffset": 35098,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"vcn\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"vcn\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"vcn\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35098,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"vcn\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35098,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"vcn\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b4a2bdda-b50b-4f67-9415-1ea4699dd0de",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_vcn.c"
                },
                "region": {
                  "startLine": 1173,
                  "startColumn": 1,
                  "endLine": 1173,
                  "endColumn": 8,
                  "charOffset": 32494,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d29c86b0-2c42-4c16-939b-e1cdb9fef98c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_display.c"
                },
                "region": {
                  "startLine": 1524,
                  "startColumn": 2,
                  "endLine": 1526,
                  "endColumn": 40,
                  "charOffset": 46765,
                  "charLength": 113,
                  "snippet": {
                    "text": "memcpy(&amdgpu_crtc->native_mode,\n\t\t       &amdgpu_encoder->native_mode,\n\t\t       sizeof(struct drm_display_mode)",
                    "rendered": {
                      "text": "memcpy(&amdgpu_crtc->native_mode,\n\t\t       &amdgpu_encoder->native_mode,\n\t\t       sizeof(struct drm_display_mode)",
                      "markdown": "`memcpy(&amdgpu_crtc->native_mode,\n\t\t       &amdgpu_encoder->native_mode,\n\t\t       sizeof(struct drm_display_mode)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_display.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46765,
                        "charLength": 113
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&amdgpu_crtc->native_mode, <size of &amdgpu_crtc->native_mode>, \n\t\t       &amdgpu_encoder->native_mode, \n\t\t       sizeof(struct drm_display_mode)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9995ea7e-685f-44d0-9b2f-c464b6305049",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v3_0.c"
                },
                "region": {
                  "startLine": 1485,
                  "startColumn": 1,
                  "endLine": 1485,
                  "endColumn": 41,
                  "charOffset": 52369,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &header, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &header, size)",
                      "markdown": "`memcpy((void *)table_loc, &header, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v3_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52369,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &header,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-872287d3-28f1-4c99-ad50-073d8b299d48",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v3_0.c"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 3,
                  "endLine": 256,
                  "endColumn": 10,
                  "charOffset": 9416,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c721a3a-58c9-48a5-be98-add7172406bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v3_0.c"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 2,
                  "endLine": 232,
                  "endColumn": 9,
                  "charOffset": 8563,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fbbd5d40-f8e3-442c-9160-facf4174c7f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0_3.c"
                },
                "region": {
                  "startLine": 1066,
                  "startColumn": 2,
                  "endLine": 1066,
                  "endColumn": 42,
                  "charOffset": 35701,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &header, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &header, size)",
                      "markdown": "`memcpy((void *)table_loc, &header, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35701,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &header,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7e1ade39-04d4-483d-99b5-716ed4c43830",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0_3.c"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 2,
                  "endLine": 186,
                  "endColumn": 9,
                  "charOffset": 6374,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fdf90da2-a432-4ba6-8017-3fc7a7025a69",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5642,
                  "startColumn": 2,
                  "endLine": 5643,
                  "endColumn": 38,
                  "charOffset": 197382,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[offset], de_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[offset], de_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)",
                      "markdown": "`memcpy((void *)&ring->ring[offset], de_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 197382,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[offset], <size of (void *)&ring->ring[offset]>,  de_payload_cpu_addr, \n\t\t       (ring->buf_mask + 1 - offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-73762bbe-1095-433f-b0cc-a0a0cfbe50c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5645,
                  "startColumn": 2,
                  "endLine": 5647,
                  "endColumn": 22,
                  "charOffset": 197541,
                  "charLength": 122,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[0],\n\t\t       de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[0],\n\t\t       de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)",
                      "markdown": "`memcpy((void *)&ring->ring[0],\n\t\t       de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 197541,
                        "charLength": 122
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[0], <size of (void *)&ring->ring[0]>, \n\t\t       de_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2), \n\t\t       payload_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b0027fa5-2d47-4f49-9bb5-55aeeec8d83b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5640,
                  "startColumn": 2,
                  "endLine": 5640,
                  "endColumn": 72,
                  "charOffset": 197298,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[offset], de_payload_cpu_addr, payload_size)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[offset], de_payload_cpu_addr, payload_size)",
                      "markdown": "`memcpy((void *)&ring->ring[offset], de_payload_cpu_addr, payload_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 197298,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[offset], <size of (void *)&ring->ring[offset]>,  de_payload_cpu_addr,  payload_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fbb0a9fd-b99f-4d9d-a763-3c0eae011801",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5610,
                  "startColumn": 2,
                  "endLine": 5612,
                  "endColumn": 22,
                  "charOffset": 196353,
                  "charLength": 122,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[0],\n\t\t       ce_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[0],\n\t\t       ce_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)",
                      "markdown": "`memcpy((void *)&ring->ring[0],\n\t\t       ce_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2),\n\t\t       payload_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 196353,
                        "charLength": 122
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[0], <size of (void *)&ring->ring[0]>, \n\t\t       ce_payload_cpu_addr + ((ring->buf_mask + 1 - offset) << 2), \n\t\t       payload_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3f990649-73d2-41c5-8adb-6ffd0ed84d4c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5607,
                  "startColumn": 2,
                  "endLine": 5608,
                  "endColumn": 38,
                  "charOffset": 196194,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)",
                      "markdown": "`memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr,\n\t\t       (ring->buf_mask + 1 - offset)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 196194,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[offset], <size of (void *)&ring->ring[offset]>,  ce_payload_cpu_addr, \n\t\t       (ring->buf_mask + 1 - offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-db70cfb4-a342-4fd9-b895-78bd2595182b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 5605,
                  "startColumn": 2,
                  "endLine": 5605,
                  "endColumn": 72,
                  "charOffset": 196110,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, payload_size)",
                    "rendered": {
                      "text": "memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, payload_size)",
                      "markdown": "`memcpy((void *)&ring->ring[offset], ce_payload_cpu_addr, payload_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 196110,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&ring->ring[offset], <size of (void *)&ring->ring[offset]>,  ce_payload_cpu_addr,  payload_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3eb3ab21-3b69-4127-bc2e-7d85e63ab3ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 3904,
                  "startColumn": 3,
                  "endLine": 3904,
                  "endColumn": 82,
                  "charOffset": 138568,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 138568,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.mec.mqd_backup[mqd_idx],  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-425824bc-fed6-4055-b12b-692d3c06c023",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 3900,
                  "startColumn": 3,
                  "endLine": 3900,
                  "endColumn": 82,
                  "charOffset": 138394,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 138394,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.mec.mqd_backup[mqd_idx], <size of adev->gfx.mec.mqd_backup[mqd_idx]>,  mqd,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af4e3255-21af-4579-91ef-faa1190d7391",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 3845,
                  "startColumn": 3,
                  "endLine": 3845,
                  "endColumn": 76,
                  "charOffset": 136399,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 136399,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.kiq[0].mqd_backup,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ff34503-55c3-40f8-b51e-d730b9b7f848",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 3870,
                  "startColumn": 3,
                  "endLine": 3870,
                  "endColumn": 76,
                  "charOffset": 137333,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 137333,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.kiq[0].mqd_backup, <size of adev->gfx.kiq[0].mqd_backup>,  mqd,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cf0e6f5c-2195-4fa8-9325-ac2b1c0a2bef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 2362,
                  "startColumn": 3,
                  "endLine": 2362,
                  "endColumn": 10,
                  "charOffset": 89259,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dea744cd-1fe7-445b-83f8-4908ccf8b934",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 2343,
                  "startColumn": 3,
                  "endLine": 2343,
                  "endColumn": 10,
                  "charOffset": 88648,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e6f87b02-08e1-4092-906a-1f78084d18aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 2341,
                  "startColumn": 3,
                  "endLine": 2341,
                  "endColumn": 10,
                  "charOffset": 88610,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d0a0b9b-9e5b-46ba-afd8-070bced93911",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 2171,
                  "startColumn": 1,
                  "endLine": 2171,
                  "endColumn": 8,
                  "charOffset": 83756,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-682dc8b4-f559-4ff6-8e74-16f500620300",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                },
                "region": {
                  "startLine": 1920,
                  "startColumn": 1,
                  "endLine": 1920,
                  "endColumn": 29,
                  "charOffset": 74891,
                  "charLength": 28,
                  "snippet": {
                    "text": "memcpy(fw, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(fw, fw_data, fw_size)",
                      "markdown": "`memcpy(fw, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74891,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw, <size of fw>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ecf6ac2-0c98-4f81-985d-d6ce1fa75a9b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_hdp.c"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 1,
                  "endLine": 41,
                  "endColumn": 44,
                  "charOffset": 1488,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"hdp\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"hdp\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"hdp\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_hdp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1488,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"hdp\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_hdp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1488,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"hdp\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c7129204-ae26-4fc7-be14-e161d6ca39cc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 1661,
                  "startColumn": 1,
                  "endLine": 1661,
                  "endColumn": 28,
                  "charOffset": 52137,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, num_bytes)",
                    "rendered": {
                      "text": "memcpy(dst, src, num_bytes)",
                      "markdown": "`memcpy(dst, src, num_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52137,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  num_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-783634d8-6593-41e6-b7d7-e46d417d6b27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 1658,
                  "startColumn": 2,
                  "endLine": 1658,
                  "endColumn": 33,
                  "charOffset": 52094,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(dst, dst_tmp, num_bytes)",
                    "rendered": {
                      "text": "memcpy(dst, dst_tmp, num_bytes)",
                      "markdown": "`memcpy(dst, dst_tmp, num_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52094,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  dst_tmp,  num_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8a862abe-de31-430a-af7d-5238b6613532",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 1655,
                  "startColumn": 2,
                  "endLine": 1655,
                  "endColumn": 39,
                  "charOffset": 51968,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(src_tmp, src, align_num_bytes)",
                    "rendered": {
                      "text": "memcpy(src_tmp, src, align_num_bytes)",
                      "markdown": "`memcpy(src_tmp, src, align_num_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51968,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(src_tmp, <size of src_tmp>,  src,  align_num_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a48f9404-c21a-4165-9a51-1fb81d1d0bf4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 1653,
                  "startColumn": 2,
                  "endLine": 1653,
                  "endColumn": 39,
                  "charOffset": 51917,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(dst, dst_tmp, align_num_bytes)",
                    "rendered": {
                      "text": "memcpy(dst, dst_tmp, align_num_bytes)",
                      "markdown": "`memcpy(dst, dst_tmp, align_num_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51917,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  dst_tmp,  align_num_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cca39259-af22-4a46-beda-0e640712105e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 4,
                  "endLine": 169,
                  "endColumn": 11,
                  "charOffset": 5626,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-06f6a495-37d1-4929-b157-b975af5dc305",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 1650,
                  "startColumn": 2,
                  "endLine": 1650,
                  "endColumn": 33,
                  "charOffset": 51797,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(src_tmp, src, num_bytes)",
                    "rendered": {
                      "text": "memcpy(src_tmp, src, num_bytes)",
                      "markdown": "`memcpy(src_tmp, src, num_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51797,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(src_tmp, <size of src_tmp>,  src,  num_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e874fd20-6b97-4cf5-849c-b81874c78247",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 4,
                  "endLine": 138,
                  "endColumn": 11,
                  "charOffset": 4620,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-48121354-a10f-48f7-8642-0b52c5dac1d6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 6874,
                  "startColumn": 4,
                  "endLine": 6874,
                  "endColumn": 11,
                  "charOffset": 236510,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9de5f3c0-66bd-4f3c-bcc9-5cefec3dbf44",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 6872,
                  "startColumn": 4,
                  "endLine": 6872,
                  "endColumn": 11,
                  "charOffset": 236463,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3db66a30-b005-49d8-8df9-49d0947de208",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 4668,
                  "startColumn": 3,
                  "endLine": 4668,
                  "endColumn": 82,
                  "charOffset": 171376,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct vi_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct vi_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct vi_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 171376,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.mec.mqd_backup[mqd_idx], <size of adev->gfx.mec.mqd_backup[mqd_idx]>,  mqd,  sizeof(struct vi_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07db58f0-ec4c-4a6d-8714-809e6e6a4779",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 4672,
                  "startColumn": 3,
                  "endLine": 4672,
                  "endColumn": 82,
                  "charOffset": 171550,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct vi_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct vi_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct vi_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 171550,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.mec.mqd_backup[mqd_idx],  sizeof(struct vi_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ac5463ff-be7c-4398-8423-e7705c323398",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 4645,
                  "startColumn": 3,
                  "endLine": 4645,
                  "endColumn": 76,
                  "charOffset": 170605,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct vi_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct vi_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.kiq[0].mqd_backup, mqd, sizeof(struct vi_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 170605,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.kiq[0].mqd_backup, <size of adev->gfx.kiq[0].mqd_backup>,  mqd,  sizeof(struct vi_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c722134-26d0-4d64-afa6-20174a76d480",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 4621,
                  "startColumn": 3,
                  "endLine": 4621,
                  "endColumn": 76,
                  "charOffset": 169700,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.kiq[0].mqd_backup, sizeof(struct vi_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 169700,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.kiq[0].mqd_backup,  sizeof(struct vi_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28bbafce-9303-450e-9e05-55732de53a5b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 2003,
                  "startColumn": 2,
                  "endLine": 2003,
                  "endColumn": 9,
                  "charOffset": 70238,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fa692c6f-7969-415c-958f-771601b2ccfc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v8_0.c"
                },
                "region": {
                  "startLine": 1893,
                  "startColumn": 1,
                  "endLine": 1893,
                  "endColumn": 8,
                  "charOffset": 67478,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5d8be667-abbb-4eb6-a113-63e6f001be3c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/si_dma.c"
                },
                "region": {
                  "startLine": 496,
                  "startColumn": 2,
                  "endLine": 496,
                  "endColumn": 9,
                  "charOffset": 14029,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9e5a7b11-604b-4b61-a1e6-0aa10b3b454e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 3,
                  "endLine": 426,
                  "endColumn": 10,
                  "charOffset": 10823,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f1b4273c-a196-4d1e-9cb2-0177664dabf8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                },
                "region": {
                  "startLine": 2375,
                  "startColumn": 1,
                  "endLine": 2375,
                  "endColumn": 8,
                  "charOffset": 67375,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-422fe5fb-3f68-450b-86fd-2edf0597d5c9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 1,
                  "endLine": 413,
                  "endColumn": 8,
                  "charOffset": 10490,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6b76f485-cdfb-4d87-8d4d-cc9529b44bf9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                },
                "region": {
                  "startLine": 2304,
                  "startColumn": 1,
                  "endLine": 2304,
                  "endColumn": 8,
                  "charOffset": 65712,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7adbf04b-27f3-4219-bfa1-e3d42d9b0146",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                },
                "region": {
                  "startLine": 1665,
                  "startColumn": 8,
                  "endLine": 1665,
                  "endColumn": 14,
                  "charOffset": 46996,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d717199a-eaa1-4357-bd7a-8e217b4220a6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                },
                "region": {
                  "startLine": 971,
                  "startColumn": 1,
                  "endLine": 971,
                  "endColumn": 44,
                  "charOffset": 26695,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"gfx\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"gfx\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"gfx\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26695,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"gfx\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26695,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"gfx\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-763fc843-2145-4740-b51d-62950f9def96",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 12,
                  "endLine": 120,
                  "endColumn": 18,
                  "charOffset": 3598,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b8128699-e937-4695-ad31-6ecf2d19bc5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c"
                },
                "region": {
                  "startLine": 1106,
                  "startColumn": 1,
                  "endLine": 1106,
                  "endColumn": 56,
                  "charOffset": 42170,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(dst_addr, src_addr, le32_to_cpu(header->jt_size)",
                    "rendered": {
                      "text": "memcpy(dst_addr, src_addr, le32_to_cpu(header->jt_size)",
                      "markdown": "`memcpy(dst_addr, src_addr, le32_to_cpu(header->jt_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42170,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_addr, <size of dst_addr>,  src_addr,  le32_to_cpu(header->jt_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-86852f20-67f8-449c-8f70-f116c5cb02d1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c"
                },
                "region": {
                  "startLine": 1471,
                  "startColumn": 5,
                  "endLine": 1471,
                  "endColumn": 14,
                  "charOffset": 52273,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b8f2285a-6879-4151-955f-296f0a53459b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c"
                },
                "region": {
                  "startLine": 1082,
                  "startColumn": 1,
                  "endLine": 1082,
                  "endColumn": 52,
                  "charOffset": 41426,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(ucode->kaddr, ucode_addr, ucode->ucode_size)",
                    "rendered": {
                      "text": "memcpy(ucode->kaddr, ucode_addr, ucode->ucode_size)",
                      "markdown": "`memcpy(ucode->kaddr, ucode_addr, ucode->ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41426,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ucode->kaddr, <size of ucode->kaddr>,  ucode_addr,  ucode->ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3404cc1b-aa22-4815-a1de-aca7770940ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                },
                "region": {
                  "startLine": 1527,
                  "startColumn": 6,
                  "endLine": 1527,
                  "endColumn": 28,
                  "charOffset": 37996,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(ATOM_ROM_MAGIC)",
                    "rendered": {
                      "text": "strlen(ATOM_ROM_MAGIC)",
                      "markdown": "`strlen(ATOM_ROM_MAGIC)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37996,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(ATOM_ROM_MAGIC, <size of ATOM_ROM_MAGIC>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37996,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(ATOM_ROM_MAGIC, <size of ATOM_ROM_MAGIC>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2b29ed70-6743-4cfe-bd86-c9ace78beb41",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                },
                "region": {
                  "startLine": 1518,
                  "startColumn": 6,
                  "endLine": 1518,
                  "endColumn": 28,
                  "charOffset": 37794,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(ATOM_ATI_MAGIC)",
                    "rendered": {
                      "text": "strlen(ATOM_ATI_MAGIC)",
                      "markdown": "`strlen(ATOM_ATI_MAGIC)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37794,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(ATOM_ATI_MAGIC, <size of ATOM_ATI_MAGIC>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37794,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(ATOM_ATI_MAGIC, <size of ATOM_ATI_MAGIC>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0c4d446c-c9df-4314-bcd7-0e33d38cba5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                },
                "region": {
                  "startLine": 1346,
                  "startColumn": 2,
                  "endLine": 1346,
                  "endColumn": 26,
                  "charOffset": 33770,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(ctx->name, na, 7)",
                    "rendered": {
                      "text": "memcpy(ctx->name, na, 7)",
                      "markdown": "`memcpy(ctx->name, na, 7)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33770,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ctx->name, <size of ctx->name>,  na,  7)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4e0ccfbd-6e1f-47cc-ba2a-6727dc155281",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                },
                "region": {
                  "startLine": 1365,
                  "startColumn": 1,
                  "endLine": 1365,
                  "endColumn": 36,
                  "charOffset": 34133,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(ctx->name, c_ptr, name_size)",
                    "rendered": {
                      "text": "memcpy(ctx->name, c_ptr, name_size)",
                      "markdown": "`memcpy(ctx->name, c_ptr, name_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34133,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ctx->name, <size of ctx->name>,  c_ptr,  name_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58b30df9-a5fe-42fc-b751-3ce959155bb1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                },
                "region": {
                  "startLine": 1490,
                  "startColumn": 2,
                  "endLine": 1490,
                  "endColumn": 54,
                  "charOffset": 37152,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(ctx->vbios_ver_str, vbios_ver, STRLEN_NORMAL)",
                    "rendered": {
                      "text": "memcpy(ctx->vbios_ver_str, vbios_ver, STRLEN_NORMAL)",
                      "markdown": "`memcpy(ctx->vbios_ver_str, vbios_ver, STRLEN_NORMAL)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37152,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ctx->vbios_ver_str, <size of ctx->vbios_ver_str>,  vbios_ver,  STRLEN_NORMAL)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f42f2942-9d28-4455-a6ba-6f0e377d81cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vce_v4_0.c"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 2,
                  "endLine": 470,
                  "endColumn": 9,
                  "charOffset": 16015,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-087f2e25-0069-40a5-9d65-fc000b0962ee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vce_v4_0.c"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 2,
                  "endLine": 321,
                  "endColumn": 68,
                  "charOffset": 11653,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                      "markdown": "`memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vce_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11653,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  &end,  sizeof(struct mmsch_v1_0_cmd_end)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2925dcd0-5bc6-4f13-898d-943de951331f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 15,
                  "charOffset": 2485,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e2e69746-1ad0-486d-b8b0-0da186b2144e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 9,
                  "endLine": 69,
                  "endColumn": 16,
                  "charOffset": 2426,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ca1e4fa3-4458-493e-b4eb-2f4d3d57437e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 410,
                  "startColumn": 4,
                  "endLine": 410,
                  "endColumn": 44,
                  "charOffset": 12419,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/vega20_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/vega20_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/vega20_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12419,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/vega20_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12419,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/vega20_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3365a650-ff97-4124-b29e-618189400dd7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 5,
                  "endLine": 404,
                  "endColumn": 45,
                  "charOffset": 12263,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/vega10_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/vega10_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/vega10_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12263,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/vega10_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12263,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/vega10_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58de5929-4339-48ce-a48a-8aa1fd7475bd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 4,
                  "endLine": 407,
                  "endColumn": 44,
                  "charOffset": 12341,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/vega12_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/vega12_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/vega12_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12341,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/vega12_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12341,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/vega12_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2f4743b1-3374-440f-abf9-752e6eecda05",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 402,
                  "startColumn": 5,
                  "endLine": 402,
                  "endColumn": 49,
                  "charOffset": 12203,
                  "charLength": 44,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/vega10_acg_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/vega10_acg_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/vega10_acg_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12203,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/vega10_acg_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12203,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/vega10_acg_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1b950c9f-2f9b-43ac-8c68-99924c4e435d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 395,
                  "startColumn": 4,
                  "endLine": 395,
                  "endColumn": 43,
                  "charOffset": 11966,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/vegam_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/vegam_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/vegam_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11966,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/vegam_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11966,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/vegam_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f89ce54f-2ac6-467a-a498-d9f5444a774c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 5,
                  "endLine": 391,
                  "endColumn": 48,
                  "charOffset": 11880,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris12_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris12_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris12_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11880,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris12_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11880,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris12_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0dcd3876-bd3d-456f-9bb5-2bd1f901acd3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 389,
                  "startColumn": 5,
                  "endLine": 389,
                  "endColumn": 50,
                  "charOffset": 11815,
                  "charLength": 45,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11815,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris12_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11815,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris12_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ed0ccfc2-223b-4501-9954-672a983a674a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 5,
                  "endLine": 383,
                  "endColumn": 51,
                  "charOffset": 11625,
                  "charLength": 46,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11625,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris10_smc_sk.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11625,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris10_smc_sk.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3c9e1524-7c9b-4814-a9ea-23d93cb9521b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 380,
                  "startColumn": 6,
                  "endLine": 380,
                  "endColumn": 49,
                  "charOffset": 11522,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris10_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris10_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris10_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11522,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris10_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11522,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris10_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-97596c10-e2c5-406b-bdf3-1790eef8fb6c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 378,
                  "startColumn": 6,
                  "endLine": 378,
                  "endColumn": 52,
                  "charOffset": 11454,
                  "charLength": 46,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11454,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris10_k2_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11454,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris10_k2_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c500f806-b733-4cd4-bed2-6a77e03b7dd5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 375,
                  "startColumn": 6,
                  "endLine": 375,
                  "endColumn": 51,
                  "charOffset": 11296,
                  "charLength": 45,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris10_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris10_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris10_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11296,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris10_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11296,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris10_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ae38a248-72e5-476c-9f78-8a46a2e9d247",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 368,
                  "startColumn": 5,
                  "endLine": 368,
                  "endColumn": 51,
                  "charOffset": 11067,
                  "charLength": 46,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11067,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris11_smc_sk.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11067,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris11_smc_sk.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-35f0559b-2140-496e-a33d-215532dd4fb2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 6,
                  "endLine": 365,
                  "endColumn": 49,
                  "charOffset": 10964,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris11_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris11_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris11_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10964,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris11_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10964,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris11_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f120b317-2634-4123-b8ce-ce6015b70b15",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 363,
                  "startColumn": 6,
                  "endLine": 363,
                  "endColumn": 52,
                  "charOffset": 10896,
                  "charLength": 46,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10896,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris11_k2_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10896,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris11_k2_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-08a5f3e8-dc11-48a6-8491-7ce71c5a3167",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 1,
                  "endLine": 127,
                  "endColumn": 85,
                  "charOffset": 3904,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v1_0_cmd_direct_polling)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v1_0_cmd_direct_polling)",
                      "markdown": "`memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v1_0_cmd_direct_polling)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3904,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_poll,  sizeof(struct mmsch_v1_0_cmd_direct_polling)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6efd82c-9f5f-441e-8403-0642265f09c5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 1,
                  "endLine": 116,
                  "endColumn": 62,
                  "charOffset": 3478,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v1_0_cmd_direct_read_modify_write)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v1_0_cmd_direct_read_modify_write)",
                      "markdown": "`memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v1_0_cmd_direct_read_modify_write)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3478,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_rd_mod_wt, \n\t       sizeof(struct mmsch_v1_0_cmd_direct_read_modify_write)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0ccb5ab6-df9e-446a-bd79-91e61794095a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 6,
                  "endLine": 360,
                  "endColumn": 51,
                  "charOffset": 10738,
                  "charLength": 45,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/polaris11_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/polaris11_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/polaris11_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10738,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/polaris11_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10738,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/polaris11_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-465fd00c-0a45-4182-8fe5-20b852740543",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 1,
                  "endLine": 104,
                  "endColumn": 81,
                  "charOffset": 3029,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v1_0_cmd_direct_write)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v1_0_cmd_direct_write)",
                      "markdown": "`memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v1_0_cmd_direct_write)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v1_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3029,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_wt,  sizeof(struct mmsch_v1_0_cmd_direct_write)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef6c24b1-5511-4d1d-a03a-55bae1c1dd5a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 4,
                  "endLine": 354,
                  "endColumn": 42,
                  "charOffset": 10523,
                  "charLength": 38,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/fiji_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/fiji_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/fiji_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10523,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/fiji_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10523,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/fiji_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3072ac3e-bec4-4557-8b52-655ec22e8aae",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 5,
                  "endLine": 351,
                  "endColumn": 44,
                  "charOffset": 10448,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/tonga_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/tonga_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/tonga_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10448,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/tonga_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10448,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/tonga_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a0b002a1-b951-49f4-ac3a-2b7acb44d268",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 5,
                  "endLine": 349,
                  "endColumn": 46,
                  "charOffset": 10389,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/tonga_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/tonga_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/tonga_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10389,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/tonga_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10389,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/tonga_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-473fe51b-52e7-40f9-b109-32436929cb25",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 5,
                  "endLine": 343,
                  "endColumn": 44,
                  "charOffset": 10127,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/topaz_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/topaz_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/topaz_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10127,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/topaz_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10127,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/topaz_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-89f19891-d895-468a-90c7-edc6f75a4456",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 341,
                  "startColumn": 5,
                  "endLine": 341,
                  "endColumn": 46,
                  "charOffset": 10068,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/topaz_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/topaz_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/topaz_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10068,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/topaz_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10068,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/topaz_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0f8b2956-2f2f-4fed-acd7-f8bfe001d0b0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 5,
                  "endLine": 331,
                  "endColumn": 45,
                  "charOffset": 9565,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/hawaii_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/hawaii_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/hawaii_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9565,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/hawaii_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9565,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/hawaii_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-204ce43c-9920-4dcb-9f0a-12e8851ba5df",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 5,
                  "endLine": 329,
                  "endColumn": 47,
                  "charOffset": 9503,
                  "charLength": 42,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9503,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/hawaii_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9503,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/hawaii_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-130370c8-e443-4fd4-a529-21318686929c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 323,
                  "startColumn": 5,
                  "endLine": 323,
                  "endColumn": 46,
                  "charOffset": 9348,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/bonaire_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/bonaire_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/bonaire_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9348,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/bonaire_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9348,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/bonaire_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c323d978-d6a9-4dfe-8272-9475466a68a8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 5,
                  "endLine": 321,
                  "endColumn": 48,
                  "charOffset": 9285,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9285,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"amdgpu/bonaire_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9285,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"amdgpu/bonaire_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c12f0e58-65e2-44cd-b1ca-277ac1154057",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 5,
                  "endLine": 313,
                  "endColumn": 45,
                  "charOffset": 9050,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/hainan_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/hainan_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/hainan_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9050,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/hainan_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9050,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/hainan_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5eeadfb7-5630-4110-a497-c1812dc81d58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 5,
                  "endLine": 311,
                  "endColumn": 48,
                  "charOffset": 8987,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/banks_k_2_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/banks_k_2_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/banks_k_2_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8987,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/banks_k_2_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8987,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/banks_k_2_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c066ede-e507-4dbb-a343-092c144c571a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 5,
                  "endLine": 307,
                  "endColumn": 47,
                  "charOffset": 8820,
                  "charLength": 42,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/hainan_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/hainan_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/hainan_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8820,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/hainan_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8820,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/hainan_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6757afbb-9cb7-494b-bf9c-d7993016c401",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 5,
                  "endLine": 295,
                  "endColumn": 44,
                  "charOffset": 8421,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/oland_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/oland_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/oland_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8421,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/oland_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8421,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/oland_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f1af32e2-57f6-477a-9b44-46d9db3a1475",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 5,
                  "endLine": 293,
                  "endColumn": 46,
                  "charOffset": 8360,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/oland_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/oland_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/oland_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8360,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/oland_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8360,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/oland_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-02486987-af18-4b92-8ab1-f3ca82168f0d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 5,
                  "endLine": 281,
                  "endColumn": 44,
                  "charOffset": 7963,
                  "charLength": 39,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/verde_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/verde_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/verde_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7963,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/verde_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7963,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/verde_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-728c4d5c-4281-4f82-8eda-0c81d83bf972",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 5,
                  "endLine": 279,
                  "endColumn": 46,
                  "charOffset": 7902,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/verde_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/verde_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/verde_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7902,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/verde_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7902,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/verde_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-20c37a8d-f2fd-4f33-9ae8-d26ae38a0dd6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 5,
                  "endLine": 265,
                  "endColumn": 47,
                  "charOffset": 7415,
                  "charLength": 42,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/pitcairn_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/pitcairn_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/pitcairn_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7415,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/pitcairn_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7415,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/pitcairn_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-04bf104c-4941-41e1-9beb-c92229100648",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 5,
                  "endLine": 263,
                  "endColumn": 49,
                  "charOffset": 7351,
                  "charLength": 44,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/pitcairn_k_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/pitcairn_k_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/pitcairn_k_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7351,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/pitcairn_k_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7351,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/pitcairn_k_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-60337f90-1d5d-4223-aa1c-471ef6f84e71",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 4,
                  "endLine": 256,
                  "endColumn": 44,
                  "charOffset": 7113,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(fw_name, \"radeon/tahiti_smc.bin\")",
                    "rendered": {
                      "text": "strcpy(fw_name, \"radeon/tahiti_smc.bin\")",
                      "markdown": "`strcpy(fw_name, \"radeon/tahiti_smc.bin\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7113,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(fw_name, <size of fw_name>,  \"radeon/tahiti_smc.bin\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7113,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(fw_name,  \"radeon/tahiti_smc.bin\", <size of fw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4450752f-0d16-45ab-a88b-758a2362679c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 1,
                  "endLine": 311,
                  "endColumn": 85,
                  "charOffset": 24617,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v2_0_cmd_direct_polling)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v2_0_cmd_direct_polling)",
                      "markdown": "`memcpy((void *)init_table, direct_poll, sizeof(struct mmsch_v2_0_cmd_direct_polling)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24617,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_poll,  sizeof(struct mmsch_v2_0_cmd_direct_polling)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-effb0ee1-8cc2-4cf8-894b-bc8f3c7835bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 1,
                  "endLine": 300,
                  "endColumn": 62,
                  "charOffset": 24191,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v2_0_cmd_direct_read_modify_write)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v2_0_cmd_direct_read_modify_write)",
                      "markdown": "`memcpy((void *)init_table, direct_rd_mod_wt,\n\t       sizeof(struct mmsch_v2_0_cmd_direct_read_modify_write)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24191,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_rd_mod_wt, \n\t       sizeof(struct mmsch_v2_0_cmd_direct_read_modify_write)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5b0968e6-cb60-4f1c-99bd-18d073528ea4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 1,
                  "endLine": 288,
                  "endColumn": 81,
                  "charOffset": 23742,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v2_0_cmd_direct_write)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v2_0_cmd_direct_write)",
                      "markdown": "`memcpy((void *)init_table, direct_wt, sizeof(struct mmsch_v2_0_cmd_direct_write)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v2_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23742,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  direct_wt,  sizeof(struct mmsch_v2_0_cmd_direct_write)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-36b6488d-cb6c-4abf-b797-e9c4c8ae1f9a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v1_0.c"
                },
                "region": {
                  "startLine": 497,
                  "startColumn": 1,
                  "endLine": 497,
                  "endColumn": 8,
                  "charOffset": 15702,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c6c3079-c068-4098-b45c-7a8c0a62da9b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c"
                },
                "region": {
                  "startLine": 1450,
                  "startColumn": 3,
                  "endLine": 1450,
                  "endColumn": 10,
                  "charOffset": 43457,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb610f0c-7d24-4b0c-b377-c65f394a302a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v4_4_2.c"
                },
                "region": {
                  "startLine": 1430,
                  "startColumn": 2,
                  "endLine": 1430,
                  "endColumn": 9,
                  "charOffset": 42852,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eefdd8ed-df93-4d60-a315-df2f1530cf2b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_securedisplay.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 2,
                  "endLine": 120,
                  "endColumn": 8,
                  "charOffset": 4136,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a68b8334-5d64-45cc-b75d-5a32fccede59",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_securedisplay.c"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 2,
                  "endLine": 118,
                  "endColumn": 8,
                  "charOffset": 4103,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-31125893-4d9a-42b6-a431-3c7c8f94f302",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mmhub.c"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 1,
                  "endLine": 39,
                  "endColumn": 46,
                  "charOffset": 1484,
                  "charLength": 45,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"mmhub\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"mmhub\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"mmhub\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mmhub.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1484,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"mmhub\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mmhub.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1484,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"mmhub\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14a0d650-898d-4d2a-bd3e-a6e58aa1475d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v2_0.c"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 1,
                  "endLine": 108,
                  "endColumn": 8,
                  "charOffset": 3599,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7e8bc716-c4a1-4eba-b7ee-bb3f997da60b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp_ta.c"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 1,
                  "endLine": 51,
                  "endColumn": 68,
                  "charOffset": 2003,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len)",
                    "rendered": {
                      "text": "memcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len)",
                      "markdown": "`memcpy((void *)mem_context->shared_buf, shared_buf, shared_buf_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp_ta.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2003,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)mem_context->shared_buf, <size of (void *)mem_context->shared_buf>,  shared_buf,  shared_buf_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7423480b-c442-4ebb-b628-eea71df66dfe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 4053,
                  "startColumn": 1,
                  "endLine": 4053,
                  "endColumn": 55,
                  "charOffset": 113484,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(adev->psp.vbflash_tmp_buf + pos, buffer, count)",
                    "rendered": {
                      "text": "memcpy(adev->psp.vbflash_tmp_buf + pos, buffer, count)",
                      "markdown": "`memcpy(adev->psp.vbflash_tmp_buf + pos, buffer, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 113484,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->psp.vbflash_tmp_buf + pos, <size of adev->psp.vbflash_tmp_buf + pos>,  buffer,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b0757132-2d91-4790-92dd-3dbdb0e2e5c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 4007,
                  "startColumn": 1,
                  "endLine": 4007,
                  "endColumn": 46,
                  "charOffset": 112145,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, start_addr, bin_size)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, start_addr, bin_size)",
                      "markdown": "`memcpy(psp->fw_pri_buf, start_addr, bin_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 112145,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  start_addr,  bin_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b93d33b8-f789-4329-8eb2-660702649f25",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1677,
                  "startColumn": 3,
                  "endLine": 1679,
                  "endColumn": 44,
                  "charOffset": 47362,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(out,\n\t\t\t\t&ras_cmd->ras_out_message.address,\n\t\t\t\tsizeof(ras_cmd->ras_out_message.address)",
                    "rendered": {
                      "text": "memcpy(out,\n\t\t\t\t&ras_cmd->ras_out_message.address,\n\t\t\t\tsizeof(ras_cmd->ras_out_message.address)",
                      "markdown": "`memcpy(out,\n\t\t\t\t&ras_cmd->ras_out_message.address,\n\t\t\t\tsizeof(ras_cmd->ras_out_message.address)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47362,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>, \n\t\t\t\t&ras_cmd->ras_out_message.address, \n\t\t\t\tsizeof(ras_cmd->ras_out_message.address)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ced79a97-d1d4-4b58-98eb-93919dd5a5d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1671,
                  "startColumn": 3,
                  "endLine": 1671,
                  "endColumn": 64,
                  "charOffset": 47148,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(out, &ras_cmd->ras_status, sizeof(ras_cmd->ras_status)",
                    "rendered": {
                      "text": "memcpy(out, &ras_cmd->ras_status, sizeof(ras_cmd->ras_status)",
                      "markdown": "`memcpy(out, &ras_cmd->ras_status, sizeof(ras_cmd->ras_status)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47148,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &ras_cmd->ras_status,  sizeof(ras_cmd->ras_status)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1e16c1f6-b0a6-4ab1-ba64-3f8584c621df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1656,
                  "startColumn": 2,
                  "endLine": 1657,
                  "endColumn": 46,
                  "charOffset": 46797,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&ras_cmd->ras_in_message.address,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.address)",
                    "rendered": {
                      "text": "memcpy(&ras_cmd->ras_in_message.address,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.address)",
                      "markdown": "`memcpy(&ras_cmd->ras_in_message.address,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.address)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46797,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ras_cmd->ras_in_message.address, <size of &ras_cmd->ras_in_message.address>, \n\t\t\tin,  sizeof(ras_cmd->ras_in_message.address)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1948115f-5c80-43af-877e-e54e6614cae7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1652,
                  "startColumn": 2,
                  "endLine": 1653,
                  "endColumn": 52,
                  "charOffset": 46647,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&ras_cmd->ras_in_message.trigger_error,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.trigger_error)",
                    "rendered": {
                      "text": "memcpy(&ras_cmd->ras_in_message.trigger_error,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.trigger_error)",
                      "markdown": "`memcpy(&ras_cmd->ras_in_message.trigger_error,\n\t\t\tin, sizeof(ras_cmd->ras_in_message.trigger_error)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46647,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ras_cmd->ras_in_message.trigger_error, <size of &ras_cmd->ras_in_message.trigger_error>, \n\t\t\tin,  sizeof(ras_cmd->ras_in_message.trigger_error)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-213a1151-94fa-4ded-88b5-6f68102fcd31",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1648,
                  "startColumn": 2,
                  "endLine": 1649,
                  "endColumn": 38,
                  "charOffset": 46525,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(&ras_cmd->ras_in_message,\n\t\t\tin, sizeof(ras_cmd->ras_in_message)",
                    "rendered": {
                      "text": "memcpy(&ras_cmd->ras_in_message,\n\t\t\tin, sizeof(ras_cmd->ras_in_message)",
                      "markdown": "`memcpy(&ras_cmd->ras_in_message,\n\t\t\tin, sizeof(ras_cmd->ras_in_message)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46525,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ras_cmd->ras_in_message, <size of &ras_cmd->ras_in_message>, \n\t\t\tin,  sizeof(ras_cmd->ras_in_message)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49b70841-6240-4eb6-b25e-a08022c5bad8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1560,
                  "startColumn": 4,
                  "endLine": 1561,
                  "endColumn": 49,
                  "charOffset": 43648,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(topology->nodes[i].port_num, link_extend_info_output->nodes[i].port_num,\n\t\t\t\t       sizeof(struct xgmi_connected_port_num)",
                    "rendered": {
                      "text": "memcpy(topology->nodes[i].port_num, link_extend_info_output->nodes[i].port_num,\n\t\t\t\t       sizeof(struct xgmi_connected_port_num)",
                      "markdown": "`memcpy(topology->nodes[i].port_num, link_extend_info_output->nodes[i].port_num,\n\t\t\t\t       sizeof(struct xgmi_connected_port_num)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43648,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(topology->nodes[i].port_num, <size of topology->nodes[i].port_num>,  link_extend_info_output->nodes[i].port_num, \n\t\t\t\t       sizeof(struct xgmi_connected_port_num)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5390f014-b224-4031-909b-fadc79913e7b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 1043,
                  "startColumn": 1,
                  "endLine": 1043,
                  "endColumn": 64,
                  "charOffset": 28256,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, psp->rl.start_addr, psp->rl.size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, psp->rl.start_addr, psp->rl.size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, psp->rl.start_addr, psp->rl.size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28256,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  psp->rl.start_addr,  psp->rl.size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e82714a1-6ca7-4897-aba2-58c50e8ce632",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 717,
                  "startColumn": 1,
                  "endLine": 717,
                  "endColumn": 72,
                  "charOffset": 20112,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(&cmd->resp, &psp->cmd_buf_mem->resp, sizeof(struct psp_gfx_resp)",
                    "rendered": {
                      "text": "memcpy(&cmd->resp, &psp->cmd_buf_mem->resp, sizeof(struct psp_gfx_resp)",
                      "markdown": "`memcpy(&cmd->resp, &psp->cmd_buf_mem->resp, sizeof(struct psp_gfx_resp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20112,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&cmd->resp, <size of &cmd->resp>,  &psp->cmd_buf_mem->resp,  sizeof(struct psp_gfx_resp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-829bc40c-0085-4a53-a3b7-711d0404f692",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                },
                "region": {
                  "startLine": 688,
                  "startColumn": 1,
                  "endLine": 688,
                  "endColumn": 62,
                  "charOffset": 19137,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(psp->cmd_buf_mem, cmd, sizeof(struct psp_gfx_cmd_resp)",
                    "rendered": {
                      "text": "memcpy(psp->cmd_buf_mem, cmd, sizeof(struct psp_gfx_cmd_resp)",
                      "markdown": "`memcpy(psp->cmd_buf_mem, cmd, sizeof(struct psp_gfx_cmd_resp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19137,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->cmd_buf_mem, <size of psp->cmd_buf_mem>,  cmd,  sizeof(struct psp_gfx_cmd_resp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c37078a1-8a7d-4b15-b3a6-2d62e22cb86c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 1,
                  "endLine": 541,
                  "endColumn": 26,
                  "charOffset": 16093,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(&tmp, buf + i,  6)",
                    "rendered": {
                      "text": "memcpy(&tmp, buf + i,  6)",
                      "markdown": "`memcpy(&tmp, buf + i,  6)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16093,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tmp, <size of &tmp>,  buf + i,   6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-563df92f-83d3-49ff-92ff-b272911cf5f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 534,
                  "startColumn": 1,
                  "endLine": 534,
                  "endColumn": 25,
                  "charOffset": 15937,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&tmp, buf + i, 6)",
                    "rendered": {
                      "text": "memcpy(&tmp, buf + i, 6)",
                      "markdown": "`memcpy(&tmp, buf + i, 6)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15937,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tmp, <size of &tmp>,  buf + i,  6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-63595e11-74a7-436e-ba13-23f621e524ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 530,
                  "startColumn": 1,
                  "endLine": 530,
                  "endColumn": 25,
                  "charOffset": 15868,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&tmp, buf + i, 8)",
                    "rendered": {
                      "text": "memcpy(&tmp, buf + i, 8)",
                      "markdown": "`memcpy(&tmp, buf + i, 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15868,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tmp, <size of &tmp>,  buf + i,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dd60732a-60b8-4045-9115-2443e2862663",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 507,
                  "startColumn": 1,
                  "endLine": 507,
                  "endColumn": 25,
                  "charOffset": 15346,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(buf + i, &tmp, 6)",
                    "rendered": {
                      "text": "memcpy(buf + i, &tmp, 6)",
                      "markdown": "`memcpy(buf + i, &tmp, 6)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15346,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf + i, <size of buf + i>,  &tmp,  6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5090027a-7ed2-451c-a1f1-31c7c3bb76f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 514,
                  "startColumn": 1,
                  "endLine": 514,
                  "endColumn": 25,
                  "charOffset": 15508,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(buf + i, &tmp, 6)",
                    "rendered": {
                      "text": "memcpy(buf + i, &tmp, 6)",
                      "markdown": "`memcpy(buf + i, &tmp, 6)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15508,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf + i, <size of buf + i>,  &tmp,  6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6df26699-5076-4ee7-9b79-73753d07d949",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 1,
                  "endLine": 503,
                  "endColumn": 25,
                  "charOffset": 15254,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(buf + i, &tmp, 8)",
                    "rendered": {
                      "text": "memcpy(buf + i, &tmp, 8)",
                      "markdown": "`memcpy(buf + i, &tmp, 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15254,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf + i, <size of buf + i>,  &tmp,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-029b22c4-f8fd-45a7-8c54-5caf533746ae",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c"
                },
                "region": {
                  "startLine": 4413,
                  "startColumn": 2,
                  "endLine": 4413,
                  "endColumn": 9,
                  "charOffset": 136217,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72719730-0920-48d4-802a-7be604f28442",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 1,
                  "endLine": 331,
                  "endColumn": 66,
                  "charOffset": 9973,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, psp->sos.start_addr, psp->sos.size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9973,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  psp->sos.start_addr,  psp->sos.size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-875b4996-3815-4a85-b0fe-ec9b3f6f5329",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c"
                },
                "region": {
                  "startLine": 4336,
                  "startColumn": 1,
                  "endLine": 4336,
                  "endColumn": 8,
                  "charOffset": 134496,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e10fc871-7fbc-4342-b322-9d489e30f0db",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0.c"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 1,
                  "endLine": 249,
                  "endColumn": 68,
                  "charOffset": 7625,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                    "rendered": {
                      "text": "memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)",
                      "markdown": "`memcpy(psp->fw_pri_buf, bin_desc->start_addr, bin_desc->size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/psp_v13_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7625,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_pri_buf, <size of psp->fw_pri_buf>,  bin_desc->start_addr,  bin_desc->size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9bc9f46f-b2de-4f7d-b107-f9f9069d4461",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c"
                },
                "region": {
                  "startLine": 859,
                  "startColumn": 2,
                  "endLine": 859,
                  "endColumn": 9,
                  "charOffset": 24967,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3bf991d6-d09b-48d8-a329-198bcdd0b516",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c"
                },
                "region": {
                  "startLine": 1199,
                  "startColumn": 3,
                  "endLine": 1199,
                  "endColumn": 43,
                  "charOffset": 30913,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(ib->ptr, kptr, ib->length_dw * 4)",
                    "rendered": {
                      "text": "memcpy(ib->ptr, kptr, ib->length_dw * 4)",
                      "markdown": "`memcpy(ib->ptr, kptr, ib->length_dw * 4)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30913,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ib->ptr, <size of ib->ptr>,  kptr,  ib->length_dw * 4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-185c4343-c38c-401c-8f1b-056d7f77f781",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v6_0.c"
                },
                "region": {
                  "startLine": 1349,
                  "startColumn": 2,
                  "endLine": 1349,
                  "endColumn": 9,
                  "charOffset": 44689,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-99251425-41ea-453c-b935-e659bf7d00b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 6284,
                  "startColumn": 1,
                  "endLine": 6284,
                  "endColumn": 49,
                  "charOffset": 339483,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 339483,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_ptr, <size of adev->gfx.me.me_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f92dc23b-2ba2-4fef-a68c-686bb4c6e3be",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/uvd_v4_2.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 1,
                  "endLine": 120,
                  "endColumn": 8,
                  "charOffset": 3432,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f5622a56-a945-4fb2-9b08-4d286a02a4fd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 6207,
                  "startColumn": 1,
                  "endLine": 6207,
                  "endColumn": 49,
                  "charOffset": 337062,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(adev->gfx.ce.ce_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.ce.ce_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->gfx.ce.ce_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 337062,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.ce.ce_fw_ptr, <size of adev->gfx.ce.ce_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ada9ee17-9b22-4d91-a07c-21ac0fdf3d71",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 6129,
                  "startColumn": 1,
                  "endLine": 6129,
                  "endColumn": 51,
                  "charOffset": 334563,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 334563,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_ptr, <size of adev->gfx.pfp.pfp_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3cef900e-8be9-4bd1-860a-5f8e91766aac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 5733,
                  "startColumn": 1,
                  "endLine": 5733,
                  "endColumn": 43,
                  "charOffset": 322705,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                      "markdown": "`memcpy(ptr + toc_offset, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 322705,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + toc_offset, <size of ptr + toc_offset>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bcfb4e2e-5d49-479e-a3a6-27bcd1172aab",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 5638,
                  "startColumn": 1,
                  "endLine": 5638,
                  "endColumn": 86,
                  "charOffset": 320041,
                  "charLength": 85,
                  "snippet": {
                    "text": "memcpy(adev->gfx.rlc.rlc_toc_buf, adev->psp.toc.start_addr, adev->psp.toc.size_bytes)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.rlc.rlc_toc_buf, adev->psp.toc.start_addr, adev->psp.toc.size_bytes)",
                      "markdown": "`memcpy(adev->gfx.rlc.rlc_toc_buf, adev->psp.toc.start_addr, adev->psp.toc.size_bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 320041,
                        "charLength": 85
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.rlc.rlc_toc_buf, <size of adev->gfx.rlc.rlc_toc_buf>,  adev->psp.toc.start_addr,  adev->psp.toc.size_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef681a41-1464-4848-9839-06585418c0ce",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 4697,
                  "startColumn": 1,
                  "endLine": 4697,
                  "endColumn": 8,
                  "charOffset": 292424,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a1dcea17-bdbb-4b79-9708-782dc437048f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 4668,
                  "startColumn": 1,
                  "endLine": 4668,
                  "endColumn": 8,
                  "charOffset": 291494,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-43257c6d-15d7-4b19-a9f9-d89e19a47f67",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                },
                "region": {
                  "startLine": 4466,
                  "startColumn": 2,
                  "endLine": 4466,
                  "endColumn": 30,
                  "charOffset": 284562,
                  "charLength": 28,
                  "snippet": {
                    "text": "memcpy(fw, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(fw, fw_data, fw_size)",
                      "markdown": "`memcpy(fw, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v10_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 284562,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw, <size of fw>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e96cc762-a889-4fd5-bec0-c29d27cc61d9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                },
                "region": {
                  "startLine": 1349,
                  "startColumn": 1,
                  "endLine": 1349,
                  "endColumn": 8,
                  "charOffset": 43810,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a74a78be-260a-42c9-a6cb-f028a89a47ce",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                },
                "region": {
                  "startLine": 1325,
                  "startColumn": 1,
                  "endLine": 1325,
                  "endColumn": 8,
                  "charOffset": 43192,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5c793427-a323-4bda-99d4-07ffea0a72ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                },
                "region": {
                  "startLine": 884,
                  "startColumn": 1,
                  "endLine": 884,
                  "endColumn": 54,
                  "charOffset": 29532,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)",
                      "markdown": "`memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29532,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->mes.data_fw_ptr[pipe], <size of adev->mes.data_fw_ptr[pipe]>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-10aa70b4-dd47-4d0b-825b-0728f64f97ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                },
                "region": {
                  "startLine": 843,
                  "startColumn": 1,
                  "endLine": 843,
                  "endColumn": 55,
                  "charOffset": 28334,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)",
                      "markdown": "`memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28334,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->mes.ucode_fw_ptr[pipe], <size of adev->mes.ucode_fw_ptr[pipe]>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4f546a1e-ead2-449a-af92-d062e35b46dc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 1191,
                  "startColumn": 3,
                  "endLine": 1192,
                  "endColumn": 28,
                  "charOffset": 31297,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(numa_info, xcc_info->numa_info,\n\t\t\t       sizeof(*numa_info)",
                    "rendered": {
                      "text": "memcpy(numa_info, xcc_info->numa_info,\n\t\t\t       sizeof(*numa_info)",
                      "markdown": "`memcpy(numa_info, xcc_info->numa_info,\n\t\t\t       sizeof(*numa_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31297,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(numa_info, <size of numa_info>,  xcc_info->numa_info, \n\t\t\t       sizeof(*numa_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7704cbd4-f2ee-45ad-91ce-e735f736961d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 1105,
                  "startColumn": 2,
                  "endLine": 1105,
                  "endColumn": 9,
                  "charOffset": 29342,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6e6ec25-6381-4a46-8a7a-6130f37bf140",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                },
                "region": {
                  "startLine": 645,
                  "startColumn": 2,
                  "endLine": 647,
                  "endColumn": 55,
                  "charOffset": 21357,
                  "charLength": 154,
                  "snippet": {
                    "text": "memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)",
                    "rendered": {
                      "text": "memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)",
                      "markdown": "`memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21357,
                        "charLength": 154
                      },
                      "insertedContent": {
                        "text": "memcpy_s(misc_pkt.set_shader_debugger.tcp_watch_cntl, <size of misc_pkt.set_shader_debugger.tcp_watch_cntl>, \n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl, \n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-501bc48e-a44d-4036-b80b-4359368b8629",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 748,
                  "startColumn": 2,
                  "endLine": 748,
                  "endColumn": 50,
                  "charOffset": 20511,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(&atcs_output, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&atcs_output, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&atcs_output, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20511,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&atcs_output, <size of &atcs_output>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc2fd8b1-13a1-4680-ae9c-90325fbc1078",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 623,
                  "startColumn": 1,
                  "endLine": 623,
                  "endColumn": 44,
                  "charOffset": 17330,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(&output, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&output, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&output, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17330,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output, <size of &output>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b1bd846a-6586-499a-b739-e92b8fcbb0c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 390,
                  "startColumn": 1,
                  "endLine": 390,
                  "endColumn": 53,
                  "charOffset": 10857,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(&characteristics, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&characteristics, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&characteristics, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10857,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&characteristics, <size of &characteristics>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e2b9a2a8-3ff3-4f81-a61b-a2873806dbc1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 314,
                  "startColumn": 1,
                  "endLine": 314,
                  "endColumn": 44,
                  "charOffset": 8932,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(&params, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&params, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&params, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8932,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&params, <size of &params>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-54301c73-3608-400b-b3a4-ee929e5a9361",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 1,
                  "endLine": 267,
                  "endColumn": 44,
                  "charOffset": 7693,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(&output, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&output, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&output, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7693,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output, <size of &output>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9867ad33-a098-45ac-9eb8-fe039db3bd8e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 1,
                  "endLine": 328,
                  "endColumn": 47,
                  "charOffset": 8574,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((u8 *)binary, (u8 *)fw->data, fw->size)",
                    "rendered": {
                      "text": "memcpy((u8 *)binary, (u8 *)fw->data, fw->size)",
                      "markdown": "`memcpy((u8 *)binary, (u8 *)fw->data, fw->size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8574,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)binary, <size of (u8 *)binary>,  (u8 *)fw->data,  fw->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c44b8d2-1bc5-463d-a9f5-ba7c6b7a6bb1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 2,
                  "endLine": 253,
                  "endColumn": 59,
                  "charOffset": 6784,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(binary, discv_regn, adev->mman.discovery_tmr_size)",
                    "rendered": {
                      "text": "memcpy(binary, discv_regn, adev->mman.discovery_tmr_size)",
                      "markdown": "`memcpy(binary, discv_regn, adev->mman.discovery_tmr_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6784,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(binary, <size of binary>,  discv_regn,  adev->mman.discovery_tmr_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2983018a-74c6-4fb6-9145-3e7625aa4e58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3912,
                  "startColumn": 1,
                  "endLine": 3912,
                  "endColumn": 43,
                  "charOffset": 126914,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(fw_data_ptr, fw_data, fw_data_size)",
                    "rendered": {
                      "text": "memcpy(fw_data_ptr, fw_data, fw_data_size)",
                      "markdown": "`memcpy(fw_data_ptr, fw_data, fw_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 126914,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw_data_ptr, <size of fw_data_ptr>,  fw_data,  fw_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a042dace-9012-40ad-b594-58afb4d9a347",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3911,
                  "startColumn": 1,
                  "endLine": 3911,
                  "endColumn": 46,
                  "charOffset": 126866,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 126866,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw_ucode_ptr, <size of fw_ucode_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2fa771de-6a9c-4312-b040-ea1672dd5164",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3841,
                  "startColumn": 1,
                  "endLine": 3841,
                  "endColumn": 29,
                  "charOffset": 124785,
                  "charLength": 28,
                  "snippet": {
                    "text": "memcpy(fw, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(fw, fw_data, fw_size)",
                      "markdown": "`memcpy(fw, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 124785,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw, <size of fw>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6ad3a502-463f-4dc1-815d-9d86d31f8bdf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3399,
                  "startColumn": 1,
                  "endLine": 3399,
                  "endColumn": 59,
                  "charOffset": 111152,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111152,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_data_ptr, <size of adev->gfx.me.me_fw_data_ptr>,  fw_data,  fw_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf15c576-8d0e-4e8e-9af6-0a3f7dafe355",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3398,
                  "startColumn": 1,
                  "endLine": 3398,
                  "endColumn": 56,
                  "charOffset": 111094,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111094,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_ptr, <size of adev->gfx.me.me_fw_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2a017be9-8b4f-4f3b-bc03-ed3785adc6d8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3330,
                  "startColumn": 1,
                  "endLine": 3330,
                  "endColumn": 49,
                  "charOffset": 109069,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 109069,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_ptr, <size of adev->gfx.me.me_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-36a961fa-1738-449a-a74f-d028b83c1e9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3181,
                  "startColumn": 1,
                  "endLine": 3181,
                  "endColumn": 61,
                  "charOffset": 104424,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 104424,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_data_ptr, <size of adev->gfx.pfp.pfp_fw_data_ptr>,  fw_data,  fw_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5944590c-0ca4-44c8-82b9-db12d4e3fcfd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3180,
                  "startColumn": 1,
                  "endLine": 3180,
                  "endColumn": 58,
                  "charOffset": 104364,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 104364,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_ptr, <size of adev->gfx.pfp.pfp_fw_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b9044152-d482-4be0-be3c-d32b8f6b3d70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 3112,
                  "startColumn": 1,
                  "endLine": 3112,
                  "endColumn": 51,
                  "charOffset": 102291,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 102291,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_ptr, <size of adev->gfx.pfp.pfp_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fb7fae65-2999-456a-b37d-49d9a923db4b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 1270,
                  "startColumn": 1,
                  "endLine": 1270,
                  "endColumn": 43,
                  "charOffset": 43972,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                      "markdown": "`memcpy(ptr + toc_offset, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43972,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + toc_offset, <size of ptr + toc_offset>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-defa3ab9-00be-43c9-80ef-df3ef0b4fe86",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 1172,
                  "startColumn": 1,
                  "endLine": 1172,
                  "endColumn": 8,
                  "charOffset": 41237,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a6fb9117-ba8e-4218-a7f5-ce22540b917d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 1,
                  "endLine": 304,
                  "endColumn": 54,
                  "charOffset": 9206,
                  "charLength": 53,
                  "snippet": {
                    "text": "strcpy(adev->umc.ras->ras_block.ras_comm.name, \"umc\")",
                    "rendered": {
                      "text": "strcpy(adev->umc.ras->ras_block.ras_comm.name, \"umc\")",
                      "markdown": "`strcpy(adev->umc.ras->ras_block.ras_comm.name, \"umc\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9206,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strcpy_s(adev->umc.ras->ras_block.ras_comm.name, <size of adev->umc.ras->ras_block.ras_comm.name>,  \"umc\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9206,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "strlcpy(adev->umc.ras->ras_block.ras_comm.name,  \"umc\", <size of adev->umc.ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-34d83736-aec5-444b-b897-4ab25de1ca79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c"
                },
                "region": {
                  "startLine": 1142,
                  "startColumn": 1,
                  "endLine": 1142,
                  "endColumn": 8,
                  "charOffset": 40304,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf051419-2b51-450d-943d-f28ffd701dc1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_detection.c"
                },
                "region": {
                  "startLine": 1421,
                  "startColumn": 1,
                  "endLine": 1421,
                  "endColumn": 8,
                  "charOffset": 41331,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-245cfa61-184a-4084-a229-aab87bbef158",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0_5.c"
                },
                "region": {
                  "startLine": 178,
                  "startColumn": 2,
                  "endLine": 178,
                  "endColumn": 9,
                  "charOffset": 6165,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-617bbde3-2fb6-47eb-b1c3-c73d37eb4f80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_detection.c"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 2,
                  "endLine": 909,
                  "endColumn": 68,
                  "charOffset": 26834,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&prev_dpcd_caps, &link->dpcd_caps, sizeof(struct dpcd_caps)",
                    "rendered": {
                      "text": "memcpy(&prev_dpcd_caps, &link->dpcd_caps, sizeof(struct dpcd_caps)",
                      "markdown": "`memcpy(&prev_dpcd_caps, &link->dpcd_caps, sizeof(struct dpcd_caps)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/link/link_detection.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26834,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&prev_dpcd_caps, <size of &prev_dpcd_caps>,  &link->dpcd_caps,  sizeof(struct dpcd_caps)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-030b21bc-a94b-4e8a-80b2-5f8ac3ea9bde",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 965,
                  "startColumn": 2,
                  "endLine": 965,
                  "endColumn": 87,
                  "charOffset": 32563,
                  "charLength": 85,
                  "snippet": {
                    "text": "memcpy(&stream->dsc_packed_pps[0], &dsc_packed_pps[0], sizeof(stream->dsc_packed_pps)",
                    "rendered": {
                      "text": "memcpy(&stream->dsc_packed_pps[0], &dsc_packed_pps[0], sizeof(stream->dsc_packed_pps)",
                      "markdown": "`memcpy(&stream->dsc_packed_pps[0], &dsc_packed_pps[0], sizeof(stream->dsc_packed_pps)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32563,
                        "charLength": 85
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&stream->dsc_packed_pps[0], <size of &stream->dsc_packed_pps[0]>,  &dsc_packed_pps[0],  sizeof(stream->dsc_packed_pps)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f00f4408-27f2-428c-a9f7-af6653df16dc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 3,
                  "endLine": 279,
                  "endColumn": 10,
                  "charOffset": 9202,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-511410e2-e86e-4e5f-9f97-39cf1ab74d07",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 3,
                  "endLine": 276,
                  "endColumn": 10,
                  "charOffset": 9060,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a1135ff2-5054-4849-abd9-a0c10873bc42",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 3,
                  "endLine": 267,
                  "endColumn": 10,
                  "charOffset": 8661,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fa0e20c4-b308-4c17-b767-2343f6db1142",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 3,
                  "endLine": 264,
                  "endColumn": 10,
                  "charOffset": 8519,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-972f37fc-9a0f-42be-855d-c2d6fdc8d1a1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 3,
                  "endLine": 255,
                  "endColumn": 10,
                  "charOffset": 8120,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76dcdbe9-fb90-4371-97fb-72e01b23fb75",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 3,
                  "endLine": 252,
                  "endColumn": 10,
                  "charOffset": 7978,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8af8ea0d-0be1-421a-9dcb-2ef284ede52a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 3,
                  "endLine": 243,
                  "endColumn": 10,
                  "charOffset": 7579,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6badea16-5405-4705-890f-df86f7660ae7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/link/link_dpms.c"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 3,
                  "endLine": 240,
                  "endColumn": 10,
                  "charOffset": 7437,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-724e2353-5ab4-4d2c-883a-af15b35c98bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c"
                },
                "region": {
                  "startLine": 972,
                  "startColumn": 2,
                  "endLine": 972,
                  "endColumn": 57,
                  "charOffset": 50675,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)",
                    "rendered": {
                      "text": "memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)",
                      "markdown": "`memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50675,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mode_lib->vba.cache_pipes, <size of mode_lib->vba.cache_pipes>,  pipes,  sizeof(*pipes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7aa135cb-1f3e-405f-b4a7-f2127a0f26c7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 1,
                  "endLine": 65,
                  "endColumn": 56,
                  "charOffset": 2594,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)",
                    "rendered": {
                      "text": "memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)",
                      "markdown": "`memcpy(mode_lib->vba.cache_pipes, pipes, sizeof(*pipes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2594,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mode_lib->vba.cache_pipes, <size of mode_lib->vba.cache_pipes>,  pipes,  sizeof(*pipes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8ebb2ea5-61e8-46ff-8af5-5da686a185f6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_1.c"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 3,
                  "endLine": 175,
                  "endColumn": 10,
                  "charOffset": 6566,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6b917c6f-c695-4243-a03f-110d74b5b9bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 2191,
                  "startColumn": 3,
                  "endLine": 2191,
                  "endColumn": 82,
                  "charOffset": 71800,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71800,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.mec.mqd_backup[mqd_idx],  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7403d501-6cfc-4ca8-9609-29677e578d0d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 2187,
                  "startColumn": 3,
                  "endLine": 2187,
                  "endColumn": 82,
                  "charOffset": 71626,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71626,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.mec.mqd_backup[mqd_idx], <size of adev->gfx.mec.mqd_backup[mqd_idx]>,  mqd,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b121db9c-f00f-4316-bbbf-f4cec09d0b80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 2157,
                  "startColumn": 3,
                  "endLine": 2157,
                  "endColumn": 81,
                  "charOffset": 70490,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(adev->gfx.kiq[xcc_id].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.kiq[xcc_id].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(adev->gfx.kiq[xcc_id].mqd_backup, mqd, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70490,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.kiq[xcc_id].mqd_backup, <size of adev->gfx.kiq[xcc_id].mqd_backup>,  mqd,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cf8292db-1e6b-46b9-a96f-f259a4ade8e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 2133,
                  "startColumn": 3,
                  "endLine": 2133,
                  "endColumn": 81,
                  "charOffset": 69429,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.kiq[xcc_id].mqd_backup, sizeof(struct v9_mqd_allocation)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.kiq[xcc_id].mqd_backup, sizeof(struct v9_mqd_allocation)",
                      "markdown": "`memcpy(mqd, adev->gfx.kiq[xcc_id].mqd_backup, sizeof(struct v9_mqd_allocation)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69429,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.kiq[xcc_id].mqd_backup,  sizeof(struct v9_mqd_allocation)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d8f87483-837e-4ae7-b509-ba8d14b2cd7a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 1021,
                  "startColumn": 1,
                  "endLine": 1021,
                  "endColumn": 8,
                  "charOffset": 33831,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ba5b819-fce1-4887-8b26-ba53edfe23f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                },
                "region": {
                  "startLine": 702,
                  "startColumn": 1,
                  "endLine": 702,
                  "endColumn": 29,
                  "charOffset": 23683,
                  "charLength": 28,
                  "snippet": {
                    "text": "memcpy(fw, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(fw, fw_data, fw_size)",
                      "markdown": "`memcpy(fw, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23683,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw, <size of fw>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-21c3c2b4-8d05-46dc-9dd0-2cba088d6993",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_stream.c"
                },
                "region": {
                  "startLine": 583,
                  "startColumn": 4,
                  "endLine": 584,
                  "endColumn": 38,
                  "charOffset": 16142,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(&stream->writeback_info[j], &stream->writeback_info[i],\n\t\t\t\t\t\tsizeof(struct dc_writeback_info)",
                    "rendered": {
                      "text": "memcpy(&stream->writeback_info[j], &stream->writeback_info[i],\n\t\t\t\t\t\tsizeof(struct dc_writeback_info)",
                      "markdown": "`memcpy(&stream->writeback_info[j], &stream->writeback_info[i],\n\t\t\t\t\t\tsizeof(struct dc_writeback_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_stream.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16142,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&stream->writeback_info[j], <size of &stream->writeback_info[j]>,  &stream->writeback_info[i], \n\t\t\t\t\t\tsizeof(struct dc_writeback_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d90496d2-549a-4186-8ac3-07996a439bda",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_stream.c"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 1,
                  "endLine": 91,
                  "endColumn": 8,
                  "charOffset": 3502,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0e4fa5b1-ac06-44fb-b38a-4abaa04d6e89",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 1,
                  "endLine": 199,
                  "endColumn": 61,
                  "charOffset": 5706,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                    "rendered": {
                      "text": "memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)",
                      "markdown": "`memcpy(dml2_opt, &dc->dml2_options, sizeof(dc->dml2_options)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5706,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dml2_opt, <size of dml2_opt>,  &dc->dml2_options,  sizeof(dc->dml2_options)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a78f64f-87cd-4d10-a9d9-a2c09790257f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 1,
                  "endLine": 189,
                  "endColumn": 69,
                  "charOffset": 5394,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(&state->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib)",
                    "rendered": {
                      "text": "memcpy(&state->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib)",
                      "markdown": "`memcpy(&state->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5394,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&state->bw_ctx.dml, <size of &state->bw_ctx.dml>,  &dc->dml,  sizeof(struct display_mode_lib)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ac110e6e-1885-4505-9342-97e110329e76",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 1,
                  "endLine": 148,
                  "endColumn": 53,
                  "charOffset": 3989,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(dst_state, src_state, sizeof(struct dc_state)",
                    "rendered": {
                      "text": "memcpy(dst_state, src_state, sizeof(struct dc_state)",
                      "markdown": "`memcpy(dst_state, src_state, sizeof(struct dc_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_state.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3989,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_state, <size of dst_state>,  src_state,  sizeof(struct dc_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0fe23aa0-2379-4547-b43f-15a35bf82d32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0.c"
                },
                "region": {
                  "startLine": 496,
                  "startColumn": 1,
                  "endLine": 496,
                  "endColumn": 41,
                  "charOffset": 14042,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &header, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &header, size)",
                      "markdown": "`memcpy((void *)table_loc, &header, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14042,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &header,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-df2dc6be-0ad9-4e08-a92b-e0c43578c69c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0.c"
                },
                "region": {
                  "startLine": 459,
                  "startColumn": 1,
                  "endLine": 459,
                  "endColumn": 41,
                  "charOffset": 12954,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(&header, (void *)table_loc, size)",
                    "rendered": {
                      "text": "memcpy(&header, (void *)table_loc, size)",
                      "markdown": "`memcpy(&header, (void *)table_loc, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12954,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&header, <size of &header>,  (void *)table_loc,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-81020b3f-d143-45ba-b219-a61932392f40",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0.c"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 1,
                  "endLine": 129,
                  "endColumn": 8,
                  "charOffset": 4355,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-173f9aaa-001b-4868-9d6d-992e883f31fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_link_enc_cfg.c"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 1,
                  "endLine": 295,
                  "endColumn": 49,
                  "charOffset": 9322,
                  "charLength": 136,
                  "snippet": {
                    "text": "memcpy(&dst_ctx->res_ctx.link_enc_cfg_ctx,\n\t       &src_ctx->res_ctx.link_enc_cfg_ctx,\n\t       sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx)",
                    "rendered": {
                      "text": "memcpy(&dst_ctx->res_ctx.link_enc_cfg_ctx,\n\t       &src_ctx->res_ctx.link_enc_cfg_ctx,\n\t       sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx)",
                      "markdown": "`memcpy(&dst_ctx->res_ctx.link_enc_cfg_ctx,\n\t       &src_ctx->res_ctx.link_enc_cfg_ctx,\n\t       sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_link_enc_cfg.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9322,
                        "charLength": 136
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dst_ctx->res_ctx.link_enc_cfg_ctx, <size of &dst_ctx->res_ctx.link_enc_cfg_ctx>, \n\t       &src_ctx->res_ctx.link_enc_cfg_ctx, \n\t       sizeof(dst_ctx->res_ctx.link_enc_cfg_ctx)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb967155-6d69-407d-9dac-acf00a0138ab",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 5888,
                  "startColumn": 2,
                  "endLine": 5891,
                  "endColumn": 4,
                  "charOffset": 181451,
                  "charLength": 90,
                  "snippet": {
                    "text": "memcpy(cmd.dp_aux_access.aux_control.dpaux.data,\n\t\t\tpayload->data,\n\t\t\tpayload->length\n\t\t\t)",
                    "rendered": {
                      "text": "memcpy(cmd.dp_aux_access.aux_control.dpaux.data,\n\t\t\tpayload->data,\n\t\t\tpayload->length\n\t\t\t)",
                      "markdown": "`memcpy(cmd.dp_aux_access.aux_control.dpaux.data,\n\t\t\tpayload->data,\n\t\t\tpayload->length\n\t\t\t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 181451,
                        "charLength": 90
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cmd.dp_aux_access.aux_control.dpaux.data, <size of cmd.dp_aux_access.aux_control.dpaux.data>, \n\t\t\tpayload->data, \n\t\t\tpayload->length\n\t\t\t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-836421b9-b271-48b5-b4c1-eb25f246dcbd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3721,
                  "startColumn": 2,
                  "endLine": 3722,
                  "endColumn": 34,
                  "charOffset": 111752,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)",
                    "rendered": {
                      "text": "memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)",
                      "markdown": "`memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111752,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(update_dirty_rect->src_dirty_rects, <size of update_dirty_rect->src_dirty_rects>,  flip_addr->dirty_rects, \n\t\t\t\tsizeof(flip_addr->dirty_rects)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3485779e-9f02-408a-8dcb-02c4893d6cfd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3666,
                  "startColumn": 2,
                  "endLine": 3667,
                  "endColumn": 34,
                  "charOffset": 109928,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)",
                    "rendered": {
                      "text": "memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)",
                      "markdown": "`memcpy(update_dirty_rect->src_dirty_rects, flip_addr->dirty_rects,\n\t\t\t\tsizeof(flip_addr->dirty_rects)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 109928,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(update_dirty_rect->src_dirty_rects, <size of update_dirty_rect->src_dirty_rects>,  flip_addr->dirty_rects, \n\t\t\t\tsizeof(flip_addr->dirty_rects)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d88b4d82-f33a-4f56-bf91-d0682a46576d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atombios_i2c.c"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 4,
                  "endLine": 70,
                  "endColumn": 30,
                  "charOffset": 2308,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(&out, &buf[1], num)",
                    "rendered": {
                      "text": "memcpy(&out, &buf[1], num)",
                      "markdown": "`memcpy(&out, &buf[1], num)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atombios_i2c.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2308,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out, <size of &out>,  &buf[1],  num)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc4fcb5c-2ec7-4df5-965f-b472f67bc39c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3124,
                  "startColumn": 2,
                  "endLine": 3126,
                  "endColumn": 59,
                  "charOffset": 91698,
                  "charLength": 146,
                  "snippet": {
                    "text": "memcpy(&stream->out_transfer_func.tf_pts,\n\t\t       &update->out_transfer_func->tf_pts,\n\t\t       sizeof(struct dc_transfer_func_distributed_points)",
                    "rendered": {
                      "text": "memcpy(&stream->out_transfer_func.tf_pts,\n\t\t       &update->out_transfer_func->tf_pts,\n\t\t       sizeof(struct dc_transfer_func_distributed_points)",
                      "markdown": "`memcpy(&stream->out_transfer_func.tf_pts,\n\t\t       &update->out_transfer_func->tf_pts,\n\t\t       sizeof(struct dc_transfer_func_distributed_points)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 91698,
                        "charLength": 146
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&stream->out_transfer_func.tf_pts, <size of &stream->out_transfer_func.tf_pts>, \n\t\t       &update->out_transfer_func->tf_pts, \n\t\t       sizeof(struct dc_transfer_func_distributed_points)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f255c833-1f58-4696-9367-668ada4ac2aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3071,
                  "startColumn": 2,
                  "endLine": 3072,
                  "endColumn": 27,
                  "charOffset": 90165,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&surface->blend_tf, srf_update->blend_tf,\n\t\tsizeof(surface->blend_tf)",
                    "rendered": {
                      "text": "memcpy(&surface->blend_tf, srf_update->blend_tf,\n\t\tsizeof(surface->blend_tf)",
                      "markdown": "`memcpy(&surface->blend_tf, srf_update->blend_tf,\n\t\tsizeof(surface->blend_tf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 90165,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&surface->blend_tf, <size of &surface->blend_tf>,  srf_update->blend_tf, \n\t\tsizeof(surface->blend_tf)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a1ee427-c01f-4fe9-8826-ba92bc32e3cf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3059,
                  "startColumn": 2,
                  "endLine": 3060,
                  "endColumn": 29,
                  "charOffset": 89854,
                  "charLength": 82,
                  "snippet": {
                    "text": "memcpy(&surface->lut3d_func, srf_update->lut3d_func,\n\t\tsizeof(surface->lut3d_func)",
                    "rendered": {
                      "text": "memcpy(&surface->lut3d_func, srf_update->lut3d_func,\n\t\tsizeof(surface->lut3d_func)",
                      "markdown": "`memcpy(&surface->lut3d_func, srf_update->lut3d_func,\n\t\tsizeof(surface->lut3d_func)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89854,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&surface->lut3d_func, <size of &surface->lut3d_func>,  srf_update->lut3d_func, \n\t\tsizeof(surface->lut3d_func)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-522ceb79-4f58-4048-9b90-19ef34a9b651",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3051,
                  "startColumn": 2,
                  "endLine": 3052,
                  "endColumn": 33,
                  "charOffset": 89582,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&surface->in_shaper_func, srf_update->func_shaper,\n\t\tsizeof(surface->in_shaper_func)",
                    "rendered": {
                      "text": "memcpy(&surface->in_shaper_func, srf_update->func_shaper,\n\t\tsizeof(surface->in_shaper_func)",
                      "markdown": "`memcpy(&surface->in_shaper_func, srf_update->func_shaper,\n\t\tsizeof(surface->in_shaper_func)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89582,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&surface->in_shaper_func, <size of &surface->in_shaper_func>,  srf_update->func_shaper, \n\t\tsizeof(surface->in_shaper_func)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b351dcca-4d66-4f56-bb49-699dba73d7a2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3039,
                  "startColumn": 2,
                  "endLine": 3041,
                  "endColumn": 53,
                  "charOffset": 89123,
                  "charLength": 137,
                  "snippet": {
                    "text": "memcpy(&surface->in_transfer_func.tf_pts,\n\t\t\t&srf_update->in_transfer_func->tf_pts,\n\t\t\tsizeof(struct dc_transfer_func_distributed_points)",
                    "rendered": {
                      "text": "memcpy(&surface->in_transfer_func.tf_pts,\n\t\t\t&srf_update->in_transfer_func->tf_pts,\n\t\t\tsizeof(struct dc_transfer_func_distributed_points)",
                      "markdown": "`memcpy(&surface->in_transfer_func.tf_pts,\n\t\t\t&srf_update->in_transfer_func->tf_pts,\n\t\t\tsizeof(struct dc_transfer_func_distributed_points)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89123,
                        "charLength": 137
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&surface->in_transfer_func.tf_pts, <size of &surface->in_transfer_func.tf_pts>, \n\t\t\t&srf_update->in_transfer_func->tf_pts, \n\t\t\tsizeof(struct dc_transfer_func_distributed_points)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8a65d1e6-87e8-4a1b-a9b0-e8934b77dad3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 3021,
                  "startColumn": 2,
                  "endLine": 3023,
                  "endColumn": 34,
                  "charOffset": 88503,
                  "charLength": 109,
                  "snippet": {
                    "text": "memcpy(&surface->gamma_correction.entries,\n\t\t\t&srf_update->gamma->entries,\n\t\t\tsizeof(struct dc_gamma_entries)",
                    "rendered": {
                      "text": "memcpy(&surface->gamma_correction.entries,\n\t\t\t&srf_update->gamma->entries,\n\t\t\tsizeof(struct dc_gamma_entries)",
                      "markdown": "`memcpy(&surface->gamma_correction.entries,\n\t\t\t&srf_update->gamma->entries,\n\t\t\tsizeof(struct dc_gamma_entries)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 88503,
                        "charLength": 109
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&surface->gamma_correction.entries, <size of &surface->gamma_correction.entries>, \n\t\t\t&srf_update->gamma->entries, \n\t\t\tsizeof(struct dc_gamma_entries)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0d0b2a79-c35e-4ac8-8c5a-cf8dfbea93f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                },
                "region": {
                  "startLine": 1027,
                  "startColumn": 1,
                  "endLine": 1027,
                  "endColumn": 79,
                  "charOffset": 28153,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides)",
                    "rendered": {
                      "text": "memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides)",
                      "markdown": "`memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28153,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc->bb_overrides, <size of &dc->bb_overrides>,  &init_params->bb_overrides,  sizeof(dc->bb_overrides)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-032543c3-c2d1-4eaf-b146-86a63c9219db",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/core/dc_vm_helper.c"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 48,
                  "endColumn": 78,
                  "charOffset": 1836,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&dc->vm_pa_config, pa_config, sizeof(struct dc_phy_addr_space_config)",
                    "rendered": {
                      "text": "memcpy(&dc->vm_pa_config, pa_config, sizeof(struct dc_phy_addr_space_config)",
                      "markdown": "`memcpy(&dc->vm_pa_config, pa_config, sizeof(struct dc_phy_addr_space_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/core/dc_vm_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1836,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc->vm_pa_config, <size of &dc->vm_pa_config>,  pa_config,  sizeof(struct dc_phy_addr_space_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-be0348a3-e705-419f-8dc9-8e5e1028bd14",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c"
                },
                "region": {
                  "startLine": 1222,
                  "startColumn": 2,
                  "endLine": 1222,
                  "endColumn": 9,
                  "charOffset": 33843,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-de4c179e-f9b1-45da-9308-9da2ba0d649e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c"
                },
                "region": {
                  "startLine": 1219,
                  "startColumn": 2,
                  "endLine": 1219,
                  "endColumn": 9,
                  "charOffset": 33724,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a601f296-a112-49aa-9ee7-565d0ff59e41",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c"
                },
                "region": {
                  "startLine": 1217,
                  "startColumn": 2,
                  "endLine": 1217,
                  "endColumn": 9,
                  "charOffset": 33609,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9336f0dd-5a18-473b-b4d2-b876aca3bebb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c"
                },
                "region": {
                  "startLine": 1036,
                  "startColumn": 1,
                  "endLine": 1037,
                  "endColumn": 54,
                  "charOffset": 28495,
                  "charLength": 122,
                  "snippet": {
                    "text": "memcpy(op_input.set_shader_debugger.tcp_watch_cntl, tcp_watch_cntl,\n\t\t\tsizeof(op_input.set_shader_debugger.tcp_watch_cntl)",
                    "rendered": {
                      "text": "memcpy(op_input.set_shader_debugger.tcp_watch_cntl, tcp_watch_cntl,\n\t\t\tsizeof(op_input.set_shader_debugger.tcp_watch_cntl)",
                      "markdown": "`memcpy(op_input.set_shader_debugger.tcp_watch_cntl, tcp_watch_cntl,\n\t\t\tsizeof(op_input.set_shader_debugger.tcp_watch_cntl)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28495,
                        "charLength": 122
                      },
                      "insertedContent": {
                        "text": "memcpy_s(op_input.set_shader_debugger.tcp_watch_cntl, <size of op_input.set_shader_debugger.tcp_watch_cntl>,  tcp_watch_cntl, \n\t\t\tsizeof(op_input.set_shader_debugger.tcp_watch_cntl)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-47e08e95-552f-4d14-bbe6-4b0dcf34dab3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c"
                },
                "region": {
                  "startLine": 1352,
                  "startColumn": 2,
                  "endLine": 1352,
                  "endColumn": 9,
                  "charOffset": 43323,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c4d88bc-ce49-46fb-bb51-40b8e7c80964",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/bios/command_table2.c"
                },
                "region": {
                  "startLine": 961,
                  "startColumn": 2,
                  "endLine": 961,
                  "endColumn": 9,
                  "charOffset": 29812,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f1ca06a3-5a58-48a2-90e4-8ad4b5fca30a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v5_0.c"
                },
                "region": {
                  "startLine": 1446,
                  "startColumn": 2,
                  "endLine": 1446,
                  "endColumn": 9,
                  "charOffset": 50774,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-22ddcd32-7618-49d5-90be-855c24f694a6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/hdcp/hdcp_msg.c"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 2,
                  "endLine": 171,
                  "endColumn": 9,
                  "charOffset": 6182,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8ee321fb-a7a2-44bf-a715-5f6bfb62ffb6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c"
                },
                "region": {
                  "startLine": 1629,
                  "startColumn": 1,
                  "endLine": 1630,
                  "endColumn": 18,
                  "charOffset": 69627,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup),\n\t\tsizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup),\n\t\tsizeof(uint32_t)",
                      "markdown": "`memcpy(dscl_prog_data->isharp_delta, spl_get_pregen_filter_isharp_1D_lut(setup),\n\t\tsizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/sspl/dc_spl.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69627,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dscl_prog_data->isharp_delta, <size of dscl_prog_data->isharp_delta>,  spl_get_pregen_filter_isharp_1D_lut(setup), \n\t\tsizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-44cdbb9d-20fc-45e0-b960-83495c726de5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/cik_sdma.c"
                },
                "region": {
                  "startLine": 969,
                  "startColumn": 2,
                  "endLine": 969,
                  "endColumn": 9,
                  "charOffset": 27238,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4d2c8ada-143e-49d9-8e70-8fc8cfc92647",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c"
                },
                "region": {
                  "startLine": 504,
                  "startColumn": 1,
                  "endLine": 504,
                  "endColumn": 98,
                  "charOffset": 15779,
                  "charLength": 97,
                  "snippet": {
                    "text": "memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut)",
                    "rendered": {
                      "text": "memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut)",
                      "markdown": "`memcpy((void *)filter_isharp_1D_lut_pregen[setup].value, (void *)filter_pregen_store, size_1dlut)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/sspl/dc_spl_isharp_filters.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15779,
                        "charLength": 97
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)filter_isharp_1D_lut_pregen[setup].value, <size of (void *)filter_isharp_1D_lut_pregen[setup].value>,  (void *)filter_pregen_store,  size_1dlut)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-639aa043-a934-49f0-bf0c-b69dd4065034",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 2,
                  "endLine": 595,
                  "endColumn": 43,
                  "charOffset": 17976,
                  "charLength": 41,
                  "snippet": {
                    "text": "strcpy(vf2pf_info->driver_version, \"N/A\")",
                    "rendered": {
                      "text": "strcpy(vf2pf_info->driver_version, \"N/A\")",
                      "markdown": "`strcpy(vf2pf_info->driver_version, \"N/A\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17976,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strcpy_s(vf2pf_info->driver_version, <size of vf2pf_info->driver_version>,  \"N/A\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17976,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "strlcpy(vf2pf_info->driver_version,  \"N/A\", <size of vf2pf_info->driver_version>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-59840ede-8fda-4837-a07e-c40da5c3657e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                },
                "region": {
                  "startLine": 592,
                  "startColumn": 2,
                  "endLine": 592,
                  "endColumn": 58,
                  "charOffset": 17903,
                  "charLength": 56,
                  "snippet": {
                    "text": "strcpy(vf2pf_info->driver_version, THIS_MODULE->version)",
                    "rendered": {
                      "text": "strcpy(vf2pf_info->driver_version, THIS_MODULE->version)",
                      "markdown": "`strcpy(vf2pf_info->driver_version, THIS_MODULE->version)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17903,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strcpy_s(vf2pf_info->driver_version, <size of vf2pf_info->driver_version>,  THIS_MODULE->version)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17903,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "strlcpy(vf2pf_info->driver_version,  THIS_MODULE->version, <size of vf2pf_info->driver_version>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-833901a1-6b8c-42b4-b7f2-ae64e4d9603a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                },
                "region": {
                  "startLine": 359,
                  "startColumn": 1,
                  "endLine": 359,
                  "endColumn": 64,
                  "charOffset": 9267,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(&data->bps[data->count], bps, pages * sizeof(*data->bps)",
                    "rendered": {
                      "text": "memcpy(&data->bps[data->count], bps, pages * sizeof(*data->bps)",
                      "markdown": "`memcpy(&data->bps[data->count], bps, pages * sizeof(*data->bps)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_virt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9267,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data->bps[data->count], <size of &data->bps[data->count]>,  bps,  pages * sizeof(*data->bps)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d034f7cf-6bf3-4819-9d94-542b9bf59a14",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 1,
                  "endLine": 273,
                  "endColumn": 8,
                  "charOffset": 6226,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-154cad66-1da9-4237-9e75-4079895c05a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 1,
                  "endLine": 224,
                  "endColumn": 8,
                  "charOffset": 5155,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ccb7ec41-edac-472f-a9c2-459fa3ad18a9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 2,
                  "endLine": 219,
                  "endColumn": 9,
                  "charOffset": 5030,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bb535177-5164-436b-9901-982af091452b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 1,
                  "endLine": 190,
                  "endColumn": 8,
                  "charOffset": 4484,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a72b78dc-6253-45f3-9715-2ffdd7677dde",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 2,
                  "endLine": 170,
                  "endColumn": 9,
                  "charOffset": 4065,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7355e322-d821-4ca7-a6b3-655a7e1dd549",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/basics/vector.c"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 3,
                  "endLine": 79,
                  "endColumn": 10,
                  "charOffset": 2375,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e09d917a-4dbf-4862-bb4d-470d106cf82b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_object.c"
                },
                "region": {
                  "startLine": 1270,
                  "startColumn": 3,
                  "endLine": 1270,
                  "endColumn": 52,
                  "charOffset": 32796,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(buffer, ubo->metadata, ubo->metadata_size)",
                    "rendered": {
                      "text": "memcpy(buffer, ubo->metadata, ubo->metadata_size)",
                      "markdown": "`memcpy(buffer, ubo->metadata, ubo->metadata_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_object.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32796,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer, <size of buffer>,  ubo->metadata,  ubo->metadata_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6797f33b-5216-47ad-a27e-d323a7ad6659",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v3_0.c"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 1,
                  "endLine": 122,
                  "endColumn": 8,
                  "charOffset": 3903,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1b559644-8ba7-4b2d-8ae3-673aeaa5abdf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v5_0_0.c"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 8,
                  "charOffset": 3658,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3b801bda-6ba7-4652-abdd-432199cc0ec6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 2,
                  "endLine": 767,
                  "endColumn": 86,
                  "charOffset": 30632,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)",
                      "markdown": "`memcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30632,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dcc, <size of &phantom_plane->dcc>,  &curr_pipe->plane_state->dcc,  sizeof(phantom_plane->dcc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-be73946f-0744-4506-aff9-9226355c40e7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 2,
                  "endLine": 766,
                  "endColumn": 38,
                  "charOffset": 30515,
                  "charLength": 112,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)",
                      "markdown": "`memcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30515,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->tiling_info, <size of &phantom_plane->tiling_info>,  &curr_pipe->plane_state->tiling_info, \n\t\t\t\tsizeof(phantom_plane->tiling_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e75bdfbf-6fe4-4d19-9bb4-7b067717e8ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 763,
                  "startColumn": 2,
                  "endLine": 764,
                  "endColumn": 37,
                  "charOffset": 30401,
                  "charLength": 109,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)",
                      "markdown": "`memcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30401,
                        "charLength": 109
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->plane_size, <size of &phantom_plane->plane_size>,  &curr_pipe->plane_state->plane_size, \n\t\t\t\tsizeof(phantom_plane->plane_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ad281364-7b39-4216-997b-f1f4db8946b2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 762,
                  "startColumn": 2,
                  "endLine": 762,
                  "endColumn": 104,
                  "charOffset": 30294,
                  "charLength": 102,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)",
                      "markdown": "`memcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30294,
                        "charLength": 102
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->clip_rect, <size of &phantom_plane->clip_rect>,  &curr_pipe->plane_state->clip_rect,  sizeof(phantom_plane->clip_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1e3ebc96-3cf3-4295-b67a-45243bbe31de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 761,
                  "startColumn": 2,
                  "endLine": 761,
                  "endColumn": 101,
                  "charOffset": 30190,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)",
                      "markdown": "`memcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30190,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->dst_rect, <size of &phantom_plane->dst_rect>,  &curr_pipe->plane_state->dst_rect,  sizeof(phantom_plane->dst_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4557646-04af-423c-8f5d-f8fdd41cafea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 760,
                  "startColumn": 2,
                  "endLine": 760,
                  "endColumn": 101,
                  "charOffset": 30086,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)",
                      "markdown": "`memcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30086,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->src_rect, <size of &phantom_plane->src_rect>,  &curr_pipe->plane_state->src_rect,  sizeof(phantom_plane->src_rect)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6079680f-2d80-43b7-ab02-615f54929e81",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 758,
                  "startColumn": 2,
                  "endLine": 759,
                  "endColumn": 42,
                  "charOffset": 29957,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)",
                      "markdown": "`memcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29957,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->scaling_quality, <size of &phantom_plane->scaling_quality>,  &curr_pipe->plane_state->scaling_quality, \n\t\t\t\tsizeof(phantom_plane->scaling_quality)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7b3fc83-0ea3-4de7-8533-70a50e8bbced",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 757,
                  "startColumn": 2,
                  "endLine": 757,
                  "endColumn": 98,
                  "charOffset": 29856,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)",
                    "rendered": {
                      "text": "memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)",
                      "markdown": "`memcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29856,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_plane->address, <size of &phantom_plane->address>,  &curr_pipe->plane_state->address,  sizeof(phantom_plane->address)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e5dd5d89-8e44-4a5c-b5d4-74aec8f9443f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 1,
                  "endLine": 726,
                  "endColumn": 81,
                  "charOffset": 28817,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)",
                      "markdown": "`memcpy(&phantom_stream->dst, &ref_pipe->stream->dst, sizeof(phantom_stream->dst)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28817,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->dst, <size of &phantom_stream->dst>,  &ref_pipe->stream->dst,  sizeof(phantom_stream->dst)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d712dc4f-009b-4e31-8c5e-225819fcce44",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 725,
                  "startColumn": 1,
                  "endLine": 725,
                  "endColumn": 81,
                  "charOffset": 28733,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)",
                      "markdown": "`memcpy(&phantom_stream->src, &ref_pipe->stream->src, sizeof(phantom_stream->src)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28733,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->src, <size of &phantom_stream->src>,  &ref_pipe->stream->src,  sizeof(phantom_stream->src)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-403b595c-4927-46b7-a39d-e8220b92bdee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                },
                "region": {
                  "startLine": 724,
                  "startColumn": 1,
                  "endLine": 724,
                  "endColumn": 90,
                  "charOffset": 28640,
                  "charLength": 89,
                  "snippet": {
                    "text": "memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)",
                    "rendered": {
                      "text": "memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)",
                      "markdown": "`memcpy(&phantom_stream->timing, &ref_pipe->stream->timing, sizeof(phantom_stream->timing)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28640,
                        "charLength": 89
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&phantom_stream->timing, <size of &phantom_stream->timing>,  &ref_pipe->stream->timing,  sizeof(phantom_stream->timing)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-05fa0b17-87a5-4adb-bf13-b3f647c96c16",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 2,
                  "endLine": 304,
                  "endColumn": 42,
                  "charOffset": 9897,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &header, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &header, size)",
                      "markdown": "`memcpy((void *)table_loc, &header, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9897,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &header,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7047ec48-034f-43ec-a7ea-0884bc0ce854",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_3.c"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 3,
                  "endLine": 181,
                  "endColumn": 10,
                  "charOffset": 6377,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6cf0c493-776f-481a-9f5f-7ddb91f93a1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c"
                },
                "region": {
                  "startLine": 840,
                  "startColumn": 1,
                  "endLine": 840,
                  "endColumn": 55,
                  "charOffset": 33849,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(dst_dml2, src_dml2, sizeof(struct dml2_context)",
                    "rendered": {
                      "text": "memcpy(dst_dml2, src_dml2, sizeof(struct dml2_context)",
                      "markdown": "`memcpy(dst_dml2, src_dml2, sizeof(struct dml2_context)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33849,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_dml2, <size of dst_dml2>,  src_dml2,  sizeof(struct dml2_context)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f66d5d3-4b24-4b38-8f05-b254e83f72f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c"
                },
                "region": {
                  "startLine": 665,
                  "startColumn": 2,
                  "endLine": 665,
                  "endColumn": 129,
                  "charOffset": 28109,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&context->bw_ctx.bw.dcn.watermarks.c, &dml2->v20.g6_temp_read_watermark_set, sizeof(context->bw_ctx.bw.dcn.watermarks.c)",
                    "rendered": {
                      "text": "memcpy(&context->bw_ctx.bw.dcn.watermarks.c, &dml2->v20.g6_temp_read_watermark_set, sizeof(context->bw_ctx.bw.dcn.watermarks.c)",
                      "markdown": "`memcpy(&context->bw_ctx.bw.dcn.watermarks.c, &dml2->v20.g6_temp_read_watermark_set, sizeof(context->bw_ctx.bw.dcn.watermarks.c)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28109,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&context->bw_ctx.bw.dcn.watermarks.c, <size of &context->bw_ctx.bw.dcn.watermarks.c>,  &dml2->v20.g6_temp_read_watermark_set,  sizeof(context->bw_ctx.bw.dcn.watermarks.c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53972ee3-47a8-423c-a5f6-b7aa38a09284",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_0.c"
                },
                "region": {
                  "startLine": 2027,
                  "startColumn": 2,
                  "endLine": 2027,
                  "endColumn": 39,
                  "charOffset": 65075,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy((void *)init_table, &end, tmp)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, &end, tmp)",
                      "markdown": "`memcpy((void *)init_table, &end, tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 65075,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  &end,  tmp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e3e11a87-b2cf-4d95-8867-31ffab890f0a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_0.c"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 2,
                  "endLine": 206,
                  "endColumn": 9,
                  "charOffset": 7761,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2e1c541d-d3ec-4e31-b8d3-499b5190bc9b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_0.c"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 1,
                  "endLine": 172,
                  "endColumn": 8,
                  "charOffset": 6024,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6fb0609c-f36d-45c6-bde7-b2c662120d85",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/display_mode_core.c"
                },
                "region": {
                  "startLine": 9481,
                  "startColumn": 2,
                  "endLine": 9481,
                  "endColumn": 9,
                  "charOffset": 498733,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42c3d0cb-4b9d-40c8-a233-37ce129a4671",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_device.c"
                },
                "region": {
                  "startLine": 3153,
                  "startColumn": 1,
                  "endLine": 3153,
                  "endColumn": 66,
                  "charOffset": 85754,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(adev->reset_magic, adev->gart.ptr, AMDGPU_RESET_MAGIC_NUM)",
                    "rendered": {
                      "text": "memcpy(adev->reset_magic, adev->gart.ptr, AMDGPU_RESET_MAGIC_NUM)",
                      "markdown": "`memcpy(adev->reset_magic, adev->gart.ptr, AMDGPU_RESET_MAGIC_NUM)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_device.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85754,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->reset_magic, <size of adev->reset_magic>,  adev->gart.ptr,  AMDGPU_RESET_MAGIC_NUM)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-02ca371c-f8ad-48fa-a3e2-180b49de83b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v6_0.c"
                },
                "region": {
                  "startLine": 3102,
                  "startColumn": 2,
                  "endLine": 3102,
                  "endColumn": 9,
                  "charOffset": 104529,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1f12fb34-8b91-443f-a19c-5b24b79e2b62",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v6_0.c"
                },
                "region": {
                  "startLine": 3079,
                  "startColumn": 2,
                  "endLine": 3079,
                  "endColumn": 9,
                  "charOffset": 103952,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2e1c5701-d41c-4aa2-b9a5-4343a0ac2545",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 1076,
                  "startColumn": 4,
                  "endLine": 1077,
                  "endColumn": 37,
                  "charOffset": 33880,
                  "charLength": 81,
                  "snippet": {
                    "text": "memcpy(vbios_info.date, atom_context->date,\n\t\t\t\t       sizeof(atom_context->date)",
                    "rendered": {
                      "text": "memcpy(vbios_info.date, atom_context->date,\n\t\t\t\t       sizeof(atom_context->date)",
                      "markdown": "`memcpy(vbios_info.date, atom_context->date,\n\t\t\t\t       sizeof(atom_context->date)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33880,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vbios_info.date, <size of vbios_info.date>,  atom_context->date, \n\t\t\t\t       sizeof(atom_context->date)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2cdfe85e-0dca-493d-a3dd-c1f09f34bd85",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 1074,
                  "startColumn": 4,
                  "endLine": 1075,
                  "endColumn": 46,
                  "charOffset": 33765,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(vbios_info.vbios_ver_str, atom_context->vbios_ver_str,\n\t\t\t\t       sizeof(atom_context->vbios_ver_str)",
                    "rendered": {
                      "text": "memcpy(vbios_info.vbios_ver_str, atom_context->vbios_ver_str,\n\t\t\t\t       sizeof(atom_context->vbios_ver_str)",
                      "markdown": "`memcpy(vbios_info.vbios_ver_str, atom_context->vbios_ver_str,\n\t\t\t\t       sizeof(atom_context->vbios_ver_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33765,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vbios_info.vbios_ver_str, <size of vbios_info.vbios_ver_str>,  atom_context->vbios_ver_str, \n\t\t\t\t       sizeof(atom_context->vbios_ver_str)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c8685526-ca83-4596-ba43-4f3e62dd4e12",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 1071,
                  "startColumn": 4,
                  "endLine": 1072,
                  "endColumn": 41,
                  "charOffset": 33617,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(vbios_info.vbios_pn, atom_context->vbios_pn,\n\t\t\t\t       sizeof(atom_context->vbios_pn)",
                    "rendered": {
                      "text": "memcpy(vbios_info.vbios_pn, atom_context->vbios_pn,\n\t\t\t\t       sizeof(atom_context->vbios_pn)",
                      "markdown": "`memcpy(vbios_info.vbios_pn, atom_context->vbios_pn,\n\t\t\t\t       sizeof(atom_context->vbios_pn)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33617,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vbios_info.vbios_pn, <size of vbios_info.vbios_pn>,  atom_context->vbios_pn, \n\t\t\t\t       sizeof(atom_context->vbios_pn)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-714936ed-8d84-4691-83ae-b66a842597ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 1069,
                  "startColumn": 4,
                  "endLine": 1070,
                  "endColumn": 37,
                  "charOffset": 33529,
                  "charLength": 81,
                  "snippet": {
                    "text": "memcpy(vbios_info.name, atom_context->name,\n\t\t\t\t       sizeof(atom_context->name)",
                    "rendered": {
                      "text": "memcpy(vbios_info.name, atom_context->name,\n\t\t\t\t       sizeof(atom_context->name)",
                      "markdown": "`memcpy(vbios_info.name, atom_context->name,\n\t\t\t\t       sizeof(atom_context->name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33529,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vbios_info.name, <size of vbios_info.name>,  atom_context->name, \n\t\t\t\t       sizeof(atom_context->name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c73edcd0-c4ba-42c8-a8d9-44143eb7ed05",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 963,
                  "startColumn": 2,
                  "endLine": 964,
                  "endColumn": 36,
                  "charOffset": 29337,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(&dev_info->cu_bitmap[0], &adev->gfx.cu_info.bitmap[0],\n\t\t       sizeof(dev_info->cu_bitmap)",
                    "rendered": {
                      "text": "memcpy(&dev_info->cu_bitmap[0], &adev->gfx.cu_info.bitmap[0],\n\t\t       sizeof(dev_info->cu_bitmap)",
                      "markdown": "`memcpy(&dev_info->cu_bitmap[0], &adev->gfx.cu_info.bitmap[0],\n\t\t       sizeof(dev_info->cu_bitmap)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29337,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dev_info->cu_bitmap[0], <size of &dev_info->cu_bitmap[0]>,  &adev->gfx.cu_info.bitmap[0], \n\t\t       sizeof(dev_info->cu_bitmap)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3ebcfcb7-afb4-46b1-8d25-0019822dca61",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                },
                "region": {
                  "startLine": 961,
                  "startColumn": 2,
                  "endLine": 962,
                  "endColumn": 47,
                  "charOffset": 29214,
                  "charLength": 118,
                  "snippet": {
                    "text": "memcpy(&dev_info->cu_ao_bitmap[0], &adev->gfx.cu_info.ao_cu_bitmap[0],\n\t\t       sizeof(adev->gfx.cu_info.ao_cu_bitmap)",
                    "rendered": {
                      "text": "memcpy(&dev_info->cu_ao_bitmap[0], &adev->gfx.cu_info.ao_cu_bitmap[0],\n\t\t       sizeof(adev->gfx.cu_info.ao_cu_bitmap)",
                      "markdown": "`memcpy(&dev_info->cu_ao_bitmap[0], &adev->gfx.cu_info.ao_cu_bitmap[0],\n\t\t       sizeof(adev->gfx.cu_info.ao_cu_bitmap)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29214,
                        "charLength": 118
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dev_info->cu_ao_bitmap[0], <size of &dev_info->cu_ao_bitmap[0]>,  &adev->gfx.cu_info.ao_cu_bitmap[0], \n\t\t       sizeof(adev->gfx.cu_info.ao_cu_bitmap)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76ad1381-b713-4cc2-890a-386efa434ced",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 1,
                  "endLine": 415,
                  "endColumn": 8,
                  "charOffset": 11595,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e9808c36-7f51-406c-bfc9-80800c20ceda",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 1,
                  "endLine": 335,
                  "endColumn": 45,
                  "charOffset": 9537,
                  "charLength": 44,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"sdma\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"sdma\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"sdma\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9537,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"sdma\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9537,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"sdma\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b999938b-d2ec-43d4-b802-2364b2ff6345",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 3,
                  "endLine": 248,
                  "endColumn": 45,
                  "charOffset": 6809,
                  "charLength": 128,
                  "snippet": {
                    "text": "memcpy((void *)&adev->sdma.instance[i],\n\t\t\t       (void *)&adev->sdma.instance[0],\n\t\t\t       sizeof(struct amdgpu_sdma_instance)",
                    "rendered": {
                      "text": "memcpy((void *)&adev->sdma.instance[i],\n\t\t\t       (void *)&adev->sdma.instance[0],\n\t\t\t       sizeof(struct amdgpu_sdma_instance)",
                      "markdown": "`memcpy((void *)&adev->sdma.instance[i],\n\t\t\t       (void *)&adev->sdma.instance[0],\n\t\t\t       sizeof(struct amdgpu_sdma_instance)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_sdma.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6809,
                        "charLength": 128
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&adev->sdma.instance[i], <size of (void *)&adev->sdma.instance[i]>, \n\t\t\t       (void *)&adev->sdma.instance[0], \n\t\t\t       sizeof(struct amdgpu_sdma_instance)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e12378c9-9678-4086-9c7b-c3a5dd729eb4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 1,
                  "endLine": 56,
                  "endColumn": 83,
                  "charOffset": 2670,
                  "charLength": 82,
                  "snippet": {
                    "text": "memcpy(&to->rc_range_params, &from->rc_range_params, sizeof(from->rc_range_params)",
                    "rendered": {
                      "text": "memcpy(&to->rc_range_params, &from->rc_range_params, sizeof(from->rc_range_params)",
                      "markdown": "`memcpy(&to->rc_range_params, &from->rc_range_params, sizeof(from->rc_range_params)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2670,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&to->rc_range_params, <size of &to->rc_range_params>,  &from->rc_range_params,  sizeof(from->rc_range_params)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-da4798e6-d270-4427-a700-12643e0424c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 1,
                  "endLine": 55,
                  "endColumn": 77,
                  "charOffset": 2590,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&to->rc_buf_thresh, &from->rc_buf_thresh, sizeof(from->rc_buf_thresh)",
                    "rendered": {
                      "text": "memcpy(&to->rc_buf_thresh, &from->rc_buf_thresh, sizeof(from->rc_buf_thresh)",
                      "markdown": "`memcpy(&to->rc_buf_thresh, &from->rc_buf_thresh, sizeof(from->rc_buf_thresh)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dsc/rc_calc_dpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2590,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&to->rc_buf_thresh, <size of &to->rc_buf_thresh>,  &from->rc_buf_thresh,  sizeof(from->rc_buf_thresh)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f9d3c824-d3d1-4efb-b647-5d4e6f72127c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v5_0_1.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 2,
                  "endLine": 107,
                  "endColumn": 9,
                  "charOffset": 3352,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-681a3ae0-e845-47bc-9863-02fca9f3845b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_nbio.c"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 1,
                  "endLine": 40,
                  "endColumn": 49,
                  "charOffset": 1484,
                  "charLength": 48,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"pcie_bif\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"pcie_bif\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"pcie_bif\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_nbio.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1484,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"pcie_bif\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_nbio.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1484,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"pcie_bif\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-51904c4e-5c4b-4c29-9275-3adce86af26b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0.c"
                },
                "region": {
                  "startLine": 1460,
                  "startColumn": 1,
                  "endLine": 1460,
                  "endColumn": 41,
                  "charOffset": 49605,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &header, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &header, size)",
                      "markdown": "`memcpy((void *)table_loc, &header, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49605,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &header,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4d9920e-00ea-43fd-8fbf-b23ded197779",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v4_0.c"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 2,
                  "endLine": 218,
                  "endColumn": 9,
                  "charOffset": 7579,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-580247c9-079b-4a88-9f28-81759fc42300",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 1,
                  "endLine": 127,
                  "endColumn": 38,
                  "charOffset": 3858,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &end, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &end, size)",
                      "markdown": "`memcpy((void *)table_loc, &end, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3858,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &end,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-21e86ada-f43e-4a47-8161-3e3795815b37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 1,
                  "endLine": 119,
                  "endColumn": 46,
                  "charOffset": 3650,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_poll, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_poll, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_poll, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3650,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_poll,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-11498ba1-7090-4e86-9add-d929e07dcad2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 1,
                  "endLine": 108,
                  "endColumn": 44,
                  "charOffset": 3298,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_wt, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_wt, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_wt, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3298,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_wt,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4f728d60-853c-440e-9eb3-64475964a35b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 1,
                  "endLine": 98,
                  "endColumn": 51,
                  "charOffset": 2986,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_rd_mod_wt, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_rd_mod_wt, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_rd_mod_wt, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v3_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2986,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_rd_mod_wt,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6bf708dd-9837-4d2d-8e99-2c98b5f80bd6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                },
                "region": {
                  "startLine": 1839,
                  "startColumn": 2,
                  "endLine": 1839,
                  "endColumn": 46,
                  "charOffset": 49531,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(buf, adev->mman.sdma_access_ptr, len)",
                    "rendered": {
                      "text": "memcpy(buf, adev->mman.sdma_access_ptr, len)",
                      "markdown": "`memcpy(buf, adev->mman.sdma_access_ptr, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49531,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  adev->mman.sdma_access_ptr,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-728e0c58-0a60-4505-8e3e-60416f3a8ba8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                },
                "region": {
                  "startLine": 1809,
                  "startColumn": 2,
                  "endLine": 1809,
                  "endColumn": 46,
                  "charOffset": 48647,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(adev->mman.sdma_access_ptr, buf, len)",
                    "rendered": {
                      "text": "memcpy(adev->mman.sdma_access_ptr, buf, len)",
                      "markdown": "`memcpy(adev->mman.sdma_access_ptr, buf, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48647,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->mman.sdma_access_ptr, <size of adev->mman.sdma_access_ptr>,  buf,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4bf07ba3-949c-4d0a-86c5-b202f7b28086",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                },
                "region": {
                  "startLine": 1774,
                  "startColumn": 4,
                  "endLine": 1774,
                  "endColumn": 30,
                  "charOffset": 47911,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(buf, &value, bytes)",
                    "rendered": {
                      "text": "memcpy(buf, &value, bytes)",
                      "markdown": "`memcpy(buf, &value, bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 47911,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  &value,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c9725b9-04b6-4196-8aa2-c775182d807e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c"
                },
                "region": {
                  "startLine": 1388,
                  "startColumn": 2,
                  "endLine": 1388,
                  "endColumn": 68,
                  "charOffset": 46909,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                    "rendered": {
                      "text": "memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)",
                      "markdown": "`memcpy((void *)init_table, &end, sizeof(struct mmsch_v1_0_cmd_end)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 46909,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)init_table, <size of (void *)init_table>,  &end,  sizeof(struct mmsch_v1_0_cmd_end)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-184166a3-c8c1-40af-a838-a6b6f2c1609f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 3,
                  "endLine": 255,
                  "endColumn": 10,
                  "charOffset": 9154,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bfc577d9-3fd6-4983-8ec2-ca639efa7073",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c"
                },
                "region": {
                  "startLine": 234,
                  "startColumn": 2,
                  "endLine": 234,
                  "endColumn": 9,
                  "charOffset": 8486,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7ca8ea8c-bc57-4023-ba6c-61b77cb8ad6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 950,
                  "startColumn": 1,
                  "endLine": 951,
                  "endColumn": 40,
                  "charOffset": 31367,
                  "charLength": 105,
                  "snippet": {
                    "text": "memcpy(clk_mgr_dce->max_clks_by_state, dce120_max_clks_by_state,\n\t       sizeof(dce120_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr_dce->max_clks_by_state, dce120_max_clks_by_state,\n\t       sizeof(dce120_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr_dce->max_clks_by_state, dce120_max_clks_by_state,\n\t       sizeof(dce120_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31367,
                        "charLength": 105
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr_dce->max_clks_by_state, <size of clk_mgr_dce->max_clks_by_state>,  dce120_max_clks_by_state, \n\t       sizeof(dce120_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-528d1f36-59e0-4d91-88f8-eec70d6fc0ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 1,
                  "endLine": 929,
                  "endColumn": 34,
                  "charOffset": 30865,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce120_max_clks_by_state,\n\t\tsizeof(dce120_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30865,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr_dce->max_clks_by_state, <size of clk_mgr_dce->max_clks_by_state>, \n\t\tdce120_max_clks_by_state, \n\t\tsizeof(dce120_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a25d6cd2-2e82-44b7-9bdb-9874b9395781",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 1,
                  "endLine": 908,
                  "endColumn": 34,
                  "charOffset": 30399,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce112_max_clks_by_state,\n\t\tsizeof(dce112_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30399,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr_dce->max_clks_by_state, <size of clk_mgr_dce->max_clks_by_state>, \n\t\tdce112_max_clks_by_state, \n\t\tsizeof(dce112_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cdf7577b-9cbb-41fd-a1c6-2e3227f1d2de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 881,
                  "startColumn": 1,
                  "endLine": 883,
                  "endColumn": 34,
                  "charOffset": 29814,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce110_max_clks_by_state,\n\t\tsizeof(dce110_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29814,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr_dce->max_clks_by_state, <size of clk_mgr_dce->max_clks_by_state>, \n\t\tdce110_max_clks_by_state, \n\t\tsizeof(dce110_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-773c4a33-0cec-4826-946b-705e26e8cfaf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                },
                "region": {
                  "startLine": 858,
                  "startColumn": 1,
                  "endLine": 860,
                  "endColumn": 33,
                  "charOffset": 29274,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)",
                    "rendered": {
                      "text": "memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)",
                      "markdown": "`memcpy(clk_mgr_dce->max_clks_by_state,\n\t\tdce80_max_clks_by_state,\n\t\tsizeof(dce80_max_clks_by_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dce_clk_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29274,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clk_mgr_dce->max_clks_by_state, <size of clk_mgr_dce->max_clks_by_state>, \n\t\tdce80_max_clks_by_state, \n\t\tsizeof(dce80_max_clks_by_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-87f58cac-88ca-4d11-ad34-fb57b0c9c149",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v4_0.c"
                },
                "region": {
                  "startLine": 1908,
                  "startColumn": 3,
                  "endLine": 1908,
                  "endColumn": 10,
                  "charOffset": 66130,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c1706b15-749b-4e0c-8648-055c19908b75",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v4_0.c"
                },
                "region": {
                  "startLine": 1871,
                  "startColumn": 2,
                  "endLine": 1871,
                  "endColumn": 9,
                  "charOffset": 65008,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-95be4721-895f-408f-a981-fb35cd8dff30",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vcn_v5_0_0.c"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 2,
                  "endLine": 171,
                  "endColumn": 9,
                  "charOffset": 5716,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1b24a09d-277e-4963-b059-7d85af1bd4ef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v7_0.c"
                },
                "region": {
                  "startLine": 1362,
                  "startColumn": 2,
                  "endLine": 1362,
                  "endColumn": 9,
                  "charOffset": 44569,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a8fa36b3-4275-46e4-a1b1-2d9541091a1c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v7_0.c"
                },
                "region": {
                  "startLine": 741,
                  "startColumn": 2,
                  "endLine": 741,
                  "endColumn": 62,
                  "charOffset": 26565,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(adev->sdma.instance[i].sdma_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->sdma.instance[i].sdma_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->sdma.instance[i].sdma_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v7_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26565,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->sdma.instance[i].sdma_fw_ptr, <size of adev->sdma.instance[i].sdma_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0ee75d47-27c5-4c75-a2fe-153c3a8c556d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                },
                "region": {
                  "startLine": 980,
                  "startColumn": 1,
                  "endLine": 980,
                  "endColumn": 8,
                  "charOffset": 26247,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6a2662b-76bf-463d-b8e4-32a6f0a9b69b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 1,
                  "endLine": 689,
                  "endColumn": 53,
                  "charOffset": 18982,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(adev->umsch_mm.data_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->umsch_mm.data_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->umsch_mm.data_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18982,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->umsch_mm.data_fw_ptr, <size of adev->umsch_mm.data_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3820f492-8ec6-4b6a-b902-2712eb86dc87",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                },
                "region": {
                  "startLine": 657,
                  "startColumn": 1,
                  "endLine": 657,
                  "endColumn": 54,
                  "charOffset": 17963,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(adev->umsch_mm.ucode_fw_ptr, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->umsch_mm.ucode_fw_ptr, fw_data, fw_size)",
                      "markdown": "`memcpy(adev->umsch_mm.ucode_fw_ptr, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17963,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->umsch_mm.ucode_fw_ptr, <size of adev->umsch_mm.ucode_fw_ptr>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-65943be0-6170-485e-8416-082c23c6d4ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_translation_helper.c"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 1,
                  "endLine": 997,
                  "endColumn": 57,
                  "charOffset": 44207,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(out, &temp_pipe->plane_res.scl_data, sizeof(*out)",
                    "rendered": {
                      "text": "memcpy(out, &temp_pipe->plane_res.scl_data, sizeof(*out)",
                      "markdown": "`memcpy(out, &temp_pipe->plane_res.scl_data, sizeof(*out)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dml2/dml2_translation_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44207,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &temp_pipe->plane_res.scl_data,  sizeof(*out)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f6378597-ee13-4759-a45f-f28ef99cb52f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 1,
                  "endLine": 232,
                  "endColumn": 74,
                  "charOffset": 7616,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)pData, bytes)",
                    "rendered": {
                      "text": "memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)pData, bytes)",
                      "markdown": "`memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)pData, bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7616,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, <size of dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr>,  (void *)pData,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a56cc820-a935-4b26-9610-25c3863c0a62",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 1,
                  "endLine": 172,
                  "endColumn": 72,
                  "charOffset": 5362,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)src, bytes)",
                    "rendered": {
                      "text": "memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)src, bytes)",
                      "markdown": "`memcpy(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, (void *)src, bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5362,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, <size of dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr>,  (void *)src,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2e6d0909-8191-473d-82ff-7fe5bc0523ae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_hw_lock_mgr.c"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 1,
                  "endLine": 45,
                  "endColumn": 96,
                  "charOffset": 1788,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(&cmd.lock_hw.lock_hw_data.inst_flags, inst_flags, sizeof(struct dmub_hw_lock_inst_flags)",
                    "rendered": {
                      "text": "memcpy(&cmd.lock_hw.lock_hw_data.inst_flags, inst_flags, sizeof(struct dmub_hw_lock_inst_flags)",
                      "markdown": "`memcpy(&cmd.lock_hw.lock_hw_data.inst_flags, inst_flags, sizeof(struct dmub_hw_lock_inst_flags)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_hw_lock_mgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1788,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&cmd.lock_hw.lock_hw_data.inst_flags, <size of &cmd.lock_hw.lock_hw_data.inst_flags>,  inst_flags,  sizeof(struct dmub_hw_lock_inst_flags)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cab24018-94c6-45c1-87a5-c66112424d1f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 1,
                  "endLine": 435,
                  "endColumn": 40,
                  "charOffset": 12020,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(req, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(req, info->buffer.pointer, size)",
                      "markdown": "`memcpy(req, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_acpi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12020,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(req, <size of req>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e1206ceb-6e06-402a-b55f-6c6012c54520",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 1,
                  "endLine": 248,
                  "endColumn": 74,
                  "charOffset": 8362,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy((void *)pData, dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, bytes)",
                    "rendered": {
                      "text": "memcpy((void *)pData, dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, bytes)",
                      "markdown": "`memcpy((void *)pData, dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr, bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8362,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)pData, <size of (void *)pData>,  dc->dmub_srv->dmub->scratch_mem_fb.cpu_addr,  bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b90957ec-8701-48fc-b603-8df54a151b9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 5015,
                  "startColumn": 1,
                  "endLine": 5015,
                  "endColumn": 65,
                  "charOffset": 136830,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(&err_node->err_info.mcm_info, mcm_info, sizeof(*mcm_info)",
                    "rendered": {
                      "text": "memcpy(&err_node->err_info.mcm_info, mcm_info, sizeof(*mcm_info)",
                      "markdown": "`memcpy(&err_node->err_info.mcm_info, mcm_info, sizeof(*mcm_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 136830,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&err_node->err_info.mcm_info, <size of &err_node->err_info.mcm_info>,  mcm_info,  sizeof(*mcm_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76459b7e-1cb9-42ce-a976-e8afc7550b7b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 4797,
                  "startColumn": 2,
                  "endLine": 4797,
                  "endColumn": 9,
                  "charOffset": 130803,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a9998e9b-cf3e-485f-9179-f12f275e344b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 4794,
                  "startColumn": 2,
                  "endLine": 4794,
                  "endColumn": 9,
                  "charOffset": 130741,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe6ca20a-d868-4c8e-8a46-8e6b1ffb2081",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 4791,
                  "startColumn": 2,
                  "endLine": 4791,
                  "endColumn": 9,
                  "charOffset": 130646,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6dc50497-efe6-472c-86fe-33e37e825a75",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 4118,
                  "startColumn": 2,
                  "endLine": 4118,
                  "endColumn": 67,
                  "charOffset": 113672,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(&query_info->head, ras_block, sizeof(struct ras_common_if)",
                    "rendered": {
                      "text": "memcpy(&query_info->head, ras_block, sizeof(struct ras_common_if)",
                      "markdown": "`memcpy(&query_info->head, ras_block, sizeof(struct ras_common_if)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 113672,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&query_info->head, <size of &query_info->head>,  ras_block,  sizeof(struct ras_common_if)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7a488bec-417f-4521-822d-595e0b33b02d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2357,
                  "startColumn": 1,
                  "endLine": 2358,
                  "endColumn": 22,
                  "charOffset": 66114,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(&data->ring[data->wptr], info->entry,\n\t\t\tdata->element_size)",
                    "rendered": {
                      "text": "memcpy(&data->ring[data->wptr], info->entry,\n\t\t\tdata->element_size)",
                      "markdown": "`memcpy(&data->ring[data->wptr], info->entry,\n\t\t\tdata->element_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66114,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data->ring[data->wptr], <size of &data->ring[data->wptr]>,  info->entry, \n\t\t\tdata->element_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-26c7f5e3-8321-441a-b74c-0a8aa25a7529",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2309,
                  "startColumn": 2,
                  "endLine": 2310,
                  "endColumn": 23,
                  "charOffset": 64892,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(&entry, &data->ring[data->rptr],\n\t\t\t\tdata->element_size)",
                    "rendered": {
                      "text": "memcpy(&entry, &data->ring[data->rptr],\n\t\t\t\tdata->element_size)",
                      "markdown": "`memcpy(&entry, &data->ring[data->rptr],\n\t\t\t\tdata->element_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64892,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&entry, <size of &entry>,  &data->ring[data->rptr], \n\t\t\t\tdata->element_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a91134d8-fffe-4327-a86f-4ca41c711fac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 2,
                  "endLine": 196,
                  "endColumn": 64,
                  "charOffset": 4882,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(++mqd, test->mqd_data_cpu_addr, sizeof(struct MQD_INFO)",
                    "rendered": {
                      "text": "memcpy(++mqd, test->mqd_data_cpu_addr, sizeof(struct MQD_INFO)",
                      "markdown": "`memcpy(++mqd, test->mqd_data_cpu_addr, sizeof(struct MQD_INFO)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_umsch_mm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4882,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(++mqd, <size of ++mqd>,  test->mqd_data_cpu_addr,  sizeof(struct MQD_INFO)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4fe613eb-8a43-46e0-9baf-9de923c28524",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2053,
                  "startColumn": 3,
                  "endLine": 2053,
                  "endColumn": 10,
                  "charOffset": 57579,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ceb05a5-760d-4516-93df-3e6a303d71fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2728,
                  "startColumn": 2,
                  "endLine": 2729,
                  "endColumn": 36,
                  "charOffset": 75907,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(bps, data->bps,\n\t\t\t\tdata->count * sizeof(*data->bps)",
                    "rendered": {
                      "text": "memcpy(bps, data->bps,\n\t\t\t\tdata->count * sizeof(*data->bps)",
                      "markdown": "`memcpy(bps, data->bps,\n\t\t\t\tdata->count * sizeof(*data->bps)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75907,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bps, <size of bps>,  data->bps, \n\t\t\t\tdata->count * sizeof(*data->bps)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-be40694e-172b-47cc-bd93-2671b55e2e0b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2008,
                  "startColumn": 1,
                  "endLine": 2010,
                  "endColumn": 36,
                  "charOffset": 56542,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(obj->fs_data.debugfs_name,\n\t\t\thead->debugfs_name,\n\t\t\tsizeof(obj->fs_data.debugfs_name)",
                    "rendered": {
                      "text": "memcpy(obj->fs_data.debugfs_name,\n\t\t\thead->debugfs_name,\n\t\t\tsizeof(obj->fs_data.debugfs_name)",
                      "markdown": "`memcpy(obj->fs_data.debugfs_name,\n\t\t\thead->debugfs_name,\n\t\t\tsizeof(obj->fs_data.debugfs_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56542,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(obj->fs_data.debugfs_name, <size of obj->fs_data.debugfs_name>, \n\t\t\thead->debugfs_name, \n\t\t\tsizeof(obj->fs_data.debugfs_name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fb05a3b4-6e27-4c1d-992a-f02ce6be3f07",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 7,
                  "endLine": 338,
                  "endColumn": 13,
                  "charOffset": 8899,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4e92cbbe-8436-4552-9f38-ebd07caacbdf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 336,
                  "startColumn": 4,
                  "endLine": 336,
                  "endColumn": 10,
                  "charOffset": 8801,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-296e60b4-d7f1-4435-9ffd-fd50efcb09e4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 7,
                  "endLine": 332,
                  "endColumn": 13,
                  "charOffset": 8574,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4214a948-db28-4f37-a8df-9f94249eee50",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 7,
                  "endLine": 334,
                  "endColumn": 13,
                  "charOffset": 8693,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a20b6681-c22c-4928-869f-812d8d6dee0c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 7,
                  "endLine": 306,
                  "endColumn": 13,
                  "charOffset": 7939,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7b2595a1-05e3-4b97-a79c-68881d629fab",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 7,
                  "endLine": 305,
                  "endColumn": 13,
                  "charOffset": 7888,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d8460ad9-6e20-4ffb-b436-513102fad969",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 10,
                  "endLine": 295,
                  "endColumn": 16,
                  "charOffset": 7608,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-60fe7c7b-5d44-49da-89d4-70c3f3bfec2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 10,
                  "endLine": 293,
                  "endColumn": 16,
                  "charOffset": 7534,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e0670bf4-8b8c-406c-8ac7-f350f4288505",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/umsch_mm_v4_0.c"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 1,
                  "endLine": 301,
                  "endColumn": 24,
                  "charOffset": 11489,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(set_hw_resources.osssys_base, adev->reg_offset[OSSSYS_HWIP][0],\n\t       sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(set_hw_resources.osssys_base, adev->reg_offset[OSSSYS_HWIP][0],\n\t       sizeof(uint32_t)",
                      "markdown": "`memcpy(set_hw_resources.osssys_base, adev->reg_offset[OSSSYS_HWIP][0],\n\t       sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/umsch_mm_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11489,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(set_hw_resources.osssys_base, <size of set_hw_resources.osssys_base>,  adev->reg_offset[OSSSYS_HWIP][0], \n\t       sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-40f0790e-0e7e-4750-bde3-3bab4778e0ca",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 291,
                  "startColumn": 5,
                  "endLine": 291,
                  "endColumn": 11,
                  "charOffset": 7468,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dfa42e31-0d3b-47a5-8291-1ee9bc6733b5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/umsch_mm_v4_0.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 1,
                  "endLine": 296,
                  "endColumn": 24,
                  "charOffset": 11287,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(set_hw_resources.mmhub_base, adev->reg_offset[MMHUB_HWIP][0],\n\t       sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(set_hw_resources.mmhub_base, adev->reg_offset[MMHUB_HWIP][0],\n\t       sizeof(uint32_t)",
                      "markdown": "`memcpy(set_hw_resources.mmhub_base, adev->reg_offset[MMHUB_HWIP][0],\n\t       sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/umsch_mm_v4_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11287,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(set_hw_resources.mmhub_base, <size of set_hw_resources.mmhub_base>,  adev->reg_offset[MMHUB_HWIP][0], \n\t       sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c386267f-6ef4-4685-9949-9aad4e2dc40b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                },
                "region": {
                  "startLine": 1464,
                  "startColumn": 1,
                  "endLine": 1464,
                  "endColumn": 8,
                  "charOffset": 46881,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4013d093-3faf-4e37-aa73-f2629911d691",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                },
                "region": {
                  "startLine": 1435,
                  "startColumn": 1,
                  "endLine": 1435,
                  "endColumn": 8,
                  "charOffset": 46096,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba9f3c2a-e166-4eae-903c-cff55a3df33f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                },
                "region": {
                  "startLine": 972,
                  "startColumn": 1,
                  "endLine": 972,
                  "endColumn": 54,
                  "charOffset": 31720,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)",
                      "markdown": "`memcpy(adev->mes.data_fw_ptr[pipe], fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31720,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->mes.data_fw_ptr[pipe], <size of adev->mes.data_fw_ptr[pipe]>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2295f8bb-719c-4fa7-8369-d2d6c17f01b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                },
                "region": {
                  "startLine": 938,
                  "startColumn": 1,
                  "endLine": 938,
                  "endColumn": 55,
                  "charOffset": 30750,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)",
                      "markdown": "`memcpy(adev->mes.ucode_fw_ptr[pipe], fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30750,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->mes.ucode_fw_ptr[pipe], <size of adev->mes.ucode_fw_ptr[pipe]>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6b042a5-96f7-41b7-be4d-d66246f7df86",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                },
                "region": {
                  "startLine": 656,
                  "startColumn": 2,
                  "endLine": 658,
                  "endColumn": 55,
                  "charOffset": 20485,
                  "charLength": 154,
                  "snippet": {
                    "text": "memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)",
                    "rendered": {
                      "text": "memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)",
                      "markdown": "`memcpy(misc_pkt.set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl,\n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mes_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20485,
                        "charLength": 154
                      },
                      "insertedContent": {
                        "text": "memcpy_s(misc_pkt.set_shader_debugger.tcp_watch_cntl, <size of misc_pkt.set_shader_debugger.tcp_watch_cntl>, \n\t\t\t\tinput->set_shader_debugger.tcp_watch_cntl, \n\t\t\t\tsizeof(misc_pkt.set_shader_debugger.tcp_watch_cntl)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd3807e7-f9c9-4adb-8929-85822454f274",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 1,
                  "endLine": 176,
                  "endColumn": 43,
                  "charOffset": 5266,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&node->entry, entry, sizeof(*entry)",
                    "rendered": {
                      "text": "memcpy(&node->entry, entry, sizeof(*entry)",
                      "markdown": "`memcpy(&node->entry, entry, sizeof(*entry)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5266,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&node->entry, <size of &node->entry>,  entry,  sizeof(*entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-868c0133-157d-4510-86a4-a0e1e4890afd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 1,
                  "endLine": 148,
                  "endColumn": 49,
                  "charOffset": 4611,
                  "charLength": 48,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mpio\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mpio\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"mca.mpio\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4611,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"mca.mpio\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4611,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"mca.mpio\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea61f94d-4f86-49a6-b7fd-032fc8a1c5dd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 1,
                  "endLine": 100,
                  "endColumn": 48,
                  "charOffset": 3467,
                  "charLength": 47,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mp0\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mp0\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"mca.mp0\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3467,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"mca.mp0\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3467,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"mca.mp0\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0c30bf89-9f4a-4fb0-825d-8a693f327011",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 1,
                  "endLine": 124,
                  "endColumn": 48,
                  "charOffset": 4037,
                  "charLength": 47,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mp1\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"mca.mp1\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"mca.mp1\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4037,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"mca.mp1\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4037,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"mca.mp1\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d0c24ca5-05b2-4a11-9f55-1c9313450df9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_2.c"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 12,
                  "endLine": 443,
                  "endColumn": 19,
                  "charOffset": 23192,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17410206-609a-4dc4-82e9-069b0fcfd2e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_2.c"
                },
                "region": {
                  "startLine": 440,
                  "startColumn": 13,
                  "endLine": 440,
                  "endColumn": 20,
                  "charOffset": 23116,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe5c968e-8660-46fc-a887-e61d5de18c10",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_2.c"
                },
                "region": {
                  "startLine": 438,
                  "startColumn": 12,
                  "endLine": 438,
                  "endColumn": 19,
                  "charOffset": 23028,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c95a3cb5-10f8-4359-b205-410807ef6a32",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v9_4_2.c"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 10,
                  "endLine": 436,
                  "endColumn": 17,
                  "charOffset": 22924,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-900d4ae0-b6da-4442-a2c8-40ff6006b370",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/sdma_v3_0.c"
                },
                "region": {
                  "startLine": 1145,
                  "startColumn": 2,
                  "endLine": 1145,
                  "endColumn": 9,
                  "charOffset": 33902,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f2402662-0ed0-4e73-9a83-c508c6d834b7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 2,
                  "endLine": 152,
                  "endColumn": 9,
                  "charOffset": 4956,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-725c9cd7-5f3b-4d28-83a4-8f85209a0c27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 1,
                  "endLine": 131,
                  "endColumn": 46,
                  "charOffset": 4085,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_poll, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_poll, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_poll, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4085,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_poll,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-86b40c23-c309-493d-baaa-5cf25435c790",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                },
                "region": {
                  "startLine": 139,
                  "startColumn": 1,
                  "endLine": 139,
                  "endColumn": 38,
                  "charOffset": 4293,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &end, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &end, size)",
                      "markdown": "`memcpy((void *)table_loc, &end, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4293,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &end,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-61ec85f3-f9e4-4010-87d1-1a8e27422d19",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 1,
                  "endLine": 120,
                  "endColumn": 44,
                  "charOffset": 3733,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_wt, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_wt, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_wt, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3733,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_wt,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c313e03-3e77-4ca2-8090-6049a5ca288c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vce_v3_0.c"
                },
                "region": {
                  "startLine": 446,
                  "startColumn": 2,
                  "endLine": 446,
                  "endColumn": 9,
                  "charOffset": 12687,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c8142dfc-e40a-4eaa-8813-f47c43d19f62",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 1,
                  "endLine": 110,
                  "endColumn": 51,
                  "charOffset": 3421,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy((void *)table_loc, &direct_rd_mod_wt, size)",
                    "rendered": {
                      "text": "memcpy((void *)table_loc, &direct_rd_mod_wt, size)",
                      "markdown": "`memcpy((void *)table_loc, &direct_rd_mod_wt, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/mmsch_v4_0.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3421,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)table_loc, <size of (void *)table_loc>,  &direct_rd_mod_wt,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-54b329a3-447f-48a3-9241-bab50177e5e4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/jpeg_v4_0_5.c"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 2,
                  "endLine": 163,
                  "endColumn": 9,
                  "charOffset": 5268,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2a49b1dc-aa4d-4a39-b739-b787a13da861",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 3350,
                  "startColumn": 3,
                  "endLine": 3350,
                  "endColumn": 62,
                  "charOffset": 107819,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(*mqd)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(*mqd)",
                      "markdown": "`memcpy(adev->gfx.mec.mqd_backup[mqd_idx], mqd, sizeof(*mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 107819,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.mec.mqd_backup[mqd_idx], <size of adev->gfx.mec.mqd_backup[mqd_idx]>,  mqd,  sizeof(*mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9d47b0ad-1224-4c4c-9306-67cba4ba3887",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 3327,
                  "startColumn": 3,
                  "endLine": 3327,
                  "endColumn": 62,
                  "charOffset": 107054,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(*mqd)",
                    "rendered": {
                      "text": "memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(*mqd)",
                      "markdown": "`memcpy(mqd, adev->gfx.mec.mqd_backup[mqd_idx], sizeof(*mqd)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 107054,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mqd, <size of mqd>,  adev->gfx.mec.mqd_backup[mqd_idx],  sizeof(*mqd)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cfb58698-0c40-4967-920a-f08ebe39a8a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 2802,
                  "startColumn": 1,
                  "endLine": 2802,
                  "endColumn": 46,
                  "charOffset": 89614,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(fw_ucode_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89614,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fw_ucode_ptr, <size of fw_ucode_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-23b2b106-87b4-4c64-815c-1db1e1c83021",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 2480,
                  "startColumn": 1,
                  "endLine": 2480,
                  "endColumn": 59,
                  "charOffset": 79994,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_data_ptr, fw_data, fw_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79994,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_data_ptr, <size of adev->gfx.me.me_fw_data_ptr>,  fw_data,  fw_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eda3d008-03e8-41ea-9895-57faae74773c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 2479,
                  "startColumn": 1,
                  "endLine": 2479,
                  "endColumn": 56,
                  "charOffset": 79936,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(adev->gfx.me.me_fw_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79936,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.me.me_fw_ptr, <size of adev->gfx.me.me_fw_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0d27326e-05cc-4821-9a77-82af6b86cad1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 2336,
                  "startColumn": 1,
                  "endLine": 2336,
                  "endColumn": 61,
                  "charOffset": 75428,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_data_ptr, fw_data, fw_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75428,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_data_ptr, <size of adev->gfx.pfp.pfp_fw_data_ptr>,  fw_data,  fw_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4551979a-c791-4424-a173-320bab16b2d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 2335,
                  "startColumn": 1,
                  "endLine": 2335,
                  "endColumn": 58,
                  "charOffset": 75368,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)",
                    "rendered": {
                      "text": "memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)",
                      "markdown": "`memcpy(adev->gfx.pfp.pfp_fw_ptr, fw_ucode, fw_ucode_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75368,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->gfx.pfp.pfp_fw_ptr, <size of adev->gfx.pfp.pfp_fw_ptr>,  fw_ucode,  fw_ucode_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d60799b-06c2-483f-b76a-fe2b430e5745",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 1084,
                  "startColumn": 1,
                  "endLine": 1084,
                  "endColumn": 43,
                  "charOffset": 36758,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                    "rendered": {
                      "text": "memcpy(ptr + toc_offset, fw_data, fw_size)",
                      "markdown": "`memcpy(ptr + toc_offset, fw_data, fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36758,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + toc_offset, <size of ptr + toc_offset>,  fw_data,  fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4374c1e4-9a20-4507-8be5-5cf570128d67",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 979,
                  "startColumn": 1,
                  "endLine": 979,
                  "endColumn": 8,
                  "charOffset": 33784,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0e2df409-39e2-4f09-8e5b-7ae69083aa9e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/gfx_v12_0.c"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 1,
                  "endLine": 948,
                  "endColumn": 8,
                  "charOffset": 32929,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bf52df88-ca43-47d7-ad0d-eb93c4c5fde6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                },
                "region": {
                  "startLine": 764,
                  "startColumn": 1,
                  "endLine": 764,
                  "endColumn": 64,
                  "charOffset": 21949,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE)",
                    "rendered": {
                      "text": "memcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE)",
                      "markdown": "`memcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21949,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dp_info.dpcd, <size of dp_info.dpcd>,  dig_connector->dpcd,  DP_RECEIVER_CAP_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-01211d03-0374-4215-ac55-befe61058240",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_fru_eeprom.c"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 1,
                  "endLine": 143,
                  "endColumn": 8,
                  "charOffset": 4334,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c2e8a3ae-6d70-47f6-9006-28524573cb6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                },
                "region": {
                  "startLine": 362,
                  "startColumn": 2,
                  "endLine": 362,
                  "endColumn": 48,
                  "charOffset": 10508,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE)",
                    "rendered": {
                      "text": "memcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE)",
                      "markdown": "`memcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10508,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dig_connector->dpcd, <size of dig_connector->dpcd>,  msg,  DP_DPCD_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-81f460ce-ac7c-44f4-8be1-ac3b7c78b130",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.c"
                },
                "region": {
                  "startLine": 417,
                  "startColumn": 1,
                  "endLine": 417,
                  "endColumn": 8,
                  "charOffset": 10736,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53b9ce8c-1e5d-4d71-afe5-b05e49451518",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 2,
                  "endLine": 157,
                  "endColumn": 54,
                  "charOffset": 4389,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size)",
                    "rendered": {
                      "text": "memcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size)",
                      "markdown": "`memcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/atombios_dp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4389,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tx_buf + HEADER_SIZE, <size of tx_buf + HEADER_SIZE>,  msg->buffer,  msg->size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-74333125-4151-4dcc-a967-f9e6ed8c7cff",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.c"
                },
                "region": {
                  "startLine": 326,
                  "startColumn": 1,
                  "endLine": 326,
                  "endColumn": 45,
                  "charOffset": 8199,
                  "charLength": 44,
                  "snippet": {
                    "text": "strcpy(ras->ras_block.ras_comm.name, \"jpeg\")",
                    "rendered": {
                      "text": "strcpy(ras->ras_block.ras_comm.name, \"jpeg\")",
                      "markdown": "`strcpy(ras->ras_block.ras_comm.name, \"jpeg\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8199,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ras->ras_block.ras_comm.name, <size of ras->ras_block.ras_comm.name>,  \"jpeg\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_jpeg.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8199,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strlcpy(ras->ras_block.ras_comm.name,  \"jpeg\", <size of ras->ras_block.ras_comm.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-404dd023-e9a9-4bdf-8d16-86eccc6fab66",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer_debug.c"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 17,
                  "endLine": 57,
                  "endColumn": 26,
                  "charOffset": 1892,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9fa0a3d8-acd5-424f-836a-b45a0edcd20b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 1,
                  "endLine": 540,
                  "endColumn": 8,
                  "charOffset": 16615,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9a47ce38-99ec-4281-9045-8367ec79e1e1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                },
                "region": {
                  "startLine": 477,
                  "startColumn": 2,
                  "endLine": 477,
                  "endColumn": 43,
                  "charOffset": 15138,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&ring->ring[ring->wptr], s, chunk)",
                    "rendered": {
                      "text": "memcpy(&ring->ring[ring->wptr], s, chunk)",
                      "markdown": "`memcpy(&ring->ring[ring->wptr], s, chunk)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15138,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ring->ring[ring->wptr], <size of &ring->ring[ring->wptr]>,  s,  chunk)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-39d2226b-dbd7-4e50-b6eb-ef84d4e764d3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 1,
                  "endLine": 196,
                  "endColumn": 69,
                  "charOffset": 6276,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(section->ctx.reg_dump, reg_dump, reg_count * sizeof(uint32_t)",
                    "rendered": {
                      "text": "memcpy(section->ctx.reg_dump, reg_dump, reg_count * sizeof(uint32_t)",
                      "markdown": "`memcpy(section->ctx.reg_dump, reg_dump, reg_count * sizeof(uint32_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6276,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(section->ctx.reg_dump, <size of section->ctx.reg_dump>,  reg_dump,  reg_count * sizeof(uint32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1592b2ed-144d-443c-b8ed-5415e7e011c0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 1,
                  "endLine": 81,
                  "endColumn": 37,
                  "charOffset": 2725,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(hdr->record_id, record_id, 8)",
                    "rendered": {
                      "text": "memcpy(hdr->record_id, record_id, 8)",
                      "markdown": "`memcpy(hdr->record_id, record_id, 8)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_cper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2725,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdr->record_id, <size of hdr->record_id>,  record_id,  8)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-91700cce-1434-4f83-a7e5-5efb1bd80b11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 1,
                  "endLine": 280,
                  "endColumn": 44,
                  "charOffset": 7316,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(&output, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&output, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&output, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7316,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output, <size of &output>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-09ed8486-2792-4741-8e11-7cf9fc1783b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 2,
                  "endLine": 194,
                  "endColumn": 45,
                  "charOffset": 4901,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(&output, info->buffer.pointer, size)",
                    "rendered": {
                      "text": "memcpy(&output, info->buffer.pointer, size)",
                      "markdown": "`memcpy(&output, info->buffer.pointer, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4901,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output, <size of &output>,  info->buffer.pointer,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c45d0abe-bef1-4fe1-87c3-77f09c2683f0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.h"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 2,
                  "endLine": 403,
                  "endColumn": 33,
                  "charOffset": 14840,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(ring->ring, src, chunk2)",
                    "rendered": {
                      "text": "memcpy(ring->ring, src, chunk2)",
                      "markdown": "`memcpy(ring->ring, src, chunk2)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14840,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ring->ring, <size of ring->ring>,  src,  chunk2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee1f2384-b2a7-402e-872a-0ff90ae57c4a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.h"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 2,
                  "endLine": 399,
                  "endColumn": 44,
                  "charOffset": 14761,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(&ring->ring[occupied], src, chunk1)",
                    "rendered": {
                      "text": "memcpy(&ring->ring[occupied], src, chunk1)",
                      "markdown": "`memcpy(&ring->ring[occupied], src, chunk1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14761,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ring->ring[occupied], <size of &ring->ring[occupied]>,  src,  chunk1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a3545f57-f062-47ee-8641-a2b394adc9ac",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c"
                },
                "region": {
                  "startLine": 707,
                  "startColumn": 1,
                  "endLine": 707,
                  "endColumn": 8,
                  "charOffset": 18879,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19eefafb-c9bb-4f03-85d8-52cad1d70581",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 2,
                  "endLine": 701,
                  "endColumn": 9,
                  "charOffset": 18714,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8e444a0e-ea0d-46b7-8805-229df913e9e3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c"
                },
                "region": {
                  "startLine": 690,
                  "startColumn": 1,
                  "endLine": 690,
                  "endColumn": 8,
                  "charOffset": 18359,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-64b2484e-8a2e-46f8-ac08-cf10e3308fd3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c"
                },
                "region": {
                  "startLine": 1193,
                  "startColumn": 37,
                  "endLine": 1193,
                  "endColumn": 56,
                  "charOffset": 33905,
                  "charLength": 19,
                  "snippet": {
                    "text": "strlen(nps_desc[i])",
                    "rendered": {
                      "text": "strlen(nps_desc[i])",
                      "markdown": "`strlen(nps_desc[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33905,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlen_s(nps_desc[i], <size of nps_desc[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_gmc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33905,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strnlen(nps_desc[i], <size of nps_desc[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2f532aa8-0bb8-49d6-a85c-cc2bd7006f2e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/vce_v2_0.c"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 2,
                  "endLine": 443,
                  "endColumn": 9,
                  "charOffset": 10739,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19614eb9-4baf-4779-96d2-b1afda833be9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h"
                },
                "region": {
                  "startLine": 153,
                  "startColumn": 41,
                  "endLine": 153,
                  "endColumn": 73,
                  "charOffset": 4177,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy((dest), (source), (bytes)",
                    "rendered": {
                      "text": "memcpy((dest), (source), (bytes)",
                      "markdown": "`memcpy((dest), (source), (bytes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dmub/inc/dmub_cmd.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4177,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s((dest), <size of (dest)>,  (source),  (bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8c3a71e1-5661-4579-b957-f93218cc1288",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_pci.c"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 8,
                  "endLine": 143,
                  "endColumn": 15,
                  "charOffset": 3520,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c4aa607a-37ac-440d-8ff1-038f800428bc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_pci.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 8,
                  "endLine": 128,
                  "endColumn": 15,
                  "charOffset": 3154,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8150ed94-196b-43e6-a92d-1f1de4fbf664",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_pci.c"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 8,
                  "endLine": 95,
                  "endColumn": 15,
                  "charOffset": 2418,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d135e957-e75f-4361-9491-9737863fc2bd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_pci.c"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 8,
                  "endLine": 86,
                  "endColumn": 15,
                  "charOffset": 2152,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9f6f4556-c429-4ad1-bfd8-0dabcffbe179",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c"
                },
                "region": {
                  "startLine": 514,
                  "startColumn": 2,
                  "endLine": 514,
                  "endColumn": 52,
                  "charOffset": 18858,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&dmub->meta_info, fw_info, sizeof(*fw_info)",
                    "rendered": {
                      "text": "memcpy(&dmub->meta_info, fw_info, sizeof(*fw_info)",
                      "markdown": "`memcpy(&dmub->meta_info, fw_info, sizeof(*fw_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dmub/src/dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18858,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dmub->meta_info, <size of &dmub->meta_info>,  fw_info,  sizeof(*fw_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4e38cf6-7124-46a8-9973-78466fc18a54",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                },
                "region": {
                  "startLine": 2925,
                  "startColumn": 3,
                  "endLine": 2926,
                  "endColumn": 39,
                  "charOffset": 81305,
                  "charLength": 86,
                  "snippet": {
                    "text": "memcpy(&data->bps[data->count], &(err_rec[j]),\n\t\t\t\t\tsizeof(struct eeprom_table_record)",
                    "rendered": {
                      "text": "memcpy(&data->bps[data->count], &(err_rec[j]),\n\t\t\t\t\tsizeof(struct eeprom_table_record)",
                      "markdown": "`memcpy(&data->bps[data->count], &(err_rec[j]),\n\t\t\t\t\tsizeof(struct eeprom_table_record)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81305,
                        "charLength": 86
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data->bps[data->count], <size of &data->bps[data->count]>,  &(err_rec[j]), \n\t\t\t\t\tsizeof(struct eeprom_table_record)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-22843b33-6860-4cb0-909a-7e24014e0c3d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_drm_dp_helper.c"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 1,
                  "endLine": 72,
                  "endColumn": 40,
                  "charOffset": 2581,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext)",
                    "rendered": {
                      "text": "memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext)",
                      "markdown": "`memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkcl/kcl_drm_dp_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2581,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dpcd, <size of dpcd>,  dpcd_ext,  sizeof(dpcd_ext)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c7fa17f-7ace-47a4-acba-70b1d0b062c7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_wbrf.c"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 1,
                  "endLine": 273,
                  "endColumn": 70,
                  "charOffset": 7485,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(out->band_list, acpi_out.band_list, sizeof(acpi_out.band_list)",
                    "rendered": {
                      "text": "memcpy(out->band_list, acpi_out.band_list, sizeof(acpi_out.band_list)",
                      "markdown": "`memcpy(out->band_list, acpi_out.band_list, sizeof(acpi_out.band_list)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkcl/kcl_wbrf.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7485,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out->band_list, <size of out->band_list>,  acpi_out.band_list,  sizeof(acpi_out.band_list)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee46ce88-9924-4331-8f2b-0c91ab4b906f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/power/power_helpers.c"
                },
                "region": {
                  "startLine": 1039,
                  "startColumn": 1,
                  "endLine": 1039,
                  "endColumn": 94,
                  "charOffset": 44640,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(caps->data_points, custom_backlight_profiles[config_no].data_points, data_points_size)",
                    "rendered": {
                      "text": "memcpy(caps->data_points, custom_backlight_profiles[config_no].data_points, data_points_size)",
                      "markdown": "`memcpy(caps->data_points, custom_backlight_profiles[config_no].data_points, data_points_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/power/power_helpers.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44640,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(caps->data_points, <size of caps->data_points>,  custom_backlight_profiles[config_no].data_points,  data_points_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17885cd5-e4d2-477d-ba4b-ee2f30c94c5c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_log.c"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 3,
                  "endLine": 47,
                  "endColumn": 10,
                  "charOffset": 1794,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3fc3bce5-1d3b-4772-8885-14db4ddb7dde",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_ddc.c"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 2,
                  "endLine": 261,
                  "endColumn": 9,
                  "charOffset": 8854,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-75250e5c-19e5-4c8c-821f-45de6fe6bfe7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 1011,
                  "startColumn": 1,
                  "endLine": 1012,
                  "endColumn": 63,
                  "charOffset": 38815,
                  "charLength": 157,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.repeater_auth_stream_ready,\n\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.repeater_auth_stream_ready,\n\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.repeater_auth_stream_ready,\n\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38815,
                        "charLength": 157
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[0], <size of &msg_in->process.receiver_message[0]>,  hdcp->auth.msg.hdcp2.repeater_auth_stream_ready, \n\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_ready)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-da5a1fd2-7bc6-4bba-9ced-c697af3eb43f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 982,
                  "startColumn": 2,
                  "endLine": 984,
                  "endColumn": 65,
                  "charOffset": 37605,
                  "charLength": 173,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37605,
                        "charLength": 173
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage, <size of hdcp->auth.msg.hdcp2.repeater_auth_stream_manage>, \n\t\t       &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_stream_manage)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc2e451f-1399-47b8-87fe-809f45aeff03",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 889,
                  "startColumn": 2,
                  "endLine": 891,
                  "endColumn": 55,
                  "charOffset": 34100,
                  "charLength": 153,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.repeater_auth_ack,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.repeater_auth_ack,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.repeater_auth_ack,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34100,
                        "charLength": 153
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.repeater_auth_ack, <size of hdcp->auth.msg.hdcp2.repeater_auth_ack>, \n\t\t       &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.repeater_auth_ack)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-66bc3f3a-b877-48fb-adb4-3cf30b6c4241",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 877,
                  "startColumn": 1,
                  "endLine": 878,
                  "endColumn": 47,
                  "charOffset": 33642,
                  "charLength": 125,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.rx_id_list,\n\t       sizeof(hdcp->auth.msg.hdcp2.rx_id_list)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.rx_id_list,\n\t       sizeof(hdcp->auth.msg.hdcp2.rx_id_list)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.rx_id_list,\n\t       sizeof(hdcp->auth.msg.hdcp2.rx_id_list)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33642,
                        "charLength": 125
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[0], <size of &msg_in->process.receiver_message[0]>,  hdcp->auth.msg.hdcp2.rx_id_list, \n\t       sizeof(hdcp->auth.msg.hdcp2.rx_id_list)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a28d67e-f4d6-4d56-9c16-7810c030a4ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 816,
                  "startColumn": 3,
                  "endLine": 818,
                  "endColumn": 61,
                  "charOffset": 31362,
                  "charLength": 200,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.content_stream_type_dp,\n\t\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)],\n\t\t\t       sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.content_stream_type_dp,\n\t\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)],\n\t\t\t       sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.content_stream_type_dp,\n\t\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)],\n\t\t\t       sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31362,
                        "charLength": 200
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.content_stream_type_dp, <size of hdcp->auth.msg.hdcp2.content_stream_type_dp>, \n\t\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ske_eks)], \n\t\t\t       sizeof(hdcp->auth.msg.hdcp2.content_stream_type_dp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5b26a79d-64e9-4559-8484-17c3a7c8ce15",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 809,
                  "startColumn": 2,
                  "endLine": 811,
                  "endColumn": 45,
                  "charOffset": 31115,
                  "charLength": 133,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.ske_eks,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ske_eks)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.ske_eks,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ske_eks)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.ske_eks,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ske_eks)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31115,
                        "charLength": 133
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.ske_eks, <size of hdcp->auth.msg.hdcp2.ske_eks>, \n\t\t       &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.ske_eks)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2d79b6e5-d8fd-45bd-a7df-4635ce61690c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 766,
                  "startColumn": 1,
                  "endLine": 767,
                  "endColumn": 47,
                  "charOffset": 29413,
                  "charLength": 125,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.lc_l_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.lc_l_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.lc_l_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29413,
                        "charLength": 125
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[0], <size of &msg_in->process.receiver_message[0]>,  hdcp->auth.msg.hdcp2.lc_l_prime, \n\t       sizeof(hdcp->auth.msg.hdcp2.lc_l_prime)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0f8f6e8a-1738-42d2-bea5-340fa2cac656",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 739,
                  "startColumn": 2,
                  "endLine": 740,
                  "endColumn": 45,
                  "charOffset": 28279,
                  "charLength": 124,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.lc_init, &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.lc_init)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.lc_init, &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.lc_init)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.lc_init, &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.lc_init)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28279,
                        "charLength": 124
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.lc_init, <size of hdcp->auth.msg.hdcp2.lc_init>,  &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.lc_init)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c212785-07ee-4ead-a88a-535472dcc06d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 693,
                  "startColumn": 2,
                  "endLine": 694,
                  "endColumn": 93,
                  "charOffset": 26375,
                  "charLength": 177,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)],\n\t\t       hdcp->auth.msg.hdcp2.ake_pairing_info, sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)],\n\t\t       hdcp->auth.msg.hdcp2.ake_pairing_info, sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)],\n\t\t       hdcp->auth.msg.hdcp2.ake_pairing_info, sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26375,
                        "charLength": 177
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)], <size of &msg_in->process.receiver_message[sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)]>, \n\t\t       hdcp->auth.msg.hdcp2.ake_pairing_info,  sizeof(hdcp->auth.msg.hdcp2.ake_pairing_info)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-866add56-3458-4be7-b20f-4a1acc1b943f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 687,
                  "startColumn": 1,
                  "endLine": 688,
                  "endColumn": 48,
                  "charOffset": 26028,
                  "charLength": 127,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_h_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_h_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_h_prime,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26028,
                        "charLength": 127
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[0], <size of &msg_in->process.receiver_message[0]>,  hdcp->auth.msg.hdcp2.ake_h_prime, \n\t       sizeof(hdcp->auth.msg.hdcp2.ake_h_prime)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6a87e556-b0fa-438c-ad6d-d4044905bbfa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 644,
                  "startColumn": 2,
                  "endLine": 646,
                  "endColumn": 51,
                  "charOffset": 24262,
                  "charLength": 189,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.ake_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_stored_km)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.ake_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_stored_km)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.ake_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_stored_km)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24262,
                        "charLength": 189
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.ake_stored_km, <size of hdcp->auth.msg.hdcp2.ake_stored_km>, \n\t\t       &msg_out->prepare.transmitter_message[sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_stored_km)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-65b5b983-de93-44a6-9f11-74bc11594896",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 640,
                  "startColumn": 2,
                  "endLine": 642,
                  "endColumn": 54,
                  "charOffset": 24105,
                  "charLength": 151,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp2.ake_no_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp2.ake_no_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp2.ake_no_stored_km,\n\t\t       &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24105,
                        "charLength": 151
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp2.ake_no_stored_km, <size of hdcp->auth.msg.hdcp2.ake_no_stored_km>, \n\t\t       &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_no_stored_km)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7e857692-b698-4ca7-a566-29449f82f266",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 627,
                  "startColumn": 1,
                  "endLine": 628,
                  "endColumn": 45,
                  "charOffset": 23594,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_cert,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_cert)",
                    "rendered": {
                      "text": "memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_cert,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_cert)",
                      "markdown": "`memcpy(&msg_in->process.receiver_message[0], hdcp->auth.msg.hdcp2.ake_cert,\n\t       sizeof(hdcp->auth.msg.hdcp2.ake_cert)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23594,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&msg_in->process.receiver_message[0], <size of &msg_in->process.receiver_message[0]>,  hdcp->auth.msg.hdcp2.ake_cert, \n\t       sizeof(hdcp->auth.msg.hdcp2.ake_cert)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e9ad37e8-d3e0-492f-825c-8c800973a7d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 2,
                  "endLine": 601,
                  "endColumn": 46,
                  "charOffset": 22457,
                  "charLength": 130,
                  "snippet": {
                    "text": "memcpy(&hdcp->auth.msg.hdcp2.ake_init[0], &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_init)",
                    "rendered": {
                      "text": "memcpy(&hdcp->auth.msg.hdcp2.ake_init[0], &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_init)",
                      "markdown": "`memcpy(&hdcp->auth.msg.hdcp2.ake_init[0], &msg_out->prepare.transmitter_message[0],\n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_init)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22457,
                        "charLength": 130
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&hdcp->auth.msg.hdcp2.ake_init[0], <size of &hdcp->auth.msg.hdcp2.ake_init[0]>,  &msg_out->prepare.transmitter_message[0], \n\t\t       sizeof(hdcp->auth.msg.hdcp2.ake_init)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d345ffeb-9162-4fc8-a7eb-b4dac05bbbb6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 1,
                  "endLine": 408,
                  "endColumn": 39,
                  "charOffset": 15361,
                  "charLength": 130,
                  "snippet": {
                    "text": "memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, hdcp->auth.msg.hdcp1.vp,\n\t       sizeof(hdcp->auth.msg.hdcp1.vp)",
                    "rendered": {
                      "text": "memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, hdcp->auth.msg.hdcp1.vp,\n\t       sizeof(hdcp->auth.msg.hdcp1.vp)",
                      "markdown": "`memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, hdcp->auth.msg.hdcp1.vp,\n\t       sizeof(hdcp->auth.msg.hdcp1.vp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15361,
                        "charLength": 130
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime, <size of hdcp_cmd->in_msg.hdcp1_second_part_authentication.v_prime>,  hdcp->auth.msg.hdcp1.vp, \n\t       sizeof(hdcp->auth.msg.hdcp1.vp)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-09239c52-0dbb-46b5-8e7b-a2251fd4bd71",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 1,
                  "endLine": 405,
                  "endColumn": 42,
                  "charOffset": 15218,
                  "charLength": 139,
                  "snippet": {
                    "text": "memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, hdcp->auth.msg.hdcp1.ksvlist,\n\t       hdcp->auth.msg.hdcp1.ksvlist_size)",
                    "rendered": {
                      "text": "memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, hdcp->auth.msg.hdcp1.ksvlist,\n\t       hdcp->auth.msg.hdcp1.ksvlist_size)",
                      "markdown": "`memcpy(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, hdcp->auth.msg.hdcp1.ksvlist,\n\t       hdcp->auth.msg.hdcp1.ksvlist_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15218,
                        "charLength": 139
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list, <size of hdcp_cmd->in_msg.hdcp1_second_part_authentication.ksv_list>,  hdcp->auth.msg.hdcp1.ksvlist, \n\t       hdcp->auth.msg.hdcp1.ksvlist_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9cc864d3-538e-4cbe-a6d8-74d0977e2576",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 1,
                  "endLine": 336,
                  "endColumn": 26,
                  "charOffset": 12312,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, hdcp->auth.msg.hdcp1.bksv,\n\t\tTA_HDCP__HDCP1_KSV_SIZE)",
                    "rendered": {
                      "text": "memcpy(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, hdcp->auth.msg.hdcp1.bksv,\n\t\tTA_HDCP__HDCP1_KSV_SIZE)",
                      "markdown": "`memcpy(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, hdcp->auth.msg.hdcp1.bksv,\n\t\tTA_HDCP__HDCP1_KSV_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12312,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary, <size of hdcp_cmd->in_msg.hdcp1_first_part_authentication.bksv_primary>,  hdcp->auth.msg.hdcp1.bksv, \n\t\tTA_HDCP__HDCP1_KSV_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2ee25329-c983-4ac7-b0a9-8cb98feff608",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 2,
                  "endLine": 282,
                  "endColumn": 40,
                  "charOffset": 10534,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp1.an, hdcp_cmd->out_msg.hdcp1_create_session.an_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.an)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp1.an, hdcp_cmd->out_msg.hdcp1_create_session.an_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.an)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp1.an, hdcp_cmd->out_msg.hdcp1_create_session.an_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.an)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10534,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp1.an, <size of hdcp->auth.msg.hdcp1.an>,  hdcp_cmd->out_msg.hdcp1_create_session.an_primary, \n\t\t       sizeof(hdcp->auth.msg.hdcp1.an)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9440a52c-0f2b-4ac3-a0fd-2a00fe22c403",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 2,
                  "endLine": 280,
                  "endColumn": 42,
                  "charOffset": 10400,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(hdcp->auth.msg.hdcp1.aksv, hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.aksv)",
                    "rendered": {
                      "text": "memcpy(hdcp->auth.msg.hdcp1.aksv, hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.aksv)",
                      "markdown": "`memcpy(hdcp->auth.msg.hdcp1.aksv, hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary,\n\t\t       sizeof(hdcp->auth.msg.hdcp1.aksv)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10400,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp->auth.msg.hdcp1.aksv, <size of hdcp->auth.msg.hdcp1.aksv>,  hdcp_cmd->out_msg.hdcp1_create_session.aksv_primary, \n\t\t       sizeof(hdcp->auth.msg.hdcp1.aksv)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9bbd3ef5-c47d-427f-86b5-d28eb69492de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 1,
                  "endLine": 34,
                  "endColumn": 74,
                  "charOffset": 1316,
                  "charLength": 73,
                  "snippet": {
                    "text": "memcpy(bksv, hdcp->auth.msg.hdcp1.bksv, sizeof(hdcp->auth.msg.hdcp1.bksv)",
                    "rendered": {
                      "text": "memcpy(bksv, hdcp->auth.msg.hdcp1.bksv, sizeof(hdcp->auth.msg.hdcp1.bksv)",
                      "markdown": "`memcpy(bksv, hdcp->auth.msg.hdcp1.bksv, sizeof(hdcp->auth.msg.hdcp1.bksv)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/modules/hdcp/hdcp1_execution.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1316,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bksv, <size of bksv>,  hdcp->auth.msg.hdcp1.bksv,  sizeof(hdcp->auth.msg.hdcp1.bksv)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-08141f23-7dcb-42d1-ba4f-d2b3e208cba5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_mm.c"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 8,
                  "endLine": 50,
                  "endColumn": 32,
                  "charOffset": 1310,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(newp, p, oldsize)",
                    "rendered": {
                      "text": "memcpy(newp, p, oldsize)",
                      "markdown": "`memcpy(newp, p, oldsize)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkcl/kcl_mm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1310,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(newp, <size of newp>,  p,  oldsize)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-474349c1-8cbb-48d5-a4fa-b2c5d9f6290b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/amdkcl/kcl_wbrf.c"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 1,
                  "endLine": 270,
                  "endColumn": 59,
                  "charOffset": 7377,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(&acpi_out, obj->buffer.pointer, obj->buffer.length)",
                    "rendered": {
                      "text": "memcpy(&acpi_out, obj->buffer.pointer, obj->buffer.length)",
                      "markdown": "`memcpy(&acpi_out, obj->buffer.pointer, obj->buffer.length)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/amdkcl/kcl_wbrf.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7377,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&acpi_out, <size of &acpi_out>,  obj->buffer.pointer,  obj->buffer.length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d14ec2cd-e226-41ef-ad6c-03647c7c2d7a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c"
                },
                "region": {
                  "startLine": 1051,
                  "startColumn": 1,
                  "endLine": 1051,
                  "endColumn": 77,
                  "charOffset": 34020,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34020,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu13_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d23b4aa1-1091-4472-8064-e46b11b9fb7e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 1,
                  "endLine": 440,
                  "endColumn": 25,
                  "charOffset": 17215,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/aldebaran_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17215,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee2d7796-2b42-4570-95bd-176f392ee24d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2292,
                  "startColumn": 2,
                  "endLine": 2292,
                  "endColumn": 66,
                  "charOffset": 75616,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75616,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  user_od_table,  sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-24571de9-1908-46ad-a294-8ebcaa9c7fbd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2236,
                  "startColumn": 2,
                  "endLine": 2238,
                  "endColumn": 41,
                  "charOffset": 73208,
                  "charLength": 92,
                  "snippet": {
                    "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73208,
                        "charLength": 92
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&user_od_table_bak, <size of &user_od_table_bak>, \n\t\t       user_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d29cf58c-21df-4390-8d4b-89bd6684f186",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2239,
                  "startColumn": 2,
                  "endLine": 2241,
                  "endColumn": 41,
                  "charOffset": 73305,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73305,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8a31d611-6b63-426a-836b-51c5f57a19b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2222,
                  "startColumn": 1,
                  "endLine": 2224,
                  "endColumn": 40,
                  "charOffset": 72761,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72761,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t       boot_od_table, \n\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7cf5b23f-edb9-42b9-aa5b-455dc6a4543b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2231,
                  "startColumn": 2,
                  "endLine": 2233,
                  "endColumn": 41,
                  "charOffset": 73030,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73030,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-86bd79df-9f56-4f33-ba6d-465733f04aae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 2080,
                  "startColumn": 1,
                  "endLine": 2080,
                  "endColumn": 77,
                  "charOffset": 66789,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66789,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu13_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a78a4e1c-1d19-459b-8862-0f63b697f6fb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 1964,
                  "startColumn": 3,
                  "endLine": 1966,
                  "endColumn": 42,
                  "charOffset": 63756,
                  "charLength": 164,
                  "snippet": {
                    "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63756,
                        "charLength": 164
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->user_overdrive_table + offset_of_voltageoffset, <size of table_context->user_overdrive_table + offset_of_voltageoffset>, \n\t\t\t       (u8 *)od_table + offset_of_voltageoffset, \n\t\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-96b3da90-d853-4de1-b20a-86ceb41c36f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 1936,
                  "startColumn": 3,
                  "endLine": 1938,
                  "endColumn": 37,
                  "charOffset": 62769,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\t\tsizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\t\tsizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\t\tsizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62769,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t\t\t\t\ttable_context->boot_overdrive_table, \n\t\t\t\t\tsizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9d613c81-2056-4486-a4da-882b8bb92835",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 1,
                  "endLine": 435,
                  "endColumn": 68,
                  "charOffset": 17105,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)",
                    "rendered": {
                      "text": "memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)",
                      "markdown": "`memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17105,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(BoardTable, <size of BoardTable>,  &smc_dpm_table->BoardTable,  sizeof(BoardTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bbe9025e-e2dc-4b5f-ab20-eb68914d641a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 1,
                  "endLine": 388,
                  "endColumn": 25,
                  "charOffset": 15905,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15905,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-59aecbf3-274e-4839-9b73-3a0b78b9bde4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 1,
                  "endLine": 288,
                  "endColumn": 18,
                  "charOffset": 9878,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9878,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e0ae3403-7d11-4eff-86ad-1b97807abc9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 1,
                  "endLine": 277,
                  "endColumn": 18,
                  "charOffset": 9397,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9397,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3beef734-975e-46fa-a2d5-8ab82b355b37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                },
                "region": {
                  "startLine": 2457,
                  "startColumn": 1,
                  "endLine": 2457,
                  "endColumn": 48,
                  "charOffset": 73543,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(table->cpu_addr, table_data, table_size)",
                    "rendered": {
                      "text": "memcpy(table->cpu_addr, table_data, table_size)",
                      "markdown": "`memcpy(table->cpu_addr, table_data, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73543,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table->cpu_addr, <size of table->cpu_addr>,  table_data,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4dbb30b4-6a8f-4f7f-89a9-edc4ea7084f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 1,
                  "endLine": 266,
                  "endColumn": 18,
                  "charOffset": 8955,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8955,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8098d99a-c5f6-4b0c-8930-5159e2306ac6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 1,
                  "endLine": 944,
                  "endColumn": 62,
                  "charOffset": 31443,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(smu_table->metrics_table, table->cpu_addr, table_size)",
                    "rendered": {
                      "text": "memcpy(smu_table->metrics_table, table->cpu_addr, table_size)",
                      "markdown": "`memcpy(smu_table->metrics_table, table->cpu_addr, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31443,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(smu_table->metrics_table, <size of smu_table->metrics_table>,  table->cpu_addr,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-43c88419-4194-4d3c-9c4b-8e1cce04174c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                },
                "region": {
                  "startLine": 871,
                  "startColumn": 2,
                  "endLine": 871,
                  "endColumn": 61,
                  "charOffset": 29101,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(metrics_table, smu_table->metrics_table, table_size)",
                    "rendered": {
                      "text": "memcpy(metrics_table, smu_table->metrics_table, table_size)",
                      "markdown": "`memcpy(metrics_table, smu_table->metrics_table, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29101,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(metrics_table, <size of metrics_table>,  smu_table->metrics_table,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-87ecfff0-4eb0-44eb-842f-dad3ddf5d2e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                },
                "region": {
                  "startLine": 865,
                  "startColumn": 2,
                  "endLine": 865,
                  "endColumn": 63,
                  "charOffset": 28974,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(smu_table->metrics_table, table->cpu_addr, table_size)",
                    "rendered": {
                      "text": "memcpy(smu_table->metrics_table, table->cpu_addr, table_size)",
                      "markdown": "`memcpy(smu_table->metrics_table, table->cpu_addr, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28974,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(smu_table->metrics_table, <size of smu_table->metrics_table>,  table->cpu_addr,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a54c4c25-d1e7-4d58-bd2a-c505af5c1838",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                },
                "region": {
                  "startLine": 598,
                  "startColumn": 1,
                  "endLine": 600,
                  "endColumn": 18,
                  "charOffset": 18268,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18268,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af8d3209-5a53-4c74-8e9b-0c5586899bb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                },
                "region": {
                  "startLine": 587,
                  "startColumn": 1,
                  "endLine": 589,
                  "endColumn": 18,
                  "charOffset": 17787,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17787,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7c713b9e-4987-4ede-bf5b-1f0f28568deb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2306,
                  "startColumn": 2,
                  "endLine": 2306,
                  "endColumn": 66,
                  "charOffset": 76440,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 76440,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  user_od_table,  sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea99f8d9-5379-4c3c-a3e5-523037460287",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 1,
                  "endLine": 578,
                  "endColumn": 18,
                  "charOffset": 17345,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17345,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53606a2e-d05e-4e89-83c6-c09cd1601517",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2253,
                  "startColumn": 2,
                  "endLine": 2255,
                  "endColumn": 41,
                  "charOffset": 74129,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74129,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0bcce434-84e4-478f-8cf8-9fd1974c56cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2245,
                  "startColumn": 2,
                  "endLine": 2247,
                  "endColumn": 41,
                  "charOffset": 73854,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73854,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f700483d-6062-4179-96f7-2214795f7203",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2250,
                  "startColumn": 2,
                  "endLine": 2252,
                  "endColumn": 41,
                  "charOffset": 74032,
                  "charLength": 92,
                  "snippet": {
                    "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74032,
                        "charLength": 92
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&user_od_table_bak, <size of &user_od_table_bak>, \n\t\t       user_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58303d23-e133-4c07-bb47-29144a18911f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2236,
                  "startColumn": 1,
                  "endLine": 2238,
                  "endColumn": 40,
                  "charOffset": 73585,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73585,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t       boot_od_table, \n\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f9d902ea-4ed6-4053-a68d-d8c346b46225",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 2094,
                  "startColumn": 1,
                  "endLine": 2094,
                  "endColumn": 77,
                  "charOffset": 67610,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67610,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu13_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1bd350c6-523b-458b-bcad-05504edb392e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 1975,
                  "startColumn": 3,
                  "endLine": 1977,
                  "endColumn": 42,
                  "charOffset": 64531,
                  "charLength": 164,
                  "snippet": {
                    "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 64531,
                        "charLength": 164
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->user_overdrive_table + offset_of_voltageoffset, <size of table_context->user_overdrive_table + offset_of_voltageoffset>, \n\t\t\t       (u8 *)od_table + offset_of_voltageoffset, \n\t\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b1ae1912-5d47-4f2d-9a42-d02edc5b289a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 1948,
                  "startColumn": 3,
                  "endLine": 1950,
                  "endColumn": 41,
                  "charOffset": 63537,
                  "charLength": 104,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 63537,
                        "charLength": 104
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t\t       table_context->boot_overdrive_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3455f849-1cc2-4e38-9ce8-d5a76af59401",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 422,
                  "startColumn": 1,
                  "endLine": 422,
                  "endColumn": 68,
                  "charOffset": 17005,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)",
                    "rendered": {
                      "text": "memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)",
                      "markdown": "`memcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17005,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(BoardTable, <size of BoardTable>,  &smc_dpm_table->BoardTable,  sizeof(BoardTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7dd3cfa-3ba1-4abc-98a7-fb4404e02def",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 1,
                  "endLine": 394,
                  "endColumn": 25,
                  "charOffset": 16174,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16174,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-29967a8b-b31f-44cf-bfcc-ae5f90e0e10a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                },
                "region": {
                  "startLine": 1430,
                  "startColumn": 1,
                  "endLine": 1432,
                  "endColumn": 18,
                  "charOffset": 44056,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44056,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17344acc-feaa-477f-b195-31e8fb459b80",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                },
                "region": {
                  "startLine": 1415,
                  "startColumn": 1,
                  "endLine": 1417,
                  "endColumn": 18,
                  "charOffset": 43275,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43275,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-59eb3176-8518-46de-9f0b-c6e4b98fead3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                },
                "region": {
                  "startLine": 1403,
                  "startColumn": 1,
                  "endLine": 1405,
                  "endColumn": 18,
                  "charOffset": 42756,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 42756,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a6cbccd-f8b6-4249-9844-c0b8ca441f1d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2671,
                  "startColumn": 3,
                  "endLine": 2673,
                  "endColumn": 42,
                  "charOffset": 85306,
                  "charLength": 164,
                  "snippet": {
                    "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85306,
                        "charLength": 164
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->user_overdrive_table + offset_of_voltageoffset, <size of table_context->user_overdrive_table + offset_of_voltageoffset>, \n\t\t\t       (u8 *)od_table + offset_of_voltageoffset, \n\t\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-642be8a9-0f7f-4b27-97c8-b7da36efe7f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2644,
                  "startColumn": 3,
                  "endLine": 2646,
                  "endColumn": 41,
                  "charOffset": 84312,
                  "charLength": 104,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84312,
                        "charLength": 104
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t\t       table_context->boot_overdrive_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e3e5a335-9c64-4e8e-ad81-af5951e6eba9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2329,
                  "startColumn": 2,
                  "endLine": 2329,
                  "endColumn": 66,
                  "charOffset": 73976,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 73976,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  user_od_table,  sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5503dbfe-3d1d-4842-914b-b9cbe610d721",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2282,
                  "startColumn": 2,
                  "endLine": 2284,
                  "endColumn": 41,
                  "charOffset": 71967,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71967,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9e9f3f57-3c06-4d86-88c1-b26cce265632",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2279,
                  "startColumn": 2,
                  "endLine": 2281,
                  "endColumn": 41,
                  "charOffset": 71870,
                  "charLength": 92,
                  "snippet": {
                    "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71870,
                        "charLength": 92
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&user_od_table_bak, <size of &user_od_table_bak>, \n\t\t       user_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f8e6ab18-8d68-436c-811f-28432cd549d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2274,
                  "startColumn": 2,
                  "endLine": 2276,
                  "endColumn": 41,
                  "charOffset": 71692,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71692,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>, \n\t\t       boot_od_table, \n\t\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-768d5c23-f010-4013-9770-7527d6ac4fd3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 2265,
                  "startColumn": 1,
                  "endLine": 2267,
                  "endColumn": 40,
                  "charOffset": 71423,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                    "rendered": {
                      "text": "memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)",
                      "markdown": "`memcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71423,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>, \n\t       boot_od_table, \n\t       sizeof(OverDriveTableExternal_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-32f5b1ca-0d64-493c-be16-9db178b693fd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 1520,
                  "startColumn": 1,
                  "endLine": 1520,
                  "endColumn": 77,
                  "charOffset": 48208,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu14_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu14_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu14_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48208,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu14_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a2305d18-2d12-4e53-86cb-043618e964e3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                },
                "region": {
                  "startLine": 364,
                  "startColumn": 1,
                  "endLine": 365,
                  "endColumn": 25,
                  "charOffset": 14332,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14332,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07cd5cfb-89e1-4b6c-820f-618c4ba6986d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 1,
                  "endLine": 597,
                  "endColumn": 18,
                  "charOffset": 19806,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19806,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72822e67-5efa-4fa1-b47d-967752fb044f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                },
                "region": {
                  "startLine": 582,
                  "startColumn": 1,
                  "endLine": 584,
                  "endColumn": 18,
                  "charOffset": 19189,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19189,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc2dd26d-e1f5-40df-9a92-f314e24435ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                },
                "region": {
                  "startLine": 567,
                  "startColumn": 1,
                  "endLine": 569,
                  "endColumn": 18,
                  "charOffset": 18487,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_c0_activity[0],\n\t\t&metrics.CoreC0Residency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_c0_activity[0],\n\t\t&metrics.CoreC0Residency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_c0_activity[0],\n\t\t&metrics.CoreC0Residency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18487,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_c0_activity[0], <size of &gpu_metrics->average_core_c0_activity[0]>, \n\t\t&metrics.CoreC0Residency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-90a7633c-18e1-43c8-99eb-3e93692997a2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                },
                "region": {
                  "startLine": 564,
                  "startColumn": 1,
                  "endLine": 566,
                  "endColumn": 18,
                  "charOffset": 18392,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_ipu_activity[0],\n\t\t&metrics.IpuBusy[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_ipu_activity[0],\n\t\t&metrics.IpuBusy[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_ipu_activity[0],\n\t\t&metrics.IpuBusy[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18392,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_ipu_activity[0], <size of &gpu_metrics->average_ipu_activity[0]>, \n\t\t&metrics.IpuBusy[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d83c7d5a-1916-416d-81ce-13d6f8700739",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                },
                "region": {
                  "startLine": 557,
                  "startColumn": 1,
                  "endLine": 559,
                  "endColumn": 18,
                  "charOffset": 18124,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_0_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18124,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4b547c5-7f3c-48f6-9ddc-dcfca9511aa6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 3308,
                  "startColumn": 1,
                  "endLine": 3308,
                  "endColumn": 69,
                  "charOffset": 103471,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t)",
                    "rendered": {
                      "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t)",
                      "markdown": "`memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 103471,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&metrics, <size of &metrics>,  smu_table->metrics_table,  sizeof(SmuMetrics_NV12_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3fafcaa3-dd59-4f9d-b9aa-70472f53089b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 3233,
                  "startColumn": 1,
                  "endLine": 3233,
                  "endColumn": 76,
                  "charOffset": 100711,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_legacy_t)",
                    "rendered": {
                      "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_legacy_t)",
                      "markdown": "`memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_legacy_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 100711,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&metrics, <size of &metrics>,  smu_table->metrics_table,  sizeof(SmuMetrics_NV12_legacy_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7618688-ea51-488f-9cb6-733611650e02",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 3161,
                  "startColumn": 1,
                  "endLine": 3161,
                  "endColumn": 64,
                  "charOffset": 98102,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t)",
                    "rendered": {
                      "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t)",
                      "markdown": "`memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 98102,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&metrics, <size of &metrics>,  smu_table->metrics_table,  sizeof(SmuMetrics_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dae95026-6ef9-4205-b961-7964e2ba9bf1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2938,
                  "startColumn": 1,
                  "endLine": 2938,
                  "endColumn": 71,
                  "charOffset": 91595,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_legacy_t)",
                    "rendered": {
                      "text": "memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_legacy_t)",
                      "markdown": "`memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_legacy_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 91595,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&metrics, <size of &metrics>,  smu_table->metrics_table,  sizeof(SmuMetrics_legacy_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b5eb5bc7-df4d-429c-8444-c80ae760d183",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2849,
                  "startColumn": 2,
                  "endLine": 2849,
                  "endColumn": 43,
                  "charOffset": 89156,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(dummy_table, &DbiPrbs7[0], 0x1000)",
                    "rendered": {
                      "text": "memcpy(dummy_table, &DbiPrbs7[0], 0x1000)",
                      "markdown": "`memcpy(dummy_table, &DbiPrbs7[0], 0x1000)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89156,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dummy_table, <size of dummy_table>,  &DbiPrbs7[0],  0x1000)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-13f96dae-d0a2-4957-863d-3db3236984af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2847,
                  "startColumn": 2,
                  "endLine": 2847,
                  "endColumn": 45,
                  "charOffset": 89084,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(dummy_table, &NoDbiPrbs7[0], 0x1000)",
                    "rendered": {
                      "text": "memcpy(dummy_table, &NoDbiPrbs7[0], 0x1000)",
                      "markdown": "`memcpy(dummy_table, &NoDbiPrbs7[0], 0x1000)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89084,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dummy_table, <size of dummy_table>,  &NoDbiPrbs7[0],  0x1000)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-534ef6d4-80a4-47f1-8b2f-d9b1db5eb790",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2694,
                  "startColumn": 3,
                  "endLine": 2694,
                  "endColumn": 81,
                  "charOffset": 84605,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84605,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->user_overdrive_table, <size of table_context->user_overdrive_table>,  od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6059a25-fef0-4bc8-97e1-e2f83502a6e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2684,
                  "startColumn": 2,
                  "endLine": 2684,
                  "endColumn": 102,
                  "charOffset": 84144,
                  "charLength": 100,
                  "snippet": {
                    "text": "memcpy(table_context->overdrive_table, table_context->boot_overdrive_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->overdrive_table, table_context->boot_overdrive_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(table_context->overdrive_table, table_context->boot_overdrive_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 84144,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->overdrive_table, <size of table_context->overdrive_table>,  table_context->boot_overdrive_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a9149553-0653-4a80-bed6-a3b98af1737a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2585,
                  "startColumn": 1,
                  "endLine": 2585,
                  "endColumn": 62,
                  "charOffset": 81000,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 81000,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>,  boot_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-237c12ea-cbaf-4fb4-af61-15ffdb44efb1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2584,
                  "startColumn": 1,
                  "endLine": 2584,
                  "endColumn": 57,
                  "charOffset": 80940,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80940,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  boot_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4fa5f74f-bd5f-4527-a83d-69ddb667b26f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 2308,
                  "startColumn": 1,
                  "endLine": 2308,
                  "endColumn": 77,
                  "charOffset": 71599,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 71599,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu11_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bb910135-8ed0-4785-9e0d-e9b45a0c6829",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                },
                "region": {
                  "startLine": 465,
                  "startColumn": 1,
                  "endLine": 466,
                  "endColumn": 25,
                  "charOffset": 17582,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17582,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6acf755d-f5e6-4113-be63-3f38859e73ba",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c"
                },
                "region": {
                  "startLine": 1076,
                  "startColumn": 1,
                  "endLine": 1076,
                  "endColumn": 77,
                  "charOffset": 33393,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33393,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu11_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a503c0ee-23a4-4263-b70f-430201db13a4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 1,
                  "endLine": 504,
                  "endColumn": 25,
                  "charOffset": 18004,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18004,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-211ec22d-41d2-46c3-8fb8-3f6d7a1c6f75",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2429,
                  "startColumn": 2,
                  "endLine": 2429,
                  "endColumn": 58,
                  "charOffset": 79119,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(od_table, user_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(od_table, user_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79119,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  user_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-96aa2840-ad31-4ce2-9bbc-b3eff3a2d2a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2380,
                  "startColumn": 3,
                  "endLine": 2380,
                  "endColumn": 81,
                  "charOffset": 77761,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77761,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->user_overdrive_table, <size of table_context->user_overdrive_table>,  od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-830574d8-a553-46f7-869e-1d52db2a3b70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2367,
                  "startColumn": 2,
                  "endLine": 2369,
                  "endColumn": 28,
                  "charOffset": 77277,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(table_context->overdrive_table,\n\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\tsizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(table_context->overdrive_table,\n\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\tsizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(table_context->overdrive_table,\n\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\tsizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 77277,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->overdrive_table, <size of table_context->overdrive_table>, \n\t\t\t\ttable_context->boot_overdrive_table, \n\t\t\t\tsizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5c51e203-9a14-4479-8f41-e776d326e325",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2205,
                  "startColumn": 2,
                  "endLine": 2205,
                  "endColumn": 63,
                  "charOffset": 72541,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72541,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>,  boot_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d4e8899c-b22d-4997-bd1d-16e73e2c64aa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2204,
                  "startColumn": 2,
                  "endLine": 2204,
                  "endColumn": 68,
                  "charOffset": 72470,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72470,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&user_od_table_bak, <size of &user_od_table_bak>,  user_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-abed2ba1-1859-4728-bb70-068b8ee72e6b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2201,
                  "startColumn": 2,
                  "endLine": 2201,
                  "endColumn": 63,
                  "charOffset": 72318,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72318,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(user_od_table, <size of user_od_table>,  boot_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-26a000fc-402a-42a4-b269-564f7d1ebe7d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2194,
                  "startColumn": 1,
                  "endLine": 2194,
                  "endColumn": 57,
                  "charOffset": 72073,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)",
                    "rendered": {
                      "text": "memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)",
                      "markdown": "`memcpy(od_table, boot_od_table, sizeof(OverDriveTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72073,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(od_table, <size of od_table>,  boot_od_table,  sizeof(OverDriveTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3e13b00f-6098-4478-a9a2-e39daf591944",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 2056,
                  "startColumn": 1,
                  "endLine": 2056,
                  "endColumn": 77,
                  "charOffset": 67457,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                    "rendered": {
                      "text": "memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)",
                      "markdown": "`memcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67457,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(range, <size of range>,  &smu11_thermal_policy[0],  sizeof(struct smu_temperature_range)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c65f4d4-4d89-41b7-a61a-d41c970c3617",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                },
                "region": {
                  "startLine": 472,
                  "startColumn": 1,
                  "endLine": 473,
                  "endColumn": 19,
                  "charOffset": 18067,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       table_size)",
                    "rendered": {
                      "text": "memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       table_size)",
                      "markdown": "`memcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18067,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_context->driver_pptable, <size of table_context->driver_pptable>,  &powerplay_table->smc_pptable, \n\t       table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-43a5df3f-ebc1-4e85-a9c2-ccfc28323263",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1970,
                  "startColumn": 1,
                  "endLine": 1972,
                  "endColumn": 18,
                  "charOffset": 59342,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59342,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.Average.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc01bd2f-0dd4-407c-a6eb-17a0998cda5b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1988,
                  "startColumn": 1,
                  "endLine": 1990,
                  "endColumn": 18,
                  "charOffset": 60252,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 60252,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.Current.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-11db823e-4c32-46da-91ca-60c6bb855ff5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1958,
                  "startColumn": 1,
                  "endLine": 1960,
                  "endColumn": 18,
                  "charOffset": 58781,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58781,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.Current.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6812d2da-d0c3-4318-a6ff-3bc98830b517",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1924,
                  "startColumn": 1,
                  "endLine": 1926,
                  "endColumn": 24,
                  "charOffset": 57708,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t       &metrics.Current.CoreFrequency[0],\n\t       sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t       &metrics.Current.CoreFrequency[0],\n\t       sizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t       &metrics.Current.CoreFrequency[0],\n\t       sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 57708,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t       &metrics.Current.CoreFrequency[0], \n\t       sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28ae68bd-b3bc-47c6-adb0-34de06e52820",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1906,
                  "startColumn": 1,
                  "endLine": 1908,
                  "endColumn": 24,
                  "charOffset": 56786,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t       &metrics.Average.CorePower[0],\n\t       sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t       &metrics.Average.CorePower[0],\n\t       sizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t       &metrics.Average.CorePower[0],\n\t       sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56786,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t       &metrics.Average.CorePower[0], \n\t       sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-17be74b7-e520-454a-9a6f-71b3ec84af0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1885,
                  "startColumn": 1,
                  "endLine": 1887,
                  "endColumn": 24,
                  "charOffset": 55810,
                  "charLength": 119,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_temperature_core[0],\n\t       &metrics.Average.CoreTemperature[0],\n\t       sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_temperature_core[0],\n\t       &metrics.Average.CoreTemperature[0],\n\t       sizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_temperature_core[0],\n\t       &metrics.Average.CoreTemperature[0],\n\t       sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55810,
                        "charLength": 119
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_temperature_core[0], <size of &gpu_metrics->average_temperature_core[0]>, \n\t       &metrics.Average.CoreTemperature[0], \n\t       sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-518c829d-972a-43a9-b7a0-c083fc200cb9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1844,
                  "startColumn": 1,
                  "endLine": 1846,
                  "endColumn": 18,
                  "charOffset": 54411,
                  "charLength": 96,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 54411,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.Current.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76af2667-52de-41a6-a285-a0878e08d026",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1878,
                  "startColumn": 1,
                  "endLine": 1880,
                  "endColumn": 24,
                  "charOffset": 55478,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t       &metrics.Current.CoreTemperature[0],\n\t       sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t       &metrics.Current.CoreTemperature[0],\n\t       sizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t       &metrics.Current.CoreTemperature[0],\n\t       sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 55478,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t       &metrics.Current.CoreTemperature[0], \n\t       sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bd26f877-11f2-4724-a401-c269178dc72e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1826,
                  "startColumn": 1,
                  "endLine": 1828,
                  "endColumn": 18,
                  "charOffset": 53501,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 53501,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.Average.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dec80d3a-17ed-497d-9ee3-0f6aee15224f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1814,
                  "startColumn": 1,
                  "endLine": 1816,
                  "endColumn": 18,
                  "charOffset": 52924,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_temperature_core[0],\n\t\t&metrics.Average.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_temperature_core[0],\n\t\t&metrics.Average.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_temperature_core[0],\n\t\t&metrics.Average.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52924,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_temperature_core[0], <size of &gpu_metrics->average_temperature_core[0]>, \n\t\t&metrics.Average.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-067aad44-4931-4580-8fbe-7417e68f8982",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1807,
                  "startColumn": 1,
                  "endLine": 1809,
                  "endColumn": 18,
                  "charOffset": 52604,
                  "charLength": 99,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 52604,
                        "charLength": 99
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.Current.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3262104d-caba-41e6-84bf-c0b45029c62d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1773,
                  "startColumn": 1,
                  "endLine": 1775,
                  "endColumn": 18,
                  "charOffset": 51570,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51570,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6d062f80-435b-45ec-b921-81b6d2f9abda",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1762,
                  "startColumn": 1,
                  "endLine": 1764,
                  "endColumn": 18,
                  "charOffset": 51089,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51089,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2e83c8fd-d8ec-4422-9a87-668ded9fd117",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1750,
                  "startColumn": 1,
                  "endLine": 1752,
                  "endColumn": 18,
                  "charOffset": 50592,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 50592,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bbc0fd15-2028-4f6c-a9e7-5c4b8b6e6a43",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1716,
                  "startColumn": 1,
                  "endLine": 1718,
                  "endColumn": 18,
                  "charOffset": 49565,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49565,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->current_coreclk[0], <size of &gpu_metrics->current_coreclk[0]>, \n\t\t&metrics.CoreFrequency[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19a69283-e65c-487c-87b0-5dcfd59f59fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1705,
                  "startColumn": 1,
                  "endLine": 1707,
                  "endColumn": 18,
                  "charOffset": 49084,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 49084,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->average_core_power[0], <size of &gpu_metrics->average_core_power[0]>, \n\t\t&metrics.CorePower[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c53e71bf-7152-4694-b697-5760cbeeb8d2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 1693,
                  "startColumn": 1,
                  "endLine": 1695,
                  "endColumn": 18,
                  "charOffset": 48587,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)",
                      "markdown": "`memcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48587,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&gpu_metrics->temperature_core[0], <size of &gpu_metrics->temperature_core[0]>, \n\t\t&metrics.CoreTemperature[0], \n\t\tsizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6b1da25-de8d-4103-874b-b12b91ced84b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 2,
                  "endLine": 404,
                  "endColumn": 45,
                  "charOffset": 15894,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(value, &metrics->Current.CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(value, &metrics->Current.CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)",
                      "markdown": "`memcpy(value, &metrics->Current.CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15894,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  &metrics->Current.CoreFrequency[0], \n\t\t       smu->cpu_core_num * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-27091760-4f91-4ce3-b52c-512b4669567a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 2,
                  "endLine": 331,
                  "endColumn": 45,
                  "charOffset": 14029,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(value, &metrics->CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(value, &metrics->CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)",
                      "markdown": "`memcpy(value, &metrics->CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14029,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(value, <size of value>,  &metrics->CoreFrequency[0], \n\t\t       smu->cpu_core_num * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4df4b10c-e07b-48cf-8975-2cca4c2bcc26",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 2,
                  "endLine": 267,
                  "endColumn": 62,
                  "charOffset": 6622,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(hwmgr->current_ps, hwmgr->request_ps, hwmgr->ps_size)",
                    "rendered": {
                      "text": "memcpy(hwmgr->current_ps, hwmgr->request_ps, hwmgr->ps_size)",
                      "markdown": "`memcpy(hwmgr->current_ps, hwmgr->request_ps, hwmgr->ps_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6622,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hwmgr->current_ps, <size of hwmgr->current_ps>,  hwmgr->request_ps,  hwmgr->ps_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e3f6017e-f733-4422-b1ef-89daa6b7fd28",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 3,
                  "endLine": 177,
                  "endColumn": 51,
                  "charOffset": 4629,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(hwmgr->request_ps, state, hwmgr->ps_size)",
                    "rendered": {
                      "text": "memcpy(hwmgr->request_ps, state, hwmgr->ps_size)",
                      "markdown": "`memcpy(hwmgr->request_ps, state, hwmgr->ps_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4629,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hwmgr->request_ps, <size of hwmgr->request_ps>,  state,  hwmgr->ps_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f300b0cd-4e40-4283-b1bb-c9aeb69362ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 3,
                  "endLine": 93,
                  "endColumn": 41,
                  "charOffset": 2841,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(hwmgr->request_ps, state, size)",
                    "rendered": {
                      "text": "memcpy(hwmgr->request_ps, state, size)",
                      "markdown": "`memcpy(hwmgr->request_ps, state, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2841,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hwmgr->request_ps, <size of hwmgr->request_ps>,  state,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-081157b4-e177-416a-8d6b-27ffe8468077",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 3,
                  "endLine": 92,
                  "endColumn": 41,
                  "charOffset": 2798,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(hwmgr->current_ps, state, size)",
                    "rendered": {
                      "text": "memcpy(hwmgr->current_ps, state, size)",
                      "markdown": "`memcpy(hwmgr->current_ps, state, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/pp_psm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2798,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hwmgr->current_ps, <size of hwmgr->current_ps>,  state,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-887b5fe2-9537-4c75-aa12-7485df57b076",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 5621,
                  "startColumn": 2,
                  "endLine": 5621,
                  "endColumn": 87,
                  "charOffset": 179084,
                  "charLength": 85,
                  "snippet": {
                    "text": "memcpy(&(data->dpm_table), &(data->golden_dpm_table), sizeof(struct vega10_dpm_table)",
                    "rendered": {
                      "text": "memcpy(&(data->dpm_table), &(data->golden_dpm_table), sizeof(struct vega10_dpm_table)",
                      "markdown": "`memcpy(&(data->dpm_table), &(data->golden_dpm_table), sizeof(struct vega10_dpm_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 179084,
                        "charLength": 85
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(data->dpm_table), <size of &(data->dpm_table)>,  &(data->golden_dpm_table),  sizeof(struct vega10_dpm_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bd0e9e86-c8d6-499c-ad58-71ed823ddde5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 5296,
                  "startColumn": 1,
                  "endLine": 5296,
                  "endColumn": 88,
                  "charOffset": 167065,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                    "rendered": {
                      "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                      "markdown": "`memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 167065,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(thermal_data, <size of thermal_data>,  &SMU7ThermalWithDelayPolicy[0],  sizeof(struct PP_TemperatureRange)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-376cd684-3a6a-4f72-bcae-46541f9e6aa2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4957,
                  "startColumn": 11,
                  "endLine": 4957,
                  "endColumn": 18,
                  "charOffset": 156925,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-451b4b0f-1b36-4770-95fe-8d3f200a28c4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4954,
                  "startColumn": 11,
                  "endLine": 4954,
                  "endColumn": 18,
                  "charOffset": 156742,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14bb293c-67d9-4c8f-a88e-6e37255d4a5f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4951,
                  "startColumn": 11,
                  "endLine": 4951,
                  "endColumn": 18,
                  "charOffset": 156559,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0c2dffa2-40d5-402f-9cb9-224695700a57",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4950,
                  "startColumn": 11,
                  "endLine": 4950,
                  "endColumn": 18,
                  "charOffset": 156506,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f6f70b22-5a22-4494-8694-b8a394efb120",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4943,
                  "startColumn": 12,
                  "endLine": 4943,
                  "endColumn": 19,
                  "charOffset": 156315,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9fa9f1e6-f062-49b0-aeb3-06da52d73b68",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4940,
                  "startColumn": 11,
                  "endLine": 4940,
                  "endColumn": 18,
                  "charOffset": 156161,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1f43816e-51e0-4830-905b-800da6799f56",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4933,
                  "startColumn": 12,
                  "endLine": 4933,
                  "endColumn": 19,
                  "charOffset": 155969,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-051b5947-7afd-4429-8b6e-ee0c95e7223a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4930,
                  "startColumn": 11,
                  "endLine": 4930,
                  "endColumn": 18,
                  "charOffset": 155815,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b060d88b-9c1c-449a-80ea-f33b3f888a7a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4911,
                  "startColumn": 11,
                  "endLine": 4911,
                  "endColumn": 18,
                  "charOffset": 155257,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dff8f7f1-9ba9-4ed2-8679-929836c59bb7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4897,
                  "startColumn": 11,
                  "endLine": 4897,
                  "endColumn": 18,
                  "charOffset": 154791,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b024568f-94c0-4691-864b-8088c93de093",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4883,
                  "startColumn": 11,
                  "endLine": 4883,
                  "endColumn": 18,
                  "charOffset": 154411,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f5ea91bb-6969-43e3-9049-52ad77b4a32a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4870,
                  "startColumn": 11,
                  "endLine": 4870,
                  "endColumn": 18,
                  "charOffset": 154059,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-721e4f02-765e-428c-8f2f-1918b917e3f9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 4857,
                  "startColumn": 11,
                  "endLine": 4857,
                  "endColumn": 18,
                  "charOffset": 153712,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7aaebf53-c1dd-445d-af91-27e134ee2103",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 1464,
                  "startColumn": 1,
                  "endLine": 1465,
                  "endColumn": 34,
                  "charOffset": 48820,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega10_dpm_table)",
                    "rendered": {
                      "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega10_dpm_table)",
                      "markdown": "`memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega10_dpm_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48820,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(data->golden_dpm_table), <size of &(data->golden_dpm_table)>,  &(data->dpm_table), \n\t\t\tsizeof(struct vega10_dpm_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b71c95c7-47c3-4d54-828c-a09e2eb02d3d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                },
                "region": {
                  "startLine": 1060,
                  "startColumn": 1,
                  "endLine": 1060,
                  "endColumn": 68,
                  "charOffset": 36426,
                  "charLength": 67,
                  "snippet": {
                    "text": "memcpy(vol_table, table, sizeof(struct pp_atomfwctrl_voltage_table)",
                    "rendered": {
                      "text": "memcpy(vol_table, table, sizeof(struct pp_atomfwctrl_voltage_table)",
                      "markdown": "`memcpy(vol_table, table, sizeof(struct pp_atomfwctrl_voltage_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36426,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vol_table, <size of vol_table>,  table,  sizeof(struct pp_atomfwctrl_voltage_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76285e7d-1aee-44c2-9247-637dffc4b7f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 4238,
                  "startColumn": 1,
                  "endLine": 4238,
                  "endColumn": 88,
                  "charOffset": 136496,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                    "rendered": {
                      "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                      "markdown": "`memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 136496,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(thermal_data, <size of thermal_data>,  &SMU7ThermalWithDelayPolicy[0],  sizeof(struct PP_TemperatureRange)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b9030abc-5c74-4fa7-820b-8ce73de1bbdc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3572,
                  "startColumn": 11,
                  "endLine": 3572,
                  "endColumn": 18,
                  "charOffset": 113649,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-871ee7ee-9304-474d-a569-8a4e98f0bb0c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3569,
                  "startColumn": 11,
                  "endLine": 3569,
                  "endColumn": 18,
                  "charOffset": 113469,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-56f17130-38aa-454e-8990-4a74834416cb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3566,
                  "startColumn": 11,
                  "endLine": 3566,
                  "endColumn": 18,
                  "charOffset": 113285,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d555fe9d-9f8b-48cb-9fcd-bedb2feb2607",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3563,
                  "startColumn": 11,
                  "endLine": 3563,
                  "endColumn": 18,
                  "charOffset": 113105,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b28ab71e-6024-4702-815f-e7364268d5d2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3560,
                  "startColumn": 11,
                  "endLine": 3560,
                  "endColumn": 18,
                  "charOffset": 112921,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f51778ad-2fcb-4867-8c67-98209764850e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3557,
                  "startColumn": 11,
                  "endLine": 3557,
                  "endColumn": 18,
                  "charOffset": 112741,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a80da833-5236-4da5-9a02-79b04699412b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3546,
                  "startColumn": 11,
                  "endLine": 3546,
                  "endColumn": 18,
                  "charOffset": 112213,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5676308d-4428-4783-be86-87ff3ffdffcb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3540,
                  "startColumn": 11,
                  "endLine": 3540,
                  "endColumn": 18,
                  "charOffset": 111988,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6974ac7-d744-41bc-aa96-bed7507ac9e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3536,
                  "startColumn": 10,
                  "endLine": 3536,
                  "endColumn": 17,
                  "charOffset": 111818,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6bd41499-fad1-4a26-b492-48803d677c6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3528,
                  "startColumn": 11,
                  "endLine": 3528,
                  "endColumn": 18,
                  "charOffset": 111663,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ad923652-08d0-4177-b073-b181bcff8310",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3525,
                  "startColumn": 11,
                  "endLine": 3525,
                  "endColumn": 18,
                  "charOffset": 111538,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-302abe1b-f7c9-4d62-bceb-80b8ea1ca070",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3522,
                  "startColumn": 11,
                  "endLine": 3522,
                  "endColumn": 18,
                  "charOffset": 111413,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-18ace9c1-e45d-4644-ba47-6f4eb2320d29",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3521,
                  "startColumn": 11,
                  "endLine": 3521,
                  "endColumn": 18,
                  "charOffset": 111355,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f2dc0ee2-6552-43e4-889d-d2c0391586ae",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3508,
                  "startColumn": 11,
                  "endLine": 3508,
                  "endColumn": 18,
                  "charOffset": 110884,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5634e058-3f0f-4c60-aa3f-399f17815aee",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3507,
                  "startColumn": 11,
                  "endLine": 3507,
                  "endColumn": 18,
                  "charOffset": 110832,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-41e2e616-dbe5-4c27-98a9-8a4daed6ec1e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3500,
                  "startColumn": 11,
                  "endLine": 3500,
                  "endColumn": 18,
                  "charOffset": 110673,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-27e926ee-30ec-48b5-ba9e-b43ee066c23a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3498,
                  "startColumn": 11,
                  "endLine": 3498,
                  "endColumn": 18,
                  "charOffset": 110599,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-37458e99-65c5-4ae0-8f22-0c71042b4ee0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3497,
                  "startColumn": 11,
                  "endLine": 3497,
                  "endColumn": 18,
                  "charOffset": 110547,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e217ae38-9f37-4733-a8a0-73e30325c20a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3476,
                  "startColumn": 11,
                  "endLine": 3476,
                  "endColumn": 18,
                  "charOffset": 109867,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1437a77e-0aa2-420c-8ea3-3f8f6cab212f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3462,
                  "startColumn": 11,
                  "endLine": 3462,
                  "endColumn": 18,
                  "charOffset": 109413,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b8b1f54d-44b3-439d-a596-b502201f34a5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3456,
                  "startColumn": 11,
                  "endLine": 3456,
                  "endColumn": 18,
                  "charOffset": 109278,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-60b74053-5db8-44c0-b7af-5c1475de5630",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3444,
                  "startColumn": 11,
                  "endLine": 3444,
                  "endColumn": 18,
                  "charOffset": 108880,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-822229bc-6b2e-46e6-b2d5-82db276795b4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3432,
                  "startColumn": 11,
                  "endLine": 3432,
                  "endColumn": 18,
                  "charOffset": 108500,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-041c4c7e-5285-471a-b63e-a8b867f6f9aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3426,
                  "startColumn": 11,
                  "endLine": 3426,
                  "endColumn": 18,
                  "charOffset": 108365,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76d528b6-f20e-4da1-9965-722972f8f947",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3414,
                  "startColumn": 11,
                  "endLine": 3414,
                  "endColumn": 18,
                  "charOffset": 107979,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-373fc107-b757-487f-ad2a-b3bc15ad089a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3408,
                  "startColumn": 11,
                  "endLine": 3408,
                  "endColumn": 18,
                  "charOffset": 107844,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1efbbe90-277d-47d4-adfe-bdce8c453c82",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3396,
                  "startColumn": 11,
                  "endLine": 3396,
                  "endColumn": 18,
                  "charOffset": 107464,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-945c52b6-430b-48c0-b647-97022e32ca61",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 3390,
                  "startColumn": 11,
                  "endLine": 3390,
                  "endColumn": 18,
                  "charOffset": 107329,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-06236901-ef68-4e8d-95fb-edebcbc0eaa8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 2138,
                  "startColumn": 2,
                  "endLine": 2138,
                  "endColumn": 66,
                  "charOffset": 72447,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)",
                    "rendered": {
                      "text": "memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)",
                      "markdown": "`memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 72447,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(metrics_table, <size of metrics_table>,  &data->metrics_table,  sizeof(SmuMetrics_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d080e881-0f58-4fc5-990b-71d634d6d4fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 823,
                  "startColumn": 1,
                  "endLine": 823,
                  "endColumn": 69,
                  "charOffset": 28503,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)",
                      "markdown": "`memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28503,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pp_table, <size of pp_table>,  pptable_information->smc_pptable,  sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1602f932-8bbf-4c52-af55-804c4e4f2f03",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 1,
                  "endLine": 779,
                  "endColumn": 34,
                  "charOffset": 26831,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega20_dpm_table)",
                    "rendered": {
                      "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega20_dpm_table)",
                      "markdown": "`memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega20_dpm_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26831,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(data->golden_dpm_table), <size of &(data->golden_dpm_table)>,  &(data->dpm_table), \n\t\t\tsizeof(struct vega20_dpm_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15a63041-1c2d-4ff8-a6ad-640ee6fbf762",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5685,
                  "startColumn": 2,
                  "endLine": 5685,
                  "endColumn": 73,
                  "charOffset": 187746,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(&tmp, &smu7_profiling[mode], sizeof(struct profile_mode_setting)",
                    "rendered": {
                      "text": "memcpy(&tmp, &smu7_profiling[mode], sizeof(struct profile_mode_setting)",
                      "markdown": "`memcpy(&tmp, &smu7_profiling[mode], sizeof(struct profile_mode_setting)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 187746,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&tmp, <size of &tmp>,  &smu7_profiling[mode],  sizeof(struct profile_mode_setting)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8392cbb6-1466-4a96-9e91-1dd6f16d1261",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5673,
                  "startColumn": 3,
                  "endLine": 5673,
                  "endColumn": 83,
                  "charOffset": 187374,
                  "charLength": 80,
                  "snippet": {
                    "text": "memcpy(&data->current_profile_setting, &tmp, sizeof(struct profile_mode_setting)",
                    "rendered": {
                      "text": "memcpy(&data->current_profile_setting, &tmp, sizeof(struct profile_mode_setting)",
                      "markdown": "`memcpy(&data->current_profile_setting, &tmp, sizeof(struct profile_mode_setting)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 187374,
                        "charLength": 80
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data->current_profile_setting, <size of &data->current_profile_setting>,  &tmp,  sizeof(struct profile_mode_setting)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7547a0d-c020-4314-93e2-01cd96c9c7df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5441,
                  "startColumn": 1,
                  "endLine": 5441,
                  "endColumn": 79,
                  "charOffset": 179803,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)",
                    "rendered": {
                      "text": "memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)",
                      "markdown": "`memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 179803,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(thermal_data, <size of thermal_data>,  &SMU7ThermalPolicy[0],  sizeof(struct PP_TemperatureRange)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-914a252c-b141-4b44-990e-e9df6fde9174",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5053,
                  "startColumn": 11,
                  "endLine": 5053,
                  "endColumn": 18,
                  "charOffset": 167695,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-81c2f999-3685-48c2-bdba-ab2c117a4666",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5050,
                  "startColumn": 11,
                  "endLine": 5050,
                  "endColumn": 18,
                  "charOffset": 167511,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d2862a4c-76e6-4d06-a035-9d5290290173",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5047,
                  "startColumn": 11,
                  "endLine": 5047,
                  "endColumn": 18,
                  "charOffset": 167327,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc53b50c-5814-4a8d-8671-a8fdf84535b6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5046,
                  "startColumn": 11,
                  "endLine": 5046,
                  "endColumn": 18,
                  "charOffset": 167274,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-de5cd990-e4ef-4b18-b009-287c0bd86118",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5039,
                  "startColumn": 12,
                  "endLine": 5039,
                  "endColumn": 19,
                  "charOffset": 167078,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c870e37-9e3b-4e57-90ec-52e4b889b9a7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5037,
                  "startColumn": 11,
                  "endLine": 5037,
                  "endColumn": 18,
                  "charOffset": 166974,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3c289225-8c03-4f11-9bfb-b0c814df4af1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5030,
                  "startColumn": 12,
                  "endLine": 5030,
                  "endColumn": 19,
                  "charOffset": 166779,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c3e49b81-67df-4c82-b44c-1dc584f0c0f8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5028,
                  "startColumn": 11,
                  "endLine": 5028,
                  "endColumn": 18,
                  "charOffset": 166675,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-62bb37dd-1437-4e35-ac15-aa20709d78eb",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5020,
                  "startColumn": 11,
                  "endLine": 5020,
                  "endColumn": 18,
                  "charOffset": 166354,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-51eecb69-239e-4064-8f7b-0ef548a6a422",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 5006,
                  "startColumn": 11,
                  "endLine": 5006,
                  "endColumn": 18,
                  "charOffset": 165974,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4130f382-b81e-4585-a896-e4b81524fe18",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 4990,
                  "startColumn": 11,
                  "endLine": 4990,
                  "endColumn": 18,
                  "charOffset": 165548,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-280069ac-1a9e-406d-aa50-11d4048a0881",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                },
                "region": {
                  "startLine": 1073,
                  "startColumn": 1,
                  "endLine": 1074,
                  "endColumn": 32,
                  "charOffset": 37454,
                  "charLength": 86,
                  "snippet": {
                    "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct smu7_dpm_table)",
                    "rendered": {
                      "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct smu7_dpm_table)",
                      "markdown": "`memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct smu7_dpm_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37454,
                        "charLength": 86
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(data->golden_dpm_table), <size of &(data->golden_dpm_table)>,  &(data->dpm_table), \n\t\t\tsizeof(struct smu7_dpm_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3ebd6d3e-137c-437e-9bd9-16ee7b588b9c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.c"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 1,
                  "endLine": 242,
                  "endColumn": 66,
                  "charOffset": 6160,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table)",
                    "rendered": {
                      "text": "memcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table)",
                      "markdown": "`memcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6160,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vol_table, <size of vol_table>,  table,  sizeof(struct pp_atomctrl_voltage_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-86c9c26e-83fa-4d19-93b8-8917b4ea597d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c"
                },
                "region": {
                  "startLine": 1871,
                  "startColumn": 1,
                  "endLine": 1871,
                  "endColumn": 79,
                  "charOffset": 51753,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)",
                    "rendered": {
                      "text": "memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)",
                      "markdown": "`memcpy(thermal_data, &SMU7ThermalPolicy[0], sizeof(struct PP_TemperatureRange)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 51753,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(thermal_data, <size of thermal_data>,  &SMU7ThermalPolicy[0],  sizeof(struct PP_TemperatureRange)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f6e3f6d3-cf04-4e30-b759-3510161f7b1a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c"
                },
                "region": {
                  "startLine": 1597,
                  "startColumn": 11,
                  "endLine": 1597,
                  "endColumn": 18,
                  "charOffset": 43482,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-770f80da-393c-4617-8a46-ffff540e3a11",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c"
                },
                "region": {
                  "startLine": 1585,
                  "startColumn": 11,
                  "endLine": 1585,
                  "endColumn": 18,
                  "charOffset": 43107,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b5ecb438-ed98-4441-af6f-bbbb220e3b96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 2782,
                  "startColumn": 1,
                  "endLine": 2782,
                  "endColumn": 88,
                  "charOffset": 85855,
                  "charLength": 87,
                  "snippet": {
                    "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                    "rendered": {
                      "text": "memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)",
                      "markdown": "`memcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 85855,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "memcpy_s(thermal_data, <size of thermal_data>,  &SMU7ThermalWithDelayPolicy[0],  sizeof(struct PP_TemperatureRange)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e29b2aef-1d49-4f0e-a38b-d3aefe12e689",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 2344,
                  "startColumn": 11,
                  "endLine": 2344,
                  "endColumn": 18,
                  "charOffset": 70656,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5248fc02-226d-4313-8fec-318106f3d062",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 2326,
                  "startColumn": 11,
                  "endLine": 2326,
                  "endColumn": 18,
                  "charOffset": 70078,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25300bf7-55f0-4dd5-a851-c035e5fbaecf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 2308,
                  "startColumn": 11,
                  "endLine": 2308,
                  "endColumn": 18,
                  "charOffset": 69499,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76c0cab9-258d-4cbd-88ff-e3d48982ee2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 2292,
                  "startColumn": 11,
                  "endLine": 2292,
                  "endColumn": 18,
                  "charOffset": 68997,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-78e40708-d38e-45f3-bb82-77175c3125e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 1408,
                  "startColumn": 2,
                  "endLine": 1408,
                  "endColumn": 66,
                  "charOffset": 45909,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)",
                    "rendered": {
                      "text": "memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)",
                      "markdown": "`memcpy(metrics_table, &data->metrics_table, sizeof(SmuMetrics_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45909,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(metrics_table, <size of metrics_table>,  &data->metrics_table,  sizeof(SmuMetrics_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-306b4486-6be0-4237-a266-f9024ff6e472",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 849,
                  "startColumn": 1,
                  "endLine": 849,
                  "endColumn": 69,
                  "charOffset": 30032,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)",
                    "rendered": {
                      "text": "memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)",
                      "markdown": "`memcpy(pp_table, pptable_information->smc_pptable, sizeof(PPTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30032,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pp_table, <size of pp_table>,  pptable_information->smc_pptable,  sizeof(PPTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b9a6ee7d-92ca-4d2a-92c3-5915847afceb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 1,
                  "endLine": 779,
                  "endColumn": 34,
                  "charOffset": 27622,
                  "charLength": 88,
                  "snippet": {
                    "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega12_dpm_table)",
                    "rendered": {
                      "text": "memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega12_dpm_table)",
                      "markdown": "`memcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega12_dpm_table)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega12_hwmgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27622,
                        "charLength": 88
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(data->golden_dpm_table), <size of &(data->golden_dpm_table)>,  &(data->dpm_table), \n\t\t\tsizeof(struct vega12_dpm_table)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6430a3c4-30b6-4ba2-88be-77f27d4be0f8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1099,
                  "startColumn": 11,
                  "endLine": 1099,
                  "endColumn": 18,
                  "charOffset": 31525,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-43aa1c77-c828-4df0-a770-7cfc7f4b793e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1098,
                  "startColumn": 11,
                  "endLine": 1098,
                  "endColumn": 18,
                  "charOffset": 31472,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a8acd5e-b1c7-430d-93e7-0d65de83d58b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1085,
                  "startColumn": 11,
                  "endLine": 1085,
                  "endColumn": 18,
                  "charOffset": 31062,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9329372a-712e-4a2f-8f71-31596356a6c2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1083,
                  "startColumn": 11,
                  "endLine": 1083,
                  "endColumn": 18,
                  "charOffset": 30929,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-738748b7-adab-40df-a3be-b845d98bad64",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1082,
                  "startColumn": 11,
                  "endLine": 1082,
                  "endColumn": 18,
                  "charOffset": 30877,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0e5926e5-887d-476d-a7e8-62f8bb68af4d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1057,
                  "startColumn": 10,
                  "endLine": 1057,
                  "endColumn": 17,
                  "charOffset": 30169,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-82cf17f5-053a-4d71-8365-652ba50b07db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1067,
                  "startColumn": 11,
                  "endLine": 1067,
                  "endColumn": 18,
                  "charOffset": 30441,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f205812-dcdb-45d2-8cd7-0b9b0d5b6530",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1054,
                  "startColumn": 10,
                  "endLine": 1054,
                  "endColumn": 17,
                  "charOffset": 30052,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c97b3f5f-3818-41a2-830f-121e09ea4eda",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c"
                },
                "region": {
                  "startLine": 1051,
                  "startColumn": 10,
                  "endLine": 1051,
                  "endColumn": 17,
                  "charOffset": 29945,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-859785c1-7c99-4645-8c6d-e8baf0a148e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega10_smumgr.c"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 1,
                  "endLine": 91,
                  "endColumn": 41,
                  "charOffset": 3177,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega10_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3177,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(priv->smu_tables.entry[table_id].table, <size of priv->smu_tables.entry[table_id].table>,  table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d78b9e83-5f5f-479a-ae65-a221bde243bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega10_smumgr.c"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 1,
                  "endLine": 66,
                  "endColumn": 41,
                  "charOffset": 2409,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega10_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2409,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table, <size of table>,  priv->smu_tables.entry[table_id].table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9973cb18-3e30-4dee-a0aa-ceee540bbb6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega12_smumgr.c"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 1,
                  "endLine": 99,
                  "endColumn": 41,
                  "charOffset": 3654,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega12_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3654,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(priv->smu_tables.entry[table_id].table, <size of priv->smu_tables.entry[table_id].table>,  table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-54d8a526-92f0-49c8-b9de-23dc3348bfcc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega12_smumgr.c"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 1,
                  "endLine": 74,
                  "endColumn": 41,
                  "charOffset": 2848,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega12_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2848,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table, <size of table>,  priv->smu_tables.entry[table_id].table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25e7f557-5af7-4e0b-a8b4-12f021c6b88c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/smu10_smumgr.c"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 1,
                  "endLine": 165,
                  "endColumn": 41,
                  "charOffset": 4941,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/smu10_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4941,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(priv->smu_tables.entry[table_id].table, <size of priv->smu_tables.entry[table_id].table>,  table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c643d50d-8826-4c2a-80e7-7b95c60d05ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 1,
                  "endLine": 312,
                  "endColumn": 61,
                  "charOffset": 10201,
                  "charLength": 135,
                  "snippet": {
                    "text": "memcpy(table, priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)",
                    "rendered": {
                      "text": "memcpy(table, priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)",
                      "markdown": "`memcpy(table, priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10201,
                        "charLength": 135
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table, <size of table>,  priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, \n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-60246e89-c078-4e63-bfa4-a9c799c51fe0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/smu10_smumgr.c"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 1,
                  "endLine": 145,
                  "endColumn": 41,
                  "charOffset": 4271,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(table, (uint8_t *)priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(table, (uint8_t *)priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(table, (uint8_t *)priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/smu10_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4271,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table, <size of table>,  (uint8_t *)priv->smu_tables.entry[table_id].table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b3b76b79-43cd-4e15-a16d-34c80da9b0f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 1,
                  "endLine": 257,
                  "endColumn": 61,
                  "charOffset": 8065,
                  "charLength": 135,
                  "snippet": {
                    "text": "memcpy(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)",
                    "rendered": {
                      "text": "memcpy(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)",
                      "markdown": "`memcpy(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8065,
                        "charLength": 135
                      },
                      "insertedContent": {
                        "text": "memcpy_s(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, <size of priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table>,  table, \n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3b44f226-cbfa-450a-bc35-47e0850f41a1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 1,
                  "endLine": 224,
                  "endColumn": 41,
                  "charOffset": 6943,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6943,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(priv->smu_tables.entry[table_id].table, <size of priv->smu_tables.entry[table_id].table>,  table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a8e6ede4-7d44-4ec9-8beb-f86e84d7eb1a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 1,
                  "endLine": 198,
                  "endColumn": 41,
                  "charOffset": 6123,
                  "charLength": 95,
                  "snippet": {
                    "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                    "rendered": {
                      "text": "memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)",
                      "markdown": "`memcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6123,
                        "charLength": 95
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table, <size of table>,  priv->smu_tables.entry[table_id].table, \n\t\t\tpriv->smu_tables.entry[table_id].size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eeb74c82-9dfb-415d-89fd-fad62d049cdd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dm_services.h"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 1,
                  "endLine": 258,
                  "endColumn": 10,
                  "charOffset": 8241,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a0452db4-d614-412e-b495-29b2d325ec82",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                },
                "region": {
                  "startLine": 1688,
                  "startColumn": 3,
                  "endLine": 1690,
                  "endColumn": 40,
                  "charOffset": 61481,
                  "charLength": 135,
                  "snippet": {
                    "text": "memcpy(&stream_sub_state_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_sub_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                    "rendered": {
                      "text": "memcpy(&stream_sub_state_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_sub_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                      "markdown": "`memcpy(&stream_sub_state_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_sub_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61481,
                        "charLength": 135
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&stream_sub_state_cmd->config, <size of &stream_sub_state_cmd->config>, \n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_sub_params[i], \n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cbc27326-8960-40d8-8722-35acae4530b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                },
                "region": {
                  "startLine": 1684,
                  "startColumn": 3,
                  "endLine": 1686,
                  "endColumn": 40,
                  "charOffset": 61306,
                  "charLength": 131,
                  "snippet": {
                    "text": "memcpy(&stream_base_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_base_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                    "rendered": {
                      "text": "memcpy(&stream_base_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_base_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)",
                      "markdown": "`memcpy(&stream_base_cmd->config,\n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_base_params[i],\n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 61306,
                        "charLength": 131
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&stream_base_cmd->config, <size of &stream_base_cmd->config>, \n\t\t\t\t\t&context->bw_ctx.bw.dcn.fams2_stream_base_params[i], \n\t\t\t\t\tsizeof(union dmub_cmd_fams2_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-00356fa8-7b8b-434f-bef5-e75af70f2949",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_12_ppt.c"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 1,
                  "endLine": 333,
                  "endColumn": 65,
                  "charOffset": 13222,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(metrics, smu_table->metrics_table, sizeof(MetricsTable_t)",
                    "rendered": {
                      "text": "memcpy(metrics, smu_table->metrics_table, sizeof(MetricsTable_t)",
                      "markdown": "`memcpy(metrics, smu_table->metrics_table, sizeof(MetricsTable_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_12_ppt.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13222,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(metrics, <size of metrics>,  smu_table->metrics_table,  sizeof(MetricsTable_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2142910b-79ba-4c2c-b529-aebe4ec0b2b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                },
                "region": {
                  "startLine": 1662,
                  "startColumn": 2,
                  "endLine": 1662,
                  "endColumn": 125,
                  "charOffset": 59798,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(&global_cmd->config.global, &context->bw_ctx.bw.dcn.fams2_global_config, sizeof(struct dmub_cmd_fams2_global_config)",
                    "rendered": {
                      "text": "memcpy(&global_cmd->config.global, &context->bw_ctx.bw.dcn.fams2_global_config, sizeof(struct dmub_cmd_fams2_global_config)",
                      "markdown": "`memcpy(&global_cmd->config.global, &context->bw_ctx.bw.dcn.fams2_global_config, sizeof(struct dmub_cmd_fams2_global_config)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 59798,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&global_cmd->config.global, <size of &global_cmd->config.global>,  &context->bw_ctx.bw.dcn.fams2_global_config,  sizeof(struct dmub_cmd_fams2_global_config)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e6d23402-8849-41ad-b717-21efb2ed6a9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                },
                "region": {
                  "startLine": 538,
                  "startColumn": 2,
                  "endLine": 540,
                  "endColumn": 43,
                  "charOffset": 16629,
                  "charLength": 154,
                  "snippet": {
                    "text": "memcpy(&dc->ctx->dmub_srv->dmub->visual_confirm_color,\n\t\t\t&cmd.visual_confirm_color.visual_confirm_color_data,\n\t\t\tsizeof(struct dmub_visual_confirm_color)",
                    "rendered": {
                      "text": "memcpy(&dc->ctx->dmub_srv->dmub->visual_confirm_color,\n\t\t\t&cmd.visual_confirm_color.visual_confirm_color_data,\n\t\t\tsizeof(struct dmub_visual_confirm_color)",
                      "markdown": "`memcpy(&dc->ctx->dmub_srv->dmub->visual_confirm_color,\n\t\t\t&cmd.visual_confirm_color.visual_confirm_color_data,\n\t\t\tsizeof(struct dmub_visual_confirm_color)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16629,
                        "charLength": 154
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc->ctx->dmub_srv->dmub->visual_confirm_color, <size of &dc->ctx->dmub_srv->dmub->visual_confirm_color>, \n\t\t\t&cmd.visual_confirm_color.visual_confirm_color_data, \n\t\t\tsizeof(struct dmub_visual_confirm_color)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b3a91ac4-285d-4592-aeec-940678b2af75",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                },
                "region": {
                  "startLine": 511,
                  "startColumn": 2,
                  "endLine": 513,
                  "endColumn": 41,
                  "charOffset": 15556,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy(&dc_dmub_srv->dmub->feature_caps,\n\t\t       &cmd.query_feature_caps.query_feature_caps_data,\n\t\t       sizeof(struct dmub_feature_caps)",
                    "rendered": {
                      "text": "memcpy(&dc_dmub_srv->dmub->feature_caps,\n\t\t       &cmd.query_feature_caps.query_feature_caps_data,\n\t\t       sizeof(struct dmub_feature_caps)",
                      "markdown": "`memcpy(&dc_dmub_srv->dmub->feature_caps,\n\t\t       &cmd.query_feature_caps.query_feature_caps_data,\n\t\t       sizeof(struct dmub_feature_caps)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/dc/dc_dmub_srv.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15556,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dc_dmub_srv->dmub->feature_caps, <size of &dc_dmub_srv->dmub->feature_caps>, \n\t\t       &cmd.query_feature_caps.query_feature_caps_data, \n\t\t       sizeof(struct dmub_feature_caps)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-34aa3d16-083a-493b-9c6e-28a809670466",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 2,
                  "endLine": 133,
                  "endColumn": 9,
                  "charOffset": 4525,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c2800b67-9f78-48e4-b47a-e252137b0103",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c"
                },
                "region": {
                  "startLine": 1892,
                  "startColumn": 1,
                  "endLine": 1892,
                  "endColumn": 66,
                  "charOffset": 56331,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(local_dc_state, dm_state->context, sizeof(struct dc_state)",
                    "rendered": {
                      "text": "memcpy(local_dc_state, dm_state->context, sizeof(struct dc_state)",
                      "markdown": "`memcpy(local_dc_state, dm_state->context, sizeof(struct dc_state)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56331,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(local_dc_state, <size of local_dc_state>,  dm_state->context,  sizeof(struct dc_state)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-703e2232-18e9-4a28-8d96-649d7d8281dc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 2,
                  "endLine": 128,
                  "endColumn": 9,
                  "charOffset": 4385,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-82480acc-0f24-4dd7-9f90-3524fe70e450",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 2,
                  "endLine": 123,
                  "endColumn": 9,
                  "charOffset": 4237,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e48aa6df-9400-4749-94df-a4468551bb2b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                },
                "region": {
                  "startLine": 1276,
                  "startColumn": 2,
                  "endLine": 1276,
                  "endColumn": 9,
                  "charOffset": 36857,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d9696685-b567-4beb-95d4-4aa2c9f9853a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                },
                "region": {
                  "startLine": 1181,
                  "startColumn": 1,
                  "endLine": 1181,
                  "endColumn": 39,
                  "charOffset": 34520,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(buf, (void *)edid + start, len)",
                    "rendered": {
                      "text": "memcpy(buf, (void *)edid + start, len)",
                      "markdown": "`memcpy(buf, (void *)edid + start, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34520,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  (void *)edid + start,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d054ac0b-8703-45a5-8e72-6b2e9669f85e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                },
                "region": {
                  "startLine": 864,
                  "startColumn": 2,
                  "endLine": 864,
                  "endColumn": 9,
                  "charOffset": 25401,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d35a0a6-e39f-4b30-a566-0d2615121e7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                },
                "region": {
                  "startLine": 685,
                  "startColumn": 3,
                  "endLine": 685,
                  "endColumn": 42,
                  "charOffset": 21597,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(buf, log_ctx->buf, log_ctx->pos)",
                    "rendered": {
                      "text": "memcpy(buf, log_ctx->buf, log_ctx->pos)",
                      "markdown": "`memcpy(buf, log_ctx->buf, log_ctx->pos)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21597,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf, <size of buf>,  log_ctx->buf,  log_ctx->pos)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ebc6b782-4d14-4979-9977-707ff6d1a5f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                },
                "region": {
                  "startLine": 4175,
                  "startColumn": 8,
                  "endLine": 4175,
                  "endColumn": 22,
                  "charOffset": 111037,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(rd_buf)",
                    "rendered": {
                      "text": "strlen(rd_buf)",
                      "markdown": "`strlen(rd_buf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111037,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(rd_buf, <size of rd_buf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 111037,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(rd_buf, <size of rd_buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-374a9bc9-b87f-417d-bb6f-68532e5804d4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 5,
                  "endLine": 672,
                  "endColumn": 14,
                  "charOffset": 21343,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b1007c1d-6cfb-4924-960b-3785d951e0b4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 11,
                  "endLine": 230,
                  "endColumn": 47,
                  "charOffset": 6486,
                  "charLength": 36,
                  "snippet": {
                    "text": "strlen(\"Preferred:  %d  0x%x  %d  \")",
                    "rendered": {
                      "text": "strlen(\"Preferred:  %d  0x%x  %d  \")",
                      "markdown": "`strlen(\"Preferred:  %d  0x%x  %d  \")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6486,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"Preferred:  %d  0x%x  %d  \", <size of \"Preferred:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6486,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "strnlen(\"Preferred:  %d  0x%x  %d  \", <size of \"Preferred:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6714608a-4d16-4b31-a5d3-b34393849847",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 11,
                  "endLine": 223,
                  "endColumn": 46,
                  "charOffset": 6235,
                  "charLength": 35,
                  "snippet": {
                    "text": "strlen(\"Reported:  %d  0x%x  %d  \")",
                    "rendered": {
                      "text": "strlen(\"Reported:  %d  0x%x  %d  \")",
                      "markdown": "`strlen(\"Reported:  %d  0x%x  %d  \")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6235,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"Reported:  %d  0x%x  %d  \", <size of \"Reported:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6235,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strnlen(\"Reported:  %d  0x%x  %d  \", <size of \"Reported:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c6e58be-60b0-40ee-8f15-4441401bcc9a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 11,
                  "endLine": 216,
                  "endColumn": 46,
                  "charOffset": 5984,
                  "charLength": 35,
                  "snippet": {
                    "text": "strlen(\"Verified:  %d  0x%x  %d  \")",
                    "rendered": {
                      "text": "strlen(\"Verified:  %d  0x%x  %d  \")",
                      "markdown": "`strlen(\"Verified:  %d  0x%x  %d  \")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5984,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"Verified:  %d  0x%x  %d  \", <size of \"Verified:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5984,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strnlen(\"Verified:  %d  0x%x  %d  \", <size of \"Verified:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7ec87b89-2924-48cf-9b29-0c4ae3677d90",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 11,
                  "endLine": 209,
                  "endColumn": 45,
                  "charOffset": 5735,
                  "charLength": 34,
                  "snippet": {
                    "text": "strlen(\"Current:  %d  0x%x  %d  \")",
                    "rendered": {
                      "text": "strlen(\"Current:  %d  0x%x  %d  \")",
                      "markdown": "`strlen(\"Current:  %d  0x%x  %d  \")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5735,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"Current:  %d  0x%x  %d  \", <size of \"Current:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5735,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strnlen(\"Current:  %d  0x%x  %d  \", <size of \"Current:  %d  0x%x  %d  \">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-36a610c0-a50b-4fee-8b83-8b3451490050",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 13062,
                  "startColumn": 2,
                  "endLine": 13063,
                  "endColumn": 31,
                  "charOffset": 392498,
                  "charLength": 79,
                  "snippet": {
                    "text": "memcpy(payload->data, p_notify->aux_reply.data,\n\t\t\t\tp_notify->aux_reply.length)",
                    "rendered": {
                      "text": "memcpy(payload->data, p_notify->aux_reply.data,\n\t\t\t\tp_notify->aux_reply.length)",
                      "markdown": "`memcpy(payload->data, p_notify->aux_reply.data,\n\t\t\t\tp_notify->aux_reply.length)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 392498,
                        "charLength": 79
                      },
                      "insertedContent": {
                        "text": "memcpy_s(payload->data, <size of payload->data>,  p_notify->aux_reply.data, \n\t\t\t\tp_notify->aux_reply.length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ace66e1c-fddc-4854-93bd-923e0b22c4ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 12577,
                  "startColumn": 1,
                  "endLine": 12577,
                  "endColumn": 37,
                  "charOffset": 378385,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(input->payload, data, length)",
                    "rendered": {
                      "text": "memcpy(input->payload, data, length)",
                      "markdown": "`memcpy(input->payload, data, length)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 378385,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(input->payload, <size of input->payload>,  data,  length)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f6e85a01-50b6-4a44-a321-a4ef994c1efc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 7894,
                  "startColumn": 1,
                  "endLine": 7894,
                  "endColumn": 33,
                  "charOffset": 231709,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&out->sb[i], &buf[4], 26)",
                    "rendered": {
                      "text": "memcpy(&out->sb[i], &buf[4], 26)",
                      "markdown": "`memcpy(&out->sb[i], &buf[4], 26)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 231709,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&out->sb[i], <size of &out->sb[i]>,  &buf[4],  26)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc8de7d8-749b-4af3-8fec-34ccb41ae8da",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detection of Prohibited C Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 7549,
                  "startColumn": 2,
                  "endLine": 7549,
                  "endColumn": 9,
                  "charOffset": 221612,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-82fe45ba-4920-4edf-be80-0da290ec53cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 1248,
                  "startColumn": 1,
                  "endLine": 1249,
                  "endColumn": 24,
                  "charOffset": 38592,
                  "charLength": 86,
                  "snippet": {
                    "text": "memcpy(fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr, adev->bios,\n\t       adev->bios_size)",
                    "rendered": {
                      "text": "memcpy(fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr, adev->bios,\n\t       adev->bios_size)",
                      "markdown": "`memcpy(fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr, adev->bios,\n\t       adev->bios_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38592,
                        "charLength": 86
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr, <size of fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr>,  adev->bios, \n\t       adev->bios_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5937bb56-4700-44cc-866d-3152ec96fdab",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 1244,
                  "startColumn": 2,
                  "endLine": 1245,
                  "endColumn": 39,
                  "charOffset": 38449,
                  "charLength": 92,
                  "snippet": {
                    "text": "memcpy(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr,\n\t\t       fw_bss_data, fw_bss_data_size)",
                    "rendered": {
                      "text": "memcpy(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr,\n\t\t       fw_bss_data, fw_bss_data_size)",
                      "markdown": "`memcpy(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr,\n\t\t       fw_bss_data, fw_bss_data_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38449,
                        "charLength": 92
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr, <size of fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr>, \n\t\t       fw_bss_data,  fw_bss_data_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53f80821-4017-4bbe-be84-835946764d3e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 1239,
                  "startColumn": 2,
                  "endLine": 1240,
                  "endColumn": 23,
                  "charOffset": 38325,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, fw_inst_const,\n\t\t\t\tfw_inst_const_size)",
                    "rendered": {
                      "text": "memcpy(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, fw_inst_const,\n\t\t\t\tfw_inst_const_size)",
                      "markdown": "`memcpy(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, fw_inst_const,\n\t\t\t\tfw_inst_const_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38325,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, <size of fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr>,  fw_inst_const, \n\t\t\t\tfw_inst_const_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7036db69-02b9-4044-8ce5-71baf76d73e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 2,
                  "endLine": 755,
                  "endColumn": 71,
                  "charOffset": 24233,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(adev->dm.dmub_notify, notify, sizeof(struct dmub_notification)",
                    "rendered": {
                      "text": "memcpy(adev->dm.dmub_notify, notify, sizeof(struct dmub_notification)",
                      "markdown": "`memcpy(adev->dm.dmub_notify, notify, sizeof(struct dmub_notification)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24233,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(adev->dm.dmub_notify, <size of adev->dm.dmub_notify>,  notify,  sizeof(struct dmub_notification)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ee0421fa-819f-408f-af3f-b4ab98bc431e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                },
                "region": {
                  "startLine": 453,
                  "startColumn": 1,
                  "endLine": 453,
                  "endColumn": 57,
                  "charOffset": 14756,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(roi_cpy, crtc_ctx->roi, sizeof(struct crc_window)",
                    "rendered": {
                      "text": "memcpy(roi_cpy, crtc_ctx->roi, sizeof(struct crc_window)",
                      "markdown": "`memcpy(roi_cpy, crtc_ctx->roi, sizeof(struct crc_window)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14756,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(roi_cpy, <size of roi_cpy>,  crtc_ctx->roi,  sizeof(struct crc_window)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3421b72b-97f6-41ed-afbf-06e2c3dd5c6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                },
                "region": {
                  "startLine": 381,
                  "startColumn": 1,
                  "endLine": 381,
                  "endColumn": 64,
                  "charOffset": 12392,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy(crc_cpy, crtc_ctx->crc_info.crc, sizeof(struct crc_data)",
                    "rendered": {
                      "text": "memcpy(crc_cpy, crtc_ctx->crc_info.crc, sizeof(struct crc_data)",
                      "markdown": "`memcpy(crc_cpy, crtc_ctx->crc_info.crc, sizeof(struct crc_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12392,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s(crc_cpy, <size of crc_cpy>,  crtc_ctx->crc_info.crc,  sizeof(struct crc_data)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e6f35a44-53a5-4e57-985a-53660a0c6550",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 3,
                  "endLine": 206,
                  "endColumn": 94,
                  "charOffset": 6705,
                  "charLength": 149,
                  "snippet": {
                    "text": "memcpy(dm->secure_display_ctx.phy_id_mapping[idx].rad,\n\t\t\t\taconnector->mst_output_port->parent->rad, sizeof(aconnector->mst_output_port->parent->rad)",
                    "rendered": {
                      "text": "memcpy(dm->secure_display_ctx.phy_id_mapping[idx].rad,\n\t\t\t\taconnector->mst_output_port->parent->rad, sizeof(aconnector->mst_output_port->parent->rad)",
                      "markdown": "`memcpy(dm->secure_display_ctx.phy_id_mapping[idx].rad,\n\t\t\t\taconnector->mst_output_port->parent->rad, sizeof(aconnector->mst_output_port->parent->rad)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6705,
                        "charLength": 149
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dm->secure_display_ctx.phy_id_mapping[idx].rad, <size of dm->secure_display_ctx.phy_id_mapping[idx].rad>, \n\t\t\t\taconnector->mst_output_port->parent->rad,  sizeof(aconnector->mst_output_port->parent->rad)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e16d9b7d-ff82-45e1-947d-91d7f4ac0ca4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                },
                "region": {
                  "startLine": 677,
                  "startColumn": 1,
                  "endLine": 677,
                  "endColumn": 33,
                  "charOffset": 21037,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(buffer, srm + pos, count)",
                    "rendered": {
                      "text": "memcpy(buffer, srm + pos, count)",
                      "markdown": "`memcpy(buffer, srm + pos, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21037,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer, <size of buffer>,  srm + pos,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-899e4a89-7e5a-454e-8be0-87597606c04e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 2,
                  "endLine": 672,
                  "endColumn": 43,
                  "charOffset": 20953,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(buffer, srm + pos, srm_size - pos)",
                    "rendered": {
                      "text": "memcpy(buffer, srm + pos, srm_size - pos)",
                      "markdown": "`memcpy(buffer, srm + pos, srm_size - pos)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20953,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer, <size of buffer>,  srm + pos,  srm_size - pos)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42ed4649-7b00-46fd-a020-028bf5a8e2f8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                },
                "region": {
                  "startLine": 637,
                  "startColumn": 2,
                  "endLine": 637,
                  "endColumn": 48,
                  "charOffset": 20252,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(work->srm, work->srm_temp, pos + count)",
                    "rendered": {
                      "text": "memcpy(work->srm, work->srm_temp, pos + count)",
                      "markdown": "`memcpy(work->srm, work->srm_temp, pos + count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20252,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(work->srm, <size of work->srm>,  work->srm_temp,  pos + count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88a12588-74e9-419e-ace0-7d10af9ca5e3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                },
                "region": {
                  "startLine": 633,
                  "startColumn": 1,
                  "endLine": 633,
                  "endColumn": 44,
                  "charOffset": 20048,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(work->srm_temp + pos, buffer, count)",
                    "rendered": {
                      "text": "memcpy(work->srm_temp + pos, buffer, count)",
                      "markdown": "`memcpy(work->srm_temp + pos, buffer, count)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20048,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(work->srm_temp + pos, <size of work->srm_temp + pos>,  buffer,  count)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b969c935-de3a-4203-a264-5479c87f72ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 1,
                  "endLine": 116,
                  "endColumn": 61,
                  "charOffset": 3872,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, srm, srm_size)",
                    "rendered": {
                      "text": "memcpy(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, srm, srm_size)",
                      "markdown": "`memcpy(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, srm, srm_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3872,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hdcp_cmd->in_msg.hdcp_set_srm.srm_buf, <size of hdcp_cmd->in_msg.hdcp_set_srm.srm_buf>,  srm,  srm_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-071545d7-4283-4822-938e-fb208b8d4fb2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 2,
                  "endLine": 161,
                  "endColumn": 42,
                  "charOffset": 4556,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(new_mods, *mods, sizeof(uint64_t)",
                    "rendered": {
                      "text": "memcpy(new_mods, *mods, sizeof(uint64_t)",
                      "markdown": "`memcpy(new_mods, *mods, sizeof(uint64_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4556,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_mods, <size of new_mods>,  *mods,  sizeof(uint64_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4633f17-e79d-4ca2-a774-50098f6f56e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c"
                },
                "region": {
                  "startLine": 618,
                  "startColumn": 1,
                  "endLine": 618,
                  "endColumn": 47,
                  "charOffset": 16594,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(smu_table->hardcode_pptable, buf, size)",
                    "rendered": {
                      "text": "memcpy(smu_table->hardcode_pptable, buf, size)",
                      "markdown": "`memcpy(smu_table->hardcode_pptable, buf, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16594,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(smu_table->hardcode_pptable, <size of smu_table->hardcode_pptable>,  buf,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc68a193-3608-45c8-9d28-307d51dfa63c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                },
                "region": {
                  "startLine": 1044,
                  "startColumn": 2,
                  "endLine": 1044,
                  "endColumn": 61,
                  "charOffset": 26918,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(metrics_table, smu_table->metrics_table, table_size)",
                    "rendered": {
                      "text": "memcpy(metrics_table, smu_table->metrics_table, table_size)",
                      "markdown": "`memcpy(metrics_table, smu_table->metrics_table, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26918,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(metrics_table, <size of metrics_table>,  smu_table->metrics_table,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-661f7bd4-e5d0-4f60-bb08-3944091822fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                },
                "region": {
                  "startLine": 988,
                  "startColumn": 2,
                  "endLine": 988,
                  "endColumn": 49,
                  "charOffset": 25668,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(table_data, table->cpu_addr, table_size)",
                    "rendered": {
                      "text": "memcpy(table_data, table->cpu_addr, table_size)",
                      "markdown": "`memcpy(table_data, table->cpu_addr, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25668,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table_data, <size of table_data>,  table->cpu_addr,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ba84dd43-9289-495e-a3a1-eedc7dd7804c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                },
                "region": {
                  "startLine": 970,
                  "startColumn": 2,
                  "endLine": 970,
                  "endColumn": 49,
                  "charOffset": 25206,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(table->cpu_addr, table_data, table_size)",
                    "rendered": {
                      "text": "memcpy(table->cpu_addr, table_data, table_size)",
                      "markdown": "`memcpy(table->cpu_addr, table_data, table_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25206,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(table->cpu_addr, <size of table->cpu_addr>,  table_data,  table_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8b24b94c-3d2f-4515-bec0-5221a314b226",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/pm/powerplay/amd_powerplay.c"
                },
                "region": {
                  "startLine": 671,
                  "startColumn": 1,
                  "endLine": 671,
                  "endColumn": 44,
                  "charOffset": 16255,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(hwmgr->hardcode_pp_table, buf, size)",
                    "rendered": {
                      "text": "memcpy(hwmgr->hardcode_pp_table, buf, size)",
                      "markdown": "`memcpy(hwmgr->hardcode_pp_table, buf, size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/pm/powerplay/amd_powerplay.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16255,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hwmgr->hardcode_pp_table, <size of hwmgr->hardcode_pp_table>,  buf,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9e782f13-deb5-4834-9c8b-804a1b8ef868",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                },
                "region": {
                  "startLine": 2798,
                  "startColumn": 1,
                  "endLine": 2798,
                  "endColumn": 42,
                  "charOffset": 83427,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(mgr->mst_primary->guid, &guid, 16)",
                    "rendered": {
                      "text": "memcpy(mgr->mst_primary->guid, &guid, 16)",
                      "markdown": "`memcpy(mgr->mst_primary->guid, &guid, 16)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 83427,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mgr->mst_primary->guid, <size of mgr->mst_primary->guid>,  &guid,  16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}